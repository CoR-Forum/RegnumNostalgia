/**
 * Map Initialization — tile probing, Leaflet map creation, tile overlays / tile layer,
 * markers.json loading, coordinate readout, pending-collectables flush.
 *
 * v1 uses leaflet-rastercoords + L.tileLayer with {z}/{x}/{y}.png tiles
 * generated by gdal2tiles-leaflet from a 6144×6144 source image.
 *
 * v2 uses 9 L.imageOverlay instances (3×3 grid of large PNGs).
 */

import { gameState } from './state.js';
import { setMapState, setTerritoryIcons, positionsToLatLngs, setRasterCoords, gameToLatLng, latLngToGame } from './map-state.js';
import './rastercoords.js'; // registers L.RasterCoords on the global L

const CDN_BASE = 'https://cor-forum.de/regnum/RegnumNostalgia/map';
const GAME_SIZE = 6144;

// --- v2 image overlay config ---
const V2_ROWS = 3;
const V2_COLS = 3;

let currentTileVersion = localStorage.getItem('tileVersion') || 'v1';
// Expose on window so settings.html can read/update it
window.currentTileVersion = currentTileVersion;

/**
 * Start map initialization.
 * For v1: immediately sets up map and tile layer (no probe needed).
 * For v2: probes a tile to determine dimensions, then sets up image overlays.
 */
export function initMap() {
  return new Promise((resolve, reject) => {
    if (currentTileVersion === 'v1') {
      initV1TiledMap(resolve, reject);
    } else {
      initV2OverlayMap(resolve, reject);
    }
  });
}

/**
 * v1: Leaflet tile layer using rastercoords for coordinate mapping.
 * The 6144×6144 source image matches game coords 1:1.
 */
function initV1TiledMap(resolve, reject) {
  const imgDims = [GAME_SIZE, GAME_SIZE]; // [width, height]

  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: 1,
    maxZoom: 7,
    maxBoundsViscosity: 0.5,
    zoomControl: false,
    scrollWheelZoom: true,
    doubleClickZoom: false,
    boxZoom: false,
    touchZoom: true,
    keyboard: false,
  });

  const rc = new L.RasterCoords(map, imgDims);
  // rc.zoomLevel() === 5 for 6144px/256px tiles
  map.setView(rc.unproject([imgDims[0] / 2, imgDims[1] / 2]), 3);

  setMapState(map, GAME_SIZE, GAME_SIZE);
  setRasterCoords(rc);

  let tileLayer = null;
  let tileOverlays = [];

  function loadTiles() {
    currentTileVersion = window.currentTileVersion || localStorage.getItem('tileVersion') || 'v1';

    tileOverlays.forEach((o) => map.removeLayer(o));
    tileOverlays = [];
    if (tileLayer) { map.removeLayer(tileLayer); tileLayer = null; }

    if (currentTileVersion === 'v1') {
      // Constrain tile loading to the image extent so Leaflet never requests
      // negative or out-of-range tile coordinates.
      const southWest = rc.unproject([0, imgDims[1]]);
      const northEast = rc.unproject([imgDims[0], 0]);
      tileLayer = L.tileLayer(`${CDN_BASE}/tiles-v1-compressed/{z}/{x}/{y}.png`, {
        noWrap: true,
        bounds: L.latLngBounds(southWest, northEast),
        maxNativeZoom: rc.zoomLevel(), // 5
      }).addTo(map);
    } else {
      // Fallback to v2 image overlays within the same map instance
      loadV2OverlaysOnRasterMap(map, rc, tileOverlays);
    }
  }
  loadTiles();
  window.loadTiles = loadTiles;

  setupMapExtras(map, GAME_SIZE, GAME_SIZE, resolve);
}

/**
 * v2: Probe first tile to get dimensions, then create 9 image overlays.
 */
function initV2OverlayMap(resolve, reject) {
  const probeUrl = `${CDN_BASE}/tiles-${currentTileVersion}/1-1.png`;
  const probe = new Image();
  probe.src = probeUrl;

  probe.onload = () => {
    const tileW = probe.width;
    const tileH = probe.height;
    const origTotalW = V2_COLS * tileW;
    const origTotalH = V2_ROWS * tileH;
    const baseScale = GAME_SIZE / origTotalW;

    let scaleX = baseScale;
    let scaleY = baseScale;
    if (currentTileVersion === 'v2') {
      scaleY = baseScale * 1.01;
    }

    const totalW = origTotalW * scaleX;
    const totalH = origTotalH * scaleY;

    const map = createLeafletMap();
    const fullBounds = [[0, 0], [totalH, totalW]];
    map.fitBounds(fullBounds);

    const pad = 1000 * Math.max(scaleX, scaleY);
    map.setMaxBounds([[-pad, -pad], [totalH + pad, totalW + pad]]);
    setMapState(map, totalH, totalW);

    let tileOverlays = [];
    let tileLayer = null;

    function loadTiles() {
      tileOverlays.forEach((o) => map.removeLayer(o));
      tileOverlays = [];
      if (tileLayer) { map.removeLayer(tileLayer); tileLayer = null; }

      loadV2Overlays(map, tileOverlays, totalH, totalW, tileW, tileH, scaleX, scaleY);
    }
    loadTiles();
    window.loadTiles = loadTiles;

    setupMapExtras(map, totalH, totalW, resolve);
  };

  probe.onerror = () => {
    console.error('Failed to load probe tile:', probeUrl);
    try { document.getElementById('map').innerText = 'Failed to load tiles. Check tiles/ filenames.'; } catch (e) {}
    reject(new Error('Tile probe failed'));
  };
}

/** Create the shared Leaflet map instance (same config for v1 and v2). */
function createLeafletMap() {
  return L.map('map', {
    crs: L.CRS.Simple,
    minZoom: -3,
    maxZoom: 2,
    maxBoundsViscosity: 0.5,
    zoomControl: false,
    scrollWheelZoom: true,
    doubleClickZoom: false,
    boxZoom: false,
    touchZoom: true,
    keyboard: false,
  });
}

/** Load v2 image overlays (3×3 grid) on the legacy CRS.Simple map. */
function loadV2Overlays(map, tileOverlays, totalH, totalW, tileW, tileH, scaleX, scaleY) {
  // If called from v1-initialised map (fallback), compute approximate values
  if (tileW === undefined) {
    tileW = totalW / V2_COLS;
    tileH = totalH / V2_ROWS;
    scaleX = 1;
    scaleY = 1;
  }
  for (let r = 1; r <= V2_ROWS; r++) {
    for (let c = 1; c <= V2_COLS; c++) {
      const rowPos = V2_ROWS - r;
      const y1 = rowPos * tileH * scaleY;
      const x1 = (c - 1) * tileW * scaleX;
      const y2 = (rowPos + 1) * tileH * scaleY;
      const x2 = c * tileW * scaleX;
      const url = `${CDN_BASE}/tiles-${currentTileVersion}/${r}-${c}.png`;
      const overlay = L.imageOverlay(url, [[y1, x1], [y2, x2]]).addTo(map);
      tileOverlays.push(overlay);
    }
  }
}

/**
 * Load v2 image overlays on a rastercoords-based map (v1 map switching to v2 tiles).
 * The rastercoords coordinate space differs from the legacy one, so we project
 * the tile corners through rc.unproject().
 */
function loadV2OverlaysOnRasterMap(map, rc, tileOverlays) {
  const tileW = GAME_SIZE / V2_COLS;
  const tileH = GAME_SIZE / V2_ROWS;
  for (let r = 1; r <= V2_ROWS; r++) {
    for (let c = 1; c <= V2_COLS; c++) {
      // Image-pixel corners (y=0 is top/north)
      const px1 = (c - 1) * tileW;
      const py1 = (r - 1) * tileH;
      const px2 = c * tileW;
      const py2 = r * tileH;
      const sw = rc.unproject([px1, py2]);
      const ne = rc.unproject([px2, py1]);
      const url = `${CDN_BASE}/tiles-${currentTileVersion}/${r}-${c}.png`;
      const overlay = L.imageOverlay(url, [sw, ne]).addTo(map);
      tileOverlays.push(overlay);
    }
  }
}

/**
 * Set up markers, coordinate readout, collectables, and resolve the promise.
 * Shared between v1 and v2 init paths.
 * Uses gameToLatLng / latLngToGame so it works with both rastercoords (v1) and
 * legacy CRS.Simple (v2) coordinate systems.
 */
function setupMapExtras(map, totalH, totalW, resolve) {
  function addRasterMarker(x, y, opts) {
    return L.marker(gameToLatLng(x, y), opts).addTo(map);
  }

  // Region display init
  try {
    if (typeof window.initRegionDisplay === 'function') {
      window.initRegionDisplay(map, gameState, window.apiCall, positionsToLatLngs);
    }
  } catch (e) { console.debug('initRegionDisplay failed', e); }

  L.control.scale({ metric: false, imperial: false }).addTo(map);

  // Load markers.json
  fetch('assets/markers.json').then((r) => r.json()).then((data) => {
    const icons = {};
    for (const [key, def] of Object.entries(data.icons || {})) {
      const size = def.size || [24, 24];
      const anchor = def.anchor || [Math.floor(size[0] / 2), size[1]];
      icons[key] = L.icon({
        iconUrl: def.url,
        iconSize: [size[0], size[1]],
        iconAnchor: [anchor[0], anchor[1]],
      });
    }
    setTerritoryIcons(icons);

    const layerIndex = {};
    const overlays = {};
    function toLatLng(p) { return gameToLatLng(p[0], p[1]); }

    for (const f of (data.features || [])) {
      let layer = null;
      if (f.type === 'marker') {
        const icon = f.icon && icons[f.icon] ? icons[f.icon] : undefined;
        layer = addRasterMarker(f.x, f.y, icon ? { icon } : undefined);
      } else if (f.type === 'circle') {
        layer = L.circle(toLatLng(f.center), { radius: f.radius || 50, color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
      } else if (f.type === 'polygon') {
        layer = L.polygon((f.points || []).map(toLatLng), { color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
      } else if (f.type === 'polyline') {
        layer = L.polyline((f.points || []).map(toLatLng), { color: f.color || '#3388ff', weight: f.weight || 3 }).addTo(map);
      } else if (f.type === 'group') {
        const members = (f.members || []).map((id) => layerIndex[id]).filter(Boolean);
        layer = L.layerGroup(members).addTo(map);
        overlays[f.name || f.id || ('group-' + Object.keys(overlays).length)] = layer;
      }
      if (layer) {
        if (f.popup) layer.bindPopup(f.popup);
        if (f.id) layerIndex[f.id] = layer;
      }
    }
    if (Object.keys(overlays).length > 0) {
      L.control.layers(null, overlays, { collapsed: false, position: 'bottomleft' }).addTo(map);
    }

    // Coordinate readout
    const coordsEl = document.getElementById('coords');
    if (coordsEl) {
      map.on('mousemove', (e) => {
        const game = latLngToGame(e.latlng);
        const displayX = Math.max(1, Math.min(GAME_SIZE, Math.floor(game.x) + 1));
        const displayY = Math.max(1, Math.min(GAME_SIZE, Math.floor(game.y) + 1));
        coordsEl.style.display = 'block';
        coordsEl.textContent = `${displayX}x${displayY}`;
        try { if (window.handleRegionMouseMove) window.handleRegionMouseMove(e); } catch (err) {}
      });
      map.on('mouseout', () => {
        coordsEl.style.display = 'none';
        const indicator = document.getElementById('walk-indicator');
        if (indicator) indicator.classList.remove('show');
      });
    }
  }).catch((err) => console.error('Failed to load markers.json', err));

  // Flush pending collectables
  if (gameState.pendingCollectables && gameState.pendingCollectables.length > 0) {
    console.debug('Processing', gameState.pendingCollectables.length, 'pending collectables');
    const pending = [...gameState.pendingCollectables];
    gameState.pendingCollectables = [];
    pending.forEach((item) => {
      if (typeof window.createCollectableMarker === 'function') window.createCollectableMarker(item);
    });
  }

  resolve({ map, totalH, totalW });
}

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Regnum Online Old World Map</title>

  <!-- Basic metadata -->
  <meta name="description" content="Interactive tiled map viewer for Regnum Online Old World. Pan and zoom the stitched map using Leaflet.">
  <meta name="keywords" content="Regnum Online, map, tiles, Leaflet, gaming, Old World, nostalgia">
  <meta name="author" content="Joshua Treudler">
  <meta name="robots" content="index,follow">
  <meta name="theme-color" content="#0d6efd">

  <!-- Social preview -->
  <meta property="og:title" content="Regnum Online Old World Map">
  <meta property="og:description" content="Interactive tiled map viewer for Regnum Online Old World.">
  <meta property="og:type" content="website">
  <meta property="og:image" content="assets/preview.png">
  <meta property="og:url" content="">
  <meta name="twitter:card" content="summary_large_image">

  <link rel="icon" href="assets/favicon.png" sizes="32x32">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    /* Background image shown behind tiles when panning outside bounds */
    #map{width:100vw;height:100vh; background: url('assets/background.jpg') center center / cover no-repeat}
      #coords {
        position: absolute;
        right: 12px;
        top: 12px;
        background: rgba(0,0,0,0.65);
        color: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        z-index: 1100;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        pointer-events: none;
        display: none;
      }

    /* Bottom-right author notice */
    #attribution{
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      line-height: 1;
    }
    #attribution a{ color: #fff; text-decoration: underline }
    /* Top-left logo */
    #logo{
      position: absolute;
      left: 12px; /* keep near edge but avoid default controls */
      top: 8px;
      width: 200px; /* increased size */
      height: auto;
      z-index: 1000;
      pointer-events: none;
    }
    /* Right-side stacked in-game map thumbnails */
    #side-maps{
      position: absolute;
      right: 12px;
      top: 50%; /* vertically center */
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
      pointer-events: auto;
      align-items: flex-end;
      /* allow expanded thumbnails to overflow left */
      will-change: transform;
    }
    .side-map{
      width: 120px;
      height: auto;
      border-radius: 6px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      transition: width 160ms ease, box-shadow 160ms ease;
      display: block;
      cursor: pointer;
      object-fit: contain;
      max-height: 30vh;
    }
    .side-map:focus{ outline: 2px solid rgba(13,110,253,0.6); outline-offset: 2px }
    .side-map:hover, .side-map:focus{
      width: auto; /* show native/original width */
      height: auto;
      max-width: 60vw; /* sensible cap so it doesn't overflow the viewport */
      max-height: 80vh;
      z-index: 2000;
      box-shadow: 0 8px 26px rgba(0,0,0,0.55);
    }
    /* Reduce size on very small viewports */
    @media (max-width: 480px){
      /* On small viewports, move thumbnails to a centered bottom row
         and allow horizontal scrolling if they overflow. */
      #side-maps{
        right: 0;
        left: 0;
        bottom: 12px;
        top: auto;
        transform: none;
        justify-content: center;
        align-items: center;
        padding: 0 12px;
        gap: 8px;
        flex-direction: row;
        overflow-x: auto;
        max-width: 100%;
      }
      .side-map{
        width: 28vw;
        max-width: 120px;
        height: auto;
      }
      .side-map:hover, .side-map:focus{
        width: 35vw;
        max-width: 160px;
        max-height: 50vh;
        z-index: 2000;
        box-shadow: 0 8px 26px rgba(0,0,0,0.55);
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="coords" aria-hidden="true"></div>
  <div id="side-maps" aria-label="Other in-game maps">
    <img class="side-map" src="assets/ingame-maps/map-alsius-ini.png" alt="Alsuis map" title="Alsuis" tabindex="0">
    <img class="side-map" src="assets/ingame-maps/map-ignis-ini.png" alt="Ignis map" title="Ignis" tabindex="0">
    <img class="side-map" src="assets/ingame-maps/map-syrtis-ini.png" alt="Syrtis map" title="Syrtis" tabindex="0">
    <img class="side-map" src="assets/ingame-maps/map-isla-beta.png" alt="Isla map" title="Isla" tabindex="0">
  </div>
  <img id="logo" src="assets/regnum-logo.png" alt="Regnum logo">
  <div id="attribution" aria-label="Map author and source">
    <a href="https://github.com/CoR-Forum/RegnumMap-Nostalgia" target="_blank" rel="noopener noreferrer">GitHub</a>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Configuration: 3 rows, 3 columns, tiles named `tiles/{row}-{col}.png`
    const rows = 3, cols = 3;
    const tileUrl = (r, c) => `assets/tiles/${r}-${c}.png`;

    // Load first tile to determine tile pixel size at runtime
    const probe = new Image();
    probe.src = tileUrl(1,1);
    probe.onload = () => {
      const tileW = probe.width;
      const tileH = probe.height;

      // Original stitched image pixel size (e.g. 3 * 1024 = 3072)
      const origTotalW = cols * tileW;
      const origTotalH = rows * tileH;

      // Desired raster coordinates size. The world should behave as 6144x6144
      // while the actual stitched image is 3072x3072. scale = 6144/3072 = 2
      const scale = 2;

      // Scaled world size used by Leaflet (map coordinate units)
      const totalW = origTotalW * scale;
      const totalH = origTotalH * scale;

      // Use CRS.Simple so coordinates map directly to pixels
      // Disable the default zoomControl (placed top-left) so we can
      // re-add it on the right side.
      const map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -3,
        maxZoom: 0,
        maxBoundsViscosity: 0.5,
        zoomControl: false
      });

      const fullBounds = [[0,0],[totalH,totalW]]; // [[y1,x1],[y2,x2]]
      map.fitBounds(fullBounds);

      // Snap back to bounds, but allow a padding buffer so users can pan slightly
      // outside before the map bounces back. Adjust `pad` (pixels) and
      // `maxBoundsViscosity` above to tune feel.
      const pad = 200 * scale; // pixels of padding outside the image (scaled)
      const paddedBounds = [[-pad, -pad], [totalH + pad, totalW + pad]];
      map.setMaxBounds(paddedBounds);

      // Helper: add markers using raster coordinates (6144x6144 space)
      // Example: addRasterMarker(x, y) where x/y are in the 6144x6144 space.
      // Y-axis: user coords have origin at top-left, Leaflet has origin at bottom-left
      function addRasterMarker(x, y, opts){
        // Leaflet expects [lat, lng] -> [y, x], and invert Y
        return L.marker([totalH - y, x], opts).addTo(map);
      }

      // Add each tile as an ImageOverlay positioned by scaled pixel bounds
      // Note: flip vertical ordering so rows 1 and 3 are swapped
      for(let r=1; r<=rows; r++){
        for(let c=1; c<=cols; c++){
          const rowPos = rows - r; // invert row index
          const y1 = rowPos * tileH * scale;
          const x1 = (c-1) * tileW * scale;
          const y2 = (rowPos + 1) * tileH * scale;
          const x2 = c * tileW * scale;
          L.imageOverlay(tileUrl(r,c), [[y1,x1],[y2,x2]]).addTo(map);
        }
      }

      L.control.scale({metric: false, imperial: false}).addTo(map);
      // Add zoom control on the right side
      L.control.zoom({ position: 'topright' }).addTo(map);

      // Load markers/shapes/icons from JSON and render them
      fetch('assets/markers.json').then(r => r.json()).then(data => {
        const icons = {};
        // Create Leaflet icons (scale sizes by `scale` so they fit raster coords)
        for(const [key, def] of Object.entries(data.icons||{})){
          const size = def.size || [24,24];
          const anchor = def.anchor || [Math.floor(size[0]/2), size[1]];
          icons[key] = L.icon({
            iconUrl: def.url,
            iconSize: [size[0], size[1]],
            iconAnchor: [anchor[0], anchor[1]]
          });
        }

        const layerIndex = {};
        const overlays = {};

        function toLatLng(p){ return [totalH - p[1], p[0]]; }

        for(const f of (data.features||[])){
          let layer = null;
          if(f.type === 'marker'){
            const icon = f.icon && icons[f.icon] ? icons[f.icon] : undefined;
            layer = addRasterMarker(f.x, f.y, icon ? {icon} : undefined);
          } else if(f.type === 'circle'){
            const c = toLatLng(f.center);
            layer = L.circle(c, { radius: (f.radius||50), color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polygon'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polygon(pts, { color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polyline'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polyline(pts, { color: f.color || '#3388ff', weight: f.weight || 3 }).addTo(map);
          } else if(f.type === 'group'){
            const members = (f.members||[]).map(id => layerIndex[id]).filter(Boolean);
            layer = L.layerGroup(members).addTo(map);
            // register group as an overlay so it can be toggled in the layer control
            overlays[f.name || f.id || ('group-' + Object.keys(overlays).length)] = layer;
          }

          if(layer){
            if(f.popup) layer.bindPopup(f.popup);
            if(f.id) layerIndex[f.id] = layer;
          }
        }
          // If any overlays (groups) were registered, add a layer control
          if(Object.keys(overlays).length > 0){
            L.control.layers(null, overlays, { collapsed: false, position: 'bottomleft' }).addTo(map);
          }
        // Coordinate readout: show raster coords (original pixel space) while hovering
        const coordsEl = document.getElementById('coords');
        if(coordsEl){
          map.on('mousemove', (e) => {
            const mapX = e.latlng.lng; // scaled x in 0..totalW
            const mapY = e.latlng.lat; // scaled y in 0..totalH (origin at bottom)
            // X: 1-based left-to-right using scaled coords
            const displayX = Math.max(1, Math.min(totalW, Math.floor(mapX) + 1));
            // Y: invert because mapY origin is bottom; top should be 1
            const displayY = Math.max(1, Math.min(totalH, Math.floor(totalH - mapY) + 1));
            coordsEl.style.display = 'block';
            coordsEl.textContent = `${displayX}x${displayY}`;
          });
          map.on('mouseout', () => { coordsEl.style.display = 'none'; });
        }
      }).catch(err => console.error('Failed to load markers.json', err));
    };

    probe.onerror = () => {
      console.error('Failed to load probe tile:', probe.src);
      document.getElementById('map').innerText = 'Failed to load tiles. Check tiles/ filenames.';
    };
  </script>
  
</body>
</html>

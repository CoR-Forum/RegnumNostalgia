<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Regnum Nostalgia - Old World Interactive Map & Browser Game</title>

  <!-- Basic metadata -->
  <meta name="description" content="Experience Regnum Online's Old World in this nostalgic browser-based RPG. Explore the classic map, battle monsters, complete quests, and relive the golden age of Champions of Regnum.">
  <meta name="keywords" content="Regnum Nostalgia, Regnum Online, Champions of Regnum, Old World, browser game, RPG, MMORPG, interactive map, retro game, nostalgia, fantasy RPG, online game">
  <meta name="author" content="Joshua Treudler">
  <meta name="robots" content="index,follow">
  <meta name="theme-color" content="#8b4513">

  <!-- Social preview -->
  <meta property="og:title" content="Regnum Nostalgia - Relive the Old World">
  <meta property="og:description" content="Experience the classic Regnum Online Old World in this nostalgic browser-based RPG. Explore, battle, and quest in the legendary realm of Champions of Regnum.">
  <meta property="og:type" content="game">
  <meta property="og:image" content="assets/preview.png">
  <meta property="og:url" content="">
  <meta property="og:site_name" content="Regnum Nostalgia">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Regnum Nostalgia - Relive the Old World">
  <meta name="twitter:description" content="Experience the classic Regnum Online Old World in this nostalgic browser-based RPG.">
  <meta name="twitter:image" content="assets/preview.png">

  <link rel="icon" href="assets/favicon.png" sizes="32x32">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    /* Utility: hide elements by adding the `hidden` class */
    .hidden { display: none !important; }

    /* Prevent dragging of UI images (compass, character status, inventory icons) */
    #ui-compass img,
    #ui-character-status img,
    #inventory-window img {
      -webkit-user-drag: none;
      user-drag: none;
      -khtml-user-drag: none;
    }

    /* Prevent the page from scrolling; map handles panning */
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
    /* Map fills the viewport */
    #map { width: 100vw; height: 100vh; margin: 0; padding: 0; background: url('assets/background.jpg') center center / cover no-repeat; }
      #coords {
        .ui-hud-btn{
          width: 39px;
          height: 39px;
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center center;
          border: none;
          padding: 0;
          margin: 0;
          cursor: pointer;
          pointer-events: auto; /* allow clicks */
          z-index: 20002;
          background-color: transparent;
          flex: 0 0 auto;
        }

        /* HUD group layout */
        .ui-bar-right{ position: relative; }
        .ui-hud-group{ position: absolute; right: 12px; bottom: 8px; display:flex; gap:8px; align-items:flex-end; pointer-events: auto; }

        /* per-action icons (base/hover/pressed) */
        .ui-hud-btn[data-action="inventory"]{ background-image: url('assets/v1/hud/ui-icon-inventory-base.png'); }
        .ui-hud-btn[data-action="inventory"]:hover{ background-image: url('assets/v1/hud/ui-icon-inventory-hover.png'); }
        .ui-hud-btn[data-action="inventory"]:active{ background-image: url('assets/v1/hud/ui-icon-inventory-pressed.png'); }

        .ui-hud-btn[data-action="character"]{ background-image: url('assets/v1/hud/ui-icon-character-base.png'); }
        .ui-hud-btn[data-action="character"]:hover{ background-image: url('assets/v1/hud/ui-icon-character-hover.png'); }
        .ui-hud-btn[data-action="character"]:active{ background-image: url('assets/v1/hud/ui-icon-character-pressed.png'); }

        .ui-hud-btn[data-action="actions"]{ background-image: url('assets/v1/hud/ui-icon-actions-base.png'); }
        .ui-hud-btn[data-action="actions"]:hover{ background-image: url('assets/v1/hud/ui-icon-actions-hover.png'); }
        .ui-hud-btn[data-action="actions"]:active{ background-image: url('assets/v1/hud/ui-icon-actions-pressed.png'); }

        .ui-hud-btn[data-action="party"]{ background-image: url('assets/v1/hud/ui-icon-party-base.png'); }
        .ui-hud-btn[data-action="party"]:hover{ background-image: url('assets/v1/hud/ui-icon-party-hover.png'); }
        .ui-hud-btn[data-action="party"]:active{ background-image: url('assets/v1/hud/ui-icon-party-pressed.png'); }

        .ui-hud-btn[data-action="premium"]{ background-image: url('assets/v1/hud/ui-icon-premium-base.png'); }
        .ui-hud-btn[data-action="premium"]:hover{ background-image: url('assets/v1/hud/ui-icon-premium-hover.png'); }
        .ui-hud-btn[data-action="premium"]:active{ background-image: url('assets/v1/hud/ui-icon-premium-pressed.png'); }

        .ui-hud-btn[data-action="quests"]{ background-image: url('assets/v1/hud/ui-icon-quests-base.png'); }
        .ui-hud-btn[data-action="quests"]:hover{ background-image: url('assets/v1/hud/ui-icon-quests-hover.png'); }
        .ui-hud-btn[data-action="quests"]:active{ background-image: url('assets/v1/hud/ui-icon-quests-pressed.png'); }

        .ui-hud-btn[data-action="spellbook"]{ background-image: url('assets/v1/hud/ui-icon-spellbook-base.png'); }
        .ui-hud-btn[data-action="spellbook"]:hover{ background-image: url('assets/v1/hud/ui-icon-spellbook-hover.png'); }
        .ui-hud-btn[data-action="spellbook"]:active{ background-image: url('assets/v1/hud/ui-icon-spellbook-pressed.png'); }

        /* Persisted pressed state when the corresponding window is open */
        .ui-hud-btn.pressed[data-action="inventory"]{ background-image: url('assets/v1/hud/ui-icon-inventory-pressed.png'); }
        .ui-hud-btn.pressed[data-action="character"]{ background-image: url('assets/v1/hud/ui-icon-character-pressed.png'); }
      z-index: 1100;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: auto;
    }
    
    #header-actions {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20010;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    #header-actions .btn-logout{
      pointer-events: auto;
    }

    /* Login/Realm Modal Styles */
    #modal-overlay{
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    #modal-overlay.hidden{ display: none; }

    /* Hide all UI elements until the user is authenticated. Keep the modal overlay, background map, and mini info window visible. */
    body:not(.authenticated) > :not(#modal-overlay):not(#map):not(#mini-info-window):not(script):not(style) {
      display: none !important;
    }

    /* Show mini info window only on the login screen (when NOT authenticated).
       Hide it when the user is authenticated / in-game. */
    body.authenticated #mini-info-window { display: none !important; }
    body:not(.authenticated) #mini-info-window { display: flex !important; }

    .modal-content{
      background: transparent;
      border: none;
      padding: 0;
      max-width: 252px;
      width: 90%;
      position: relative;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }
    .modal-content::before{
      display: none;
    }

    .modal-step{ display: none; }
    .modal-step.active{ display: block; }
    /* Map context menu (right-click) */
    .map-contextmenu{
      position: absolute;
      background: #1f2937;
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      font-size: 13px;
      z-index: 20000;
      display: none;
      min-width: 96px;
      pointer-events: auto;
    }
    .map-contextmenu .map-contextmenu-item{
      padding: 6px 10px;
      cursor: pointer;
      border-radius: 4px;
    }
    .map-contextmenu .map-contextmenu-item:hover{ background: rgba(255,255,255,0.04) }

    /* Screenshot markers */
    .screenshot-marker {
      background: transparent;
      border: none;
    }
    .screenshot-dot {
      width: 8px;
      height: 8px;
      background: rgba(128, 128, 128, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .screenshot-marker:hover .screenshot-dot {
      background: rgba(128, 128, 128, 0.8);
      transform: scale(1.3);
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
    }
    .screenshot-tooltip {
      background: linear-gradient(180deg, rgba(20,22,26,0.98), rgba(10,12,15,0.98)) !important;
      border: 1px solid #2a2f37 !important;
      box-shadow: 0 6px 12px rgba(0,0,0,0.6) !important;
      padding: 8px !important;
      border-radius: 4px !important;
    }
    /* Player tooltip styling */
    .player-tooltip .leaflet-tooltip-content{
      background: linear-gradient(180deg, rgba(20,22,26,0.98), rgba(10,12,15,0.98));
      color: #e6e6e6;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 6px 12px rgba(0,0,0,0.6);
      white-space: nowrap;
      pointer-events: none;
    }
    .screenshot-tooltip .leaflet-tooltip-content {
      margin: 0 !important;
    }

    .modal-title{
      /* Now using ui-window-titlebar styling */
    }

    .modal-body{
      /* Now using ui-window-body styling with 9-slice border-image */
      padding-left: 16px;
      padding-right: 16px;
      padding-bottom: 16px;
    }

    .form-group{
      margin-bottom: 14px;
    }

    .form-label{
      display: block;
      color: #e0e0e0;
      font-size: 11px;
      margin-bottom: 4px;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }
    .item-icon img{
      width: 28px;
      height: 28px;
      object-fit: contain;
      image-rendering: pixelated;
    }

    .form-input{
      width: 100%;
      padding: 3px 8px;
      border: 1px solid #444;
      background: #2a2a2a;
      color: #e0e0e0;
      font-size: 11px;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      box-sizing: border-box;
      transition: none;
    }
    .form-input:focus{
      outline: 1px solid #0d6efd;
      outline-offset: 0;
      border-color: #0d6efd;
    }

    .btn{
      width: 100%;
      padding: 4px 12px;
      border: 1px solid #444;
      font-size: 11px;
      font-weight: 400;
      cursor: pointer;
      transition: background 0.2s;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .btn-primary{
      background: #4a4a4a;
      color: #ffffff;
      border-color: #4a4a4a;
    }
    .btn-primary:hover{ background: #5a5a5a; }
    .btn-primary:active{
      background: #3a3a3a;
    }
    .btn-primary:disabled{
      background: #2a2a2a;
      color: #666;
      cursor: not-allowed;
      border-color: #333;
    }

    .realm-cards{
      display: flex;
      flex-direction: row;
      gap: 8px;
      margin-top: 12px;
    }

    .realm-card{
      padding: 8px;
      border: 1px solid #444;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      background: #2a2a2a;
      color: #e0e0e0;
      flex: 1;
      text-align: center;
    }
    .realm-card:hover{
      background: #333;
      border-color: #555;
    }
    .realm-card:active{
      background: #1a1a1a;
    }

    .realm-card.syrtis{
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .realm-card.alsius{
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .realm-card.ignis{
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .realm-icon{
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
    }
    .realm-icon img{
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .realm-info h3{
      margin: 0 0 2px 0;
      font-size: 11px;
      font-weight: 700;
    }
    .realm-info p{
      margin: 0;
      font-size: 11px;
      opacity: 1;
    }

    .error-message{
      background: #3a1a1a;
      color: #ff6b6b;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 11px;
      border: 1px solid #661a1a;
    }
    .error-message.hidden{ display: none; }

    .loading-spinner{
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin{
      to{ transform: rotate(360deg); }
    }



    .realm-badge{
      display: inline-block;
      width: 10px;
      height: 10px;
    }
    .realm-badge.syrtis{ background: #008000; }
    .realm-badge.alsius{ background: #0000ff; }
    .realm-badge.ignis{ background: #ff0000; }

    .player-info-body{
      padding: 8px;
      background: transparent;
    }

    .player-coords{
      font-size: 11px;
      color: #e0e0e0;
      margin-bottom: 8px;
    }

    .btn-logout{
      padding: 4px 8px;
      background: #2a2a2a;
      color: #e0e0e0;
      border: 1px solid #444;
      cursor: pointer;
      font-size: 11px;
      width: 100%;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      transition: background 0.2s;
      text-shadow: none;
      box-shadow: none;
      margin-bottom: 4px;
    }
    .btn-logout:hover{ 
      background: #333;
    }
    .btn-logout:active{
      background: #1a1a1a;
    }

    /* Territory Health Bar Styles */
    .territory-marker{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .territory-icon{
      width: 32px;
      height: 32px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    .territory-health-bar{
      width: 40px;
      height: 4px;
      background: rgba(0,0,0,0.5);
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.3);
    }
    /* Hide map-mounted territory health bars by default but keep layout/space. */
    .territory-health-bar {
      opacity: 0;
      transition: opacity 0.16s ease;
      pointer-events: none; /* don't block map interactions */
    }
    /* Reveal territory health bars when hovering markers or when they receive focus. */
    .custom-territory-marker:hover .territory-health-bar,
    .custom-player-marker:hover .territory-health-bar,
    .custom-territory-marker:focus .territory-health-bar,
    .custom-player-marker:focus .territory-health-bar {
      opacity: 1;
      pointer-events: auto;
    }
    .territory-health-fill{
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    /* Allies (same realm / self) */
    .health-ally{ background-color: #22c55e; }
    /* Enemies (other realms) */
    .health-enemy{ background-color: #ef4444; }
    /* Status-based helpers (kept for compatibility) */
    .health-medium{ background-color: #eab308; }
    .health-low{ background-color: #ef4444; }

    /* Inventory Grid Styles */
    .inventory-grid{
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border: 2px solid #1a2538;
      border-radius: 3px;
    }

    /* Dark scrollbar - reusable class */
    .dark-scrollbar {
      scrollbar-width: thin; /* Firefox */
      scrollbar-color: rgba(0,0,0,0.6) rgba(0,0,0,0.08);
    }
    .dark-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
    .dark-scrollbar::-webkit-scrollbar-track { background: rgba(0,0,0,0.08); border-radius: 6px; }
    .dark-scrollbar::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.6); border-radius: 6px; border: 2px solid rgba(0,0,0,0); background-clip: padding-box; }
    .dark-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.75); }

    /* Inventory window sizing */
    #inventory-window{
      height: 600px;
      max-height: 600px;
    }
    #inventory-list{
      overflow-y: auto;
      flex: 1 1 auto;
      min-height: 0;
      padding-right: 30px;
    }

    /* Equipment Slot Styles */
    .equipment-area{ padding: 8px; border: 2px solid #1a2538; border-radius: 3px; margin-bottom: 8px; background: transparent;}    
    .equipment-row{ display:flex; gap:6px; justify-content: flex-start; margin-bottom:6px; }
    .equipment-slot{ width:44px; height:44px; background: transparent; border: 2px solid #2a3f5f; border-radius: 4px; display:flex; align-items:center; justify-content:center; position:relative; cursor:pointer; background-size: contain; background-position: center; background-repeat: no-repeat; }
    /* Character styles moved to public/character.html */
    .char-stat-row{ display:flex; justify-content:space-between; gap: 8px; margin: 2px 0; }
    .char-status{ display:flex; justify-content:space-between; color: #ef4444; font-weight: 700; }

    /* Visual for items that cannot be equipped into any slot */
    .not-equippable{ opacity: 0.6; filter: grayscale(80%); }

    /* Brief invalid equip animation (flash) */
    .invalid-equip{ animation: invalidFlash 0.35s ease-in-out; }
    @keyframes invalidFlash{ 0%{ box-shadow: 0 0 0 rgba(255,0,0,0); } 50%{ box-shadow: 0 0 8px rgba(255,0,0,0.8); } 100%{ box-shadow: 0 0 0 rgba(255,0,0,0); } }

    .inventory-slot{
      aspect-ratio: 1;
      background: transparent;
      border: 2px solid #2a3f5f;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.15s;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    }
    .inventory-slot:hover{
      border-color: #4a6f9f;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(74,111,159,0.4);
    }
    .inventory-slot.empty{
      opacity: 0.5;
    }

    .slot-icon{
      font-size: 32px;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.7));
    }
    .slot-icon img{
      width: 40px;
      height: 40px;
      object-fit: contain;
      image-rendering: pixelated;
      display: block;
    }

    .slot-quantity{
      position: absolute;
      bottom: 2px;
      right: 4px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      padding: 1px 4px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .slot-rarity-border{
      position: absolute;
      inset: -2px;
      border-radius: 3px;
      pointer-events: none;
    }
    .slot-rarity-border.common{ border: 2px solid #6b7280; }
    .slot-rarity-border.uncommon{ border: 2px solid #22c55e; box-shadow: 0 0 6px rgba(34,197,94,0.3); }
    .slot-rarity-border.rare{ border: 2px solid #3b82f6; box-shadow: 0 0 6px rgba(59,130,246,0.3); }
    .slot-rarity-border.epic{ border: 2px solid #a855f7; box-shadow: 0 0 6px rgba(168,85,247,0.3); }

    .item-tooltip{
      position: fixed;
      background: linear-gradient(180deg, rgba(20,22,26,0.98), rgba(10,12,15,0.98));
      border: 1px solid #2a2f37;
      padding: 8px 10px;
      color: #e6e6e6;
      font-size: 11px;
      z-index: 10001;
      pointer-events: none;
      box-shadow: 0 6px 12px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.04);
      max-width: 208px;
      line-height: 1.35;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }
    .item-tooltip::before{
      content: "";
      position: absolute;
      inset: 2px;
      border: 1px solid rgba(0,0,0,0.6);
      pointer-events: none;
    }
    .item-tooltip .tooltip-name{
      font-weight: 700;
      font-size: 12px;
      margin-bottom: 2px;
      color: #e6e6e6;
      text-shadow: 0 1px 0 rgba(0,0,0,0.8);
    }
    .item-tooltip .tooltip-name.common{ color: #b5b5b5; }
    .item-tooltip .tooltip-name.uncommon{ color: #7ee787; }
    .item-tooltip .tooltip-name.rare{ color: #7aa2ff; }
    .item-tooltip .tooltip-name.epic{ color: #c084fc; }
    .item-tooltip .tooltip-header{
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 2px;
    }
    .item-tooltip .tooltip-icon{
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      line-height: 1;
      color: #e6e6e6;
      flex: 0 0 auto;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.7));
    }
    .item-tooltip .tooltip-icon img{
      width: 20px;
      height: 20px;
      object-fit: contain;
      image-rendering: pixelated;
      display: block;
    }
    .item-tooltip .tooltip-title{
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }
    .item-tooltip .tooltip-level{
      font-size: 9px;
      color: #cfcfcf;
      margin-left: 6px;
      font-weight: 700;
      background: rgba(0,0,0,0.35);
      padding: 1px 4px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .item-tooltip .tooltip-type{
      font-size: 10px;
      color: #cfcfcf;
      margin-bottom: 6px;
      text-transform: none;
    }
    .item-tooltip .tooltip-description{
      color: #c8c8c8;
      font-size: 10px;
      margin-bottom: 6px;
      font-style: normal;
    }
    .item-tooltip .tooltip-stats{
      font-size: 10px;
      color: #77c2ff;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding-top: 6px;
      margin-top: 6px;
      white-space: nowrap;
    }
    .item-tooltip .tooltip-rarity{
      font-size: 10px;
      text-transform: uppercase;
      font-weight: 600;
      margin-top: 6px;
      color: #6ee787;
    }
    .item-tooltip .tooltip-rarity.common{ color: #b5b5b5; }
    .item-tooltip .tooltip-rarity.uncommon{ color: #7ee787; }
    .item-tooltip .tooltip-rarity.rare{ color: #7aa2ff; }
    .item-tooltip .tooltip-rarity.epic{ color: #c084fc; }

    /* Inventory Item Styles - compact smart list */
    .inventory-item{
      height: 32px;
      min-height: 32px;
      background: transparent;
      border: none;
      padding: 0 6px;
      margin-bottom: 2px;
      display: flex;
      gap: 8px;
      align-items: center;
      transition: background 0.12s, color 0.12s;
    }
    .inventory-item:hover{ background: rgba(13,110,253,0.12); color: #ffffff; }

    .item-icon{
      position: relative;
      width: 32px;
      height: 32px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
      line-height: 1;
    }

    .item-name{
      flex: 1 1 auto;
      min-width: 0;
      font-weight: 400;
      font-size: 11px;
      color: #e0e0e0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .item-name.common{ color: #b5b5b5; }
    .item-name.uncommon{ color: #7ee787; }
    .item-name.rare{ color: #7aa2ff; }
    .item-name.epic{ color: #c084fc; }

    .item-name .item-level{ font-size: 9px; color: #cfcfcf; margin-left: 6px; font-weight: 700; background: transparent; padding: 0 3px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.04); }

    .item-quantity{
      flex: 0 0 auto;
      font-size: 11px;
      color: #cfcfcf;
      margin-left: 6px;
      padding-left: 6px;
      border-left: 1px solid rgba(255,255,255,0.04);
    }
  </style>
</head>
<body>
  <!-- Login window loader (define but don't fetch immediately) -->
  <script>
    // Load the login modal HTML into the document when needed.
    // Returns a Promise that resolves after scripts have been appended.
    window.loadLoginForm = function loadLoginForm() {
      return fetch('login.html').then(r => r.text()).then(html => {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;

        // Move non-script nodes directly to body (not into a container)
        Array.from(tmp.childNodes).forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'script') return;
          document.body.appendChild(node);
        });

        // Execute inline scripts and load external scripts (if any)
        const scripts = tmp.querySelectorAll('script');
        scripts.forEach(s => {
          const ns = document.createElement('script');
          if (s.src) ns.src = s.src;
          else ns.textContent = s.textContent;
          document.body.appendChild(ns);
        });
      }).catch(err => console.error('Failed to load login window:', err));
    };
  </script>

  <!-- Inventory Window -->
  <div id="inventory-window" class="ui-window" style="position: absolute; right: 12px; bottom: 62px; width: 304px; z-index: 1000; display: none; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
    <div id="inventory-header" class="ui-window-titlebar" style="cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none;">
      <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff; font-family: 'MS Sans Serif', Arial, sans-serif; text-align: center;">Inventory</h2>
      <button id="inventory-close-btn" class="ui-window-close-btn"></button>
    </div>

    <div class="ui-window-body" style="padding: 10px 10px 0 10px;">
      <div class="equipment-area">
        <div class="equipment-row" id="equipment-row-top">
          <div class="equipment-slot empty" data-slot="head" title="Head"></div>
          <div class="equipment-slot empty" data-slot="body" title="Body"></div>
          <div class="equipment-slot empty" data-slot="hands" title="Hands"></div>
          <div class="equipment-slot empty" data-slot="shoulders" title="Shoulders"></div>
          <div class="equipment-slot empty" data-slot="legs" title="Legs"></div>
        </div>
        <div class="equipment-row" id="equipment-row-bottom">
          <div class="equipment-slot empty" data-slot="weaponRight" title="Weapon R"></div>
          <div class="equipment-slot empty" data-slot="weaponLeft" title="Weapon L"></div>
          <div class="equipment-slot empty" data-slot="ringRight" title="Ring R"></div>
          <div class="equipment-slot empty" data-slot="ringLeft" title="Ring L"></div>
          <div class="equipment-slot empty" data-slot="amulet" title="Amulet"></div>
        </div>
      </div>
    </div>

    <div id="inventory-list" class="ui-window-body dark-scrollbar" style="padding: 20px 8px;">
      <div id="inventory-loading" style="text-align: center; color: #e0e0e0; padding: 40px;">
        <div class="loading-spinner" style="margin: 0 auto 12px;"></div>
        <div style="font-size: 11px;">Loading inventory...</div>
      </div>
      <div id="inventory-items" style="display: none;"></div>
      <div id="inventory-empty" style="text-align: center; color: #e0e0e0; padding: 40px; display: none; font-size: 11px;">
        Your inventory is empty
      </div>
    </div>
    <div id="inventory-footer" class="ui-window-body" style="padding: 20px 8px; display: none;">
      <div style="display: flex; align-items: center; gap: 4px; color: #e0e0e0; font-size: 11px;">
        <img src="https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-gold.png" alt="Gold" style="width: 14px; height: 14px; display: inline-block;" draggable="false" ondragstart="return false;">
        <span id="inventory-gold" style="font-weight: 400;">0 Gold</span>
      </div>
    </div>
  </div>
  
  <!-- Build Path panel moved to public/build-path.js -->

  <div id="settings-include"></div>

  <!-- Player info moved into the top-left character-status overlay -->

  <div id="map"></div>
  <div id="coords" aria-hidden="true"></div>
  
  <!-- Character window loaded from separate file -->
  <div id="character-include"></div>
  <script>
    (function(){
      fetch('character.html').then(r => r.text()).then(html => {
        const container = document.getElementById('character-include');
        if (!container) return;
        const tmp = document.createElement('div');
        tmp.innerHTML = html;

        // Move non-script nodes into the container
        Array.from(tmp.childNodes).forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'script') return;
          container.appendChild(node);
        });

        // Execute inline scripts and load external scripts (if any)
        const scripts = tmp.querySelectorAll('script');
        scripts.forEach(s => {
          const ns = document.createElement('script');
          if (s.src) ns.src = s.src;
          else ns.textContent = s.textContent;
          document.body.appendChild(ns);
        });

        try { if (typeof initWindows === 'function') initWindows(); } catch (e) {}
      }).catch(err => console.error('Failed to load character window:', err));
    })();
  </script>

  <script>
    (function(){
      fetch('settings.html').then(r => r.text()).then(html => {
        const container = document.getElementById('settings-include');
        if (!container) return;
        const tmp = document.createElement('div');
        tmp.innerHTML = html;

        // Move non-script nodes into container
        Array.from(tmp.childNodes).forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'script') return;
          container.appendChild(node);
        });

        // Execute inline scripts and load external scripts (if any)
        const scripts = tmp.querySelectorAll('script');
        scripts.forEach(s => {
          const ns = document.createElement('script');
          if (s.src) ns.src = s.src;
          else ns.textContent = s.textContent;
          document.body.appendChild(ns);
        });
      }).catch(err => console.error('Failed to load settings include:', err));
    })();
  </script>

  <!-- Screenshots Window -->
  <div id="screenshots-window" class="ui-window" style="position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 580px; height: 480px; z-index: 10000; display: none; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
    <div id="screenshots-header" class="ui-window-titlebar" style="cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none;">
      <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff; text-align: center;">Screenshots Manager</h2>
      <button id="screenshots-close-btn" class="ui-window-close-btn"></button>
    </div>

    <div class="ui-window-body" style="padding: 8px; display: flex; gap: 8px; height: 100%; overflow: hidden;">
      <!-- Left side: Form -->
      <div style="flex: 1; display: flex; flex-direction: column; gap: 6px; overflow-y: auto;">
        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Screenshot File *</label>
          <input type="file" id="screenshot-file-input" accept="image/jpeg,image/jpg,image/png,image/gif,image/webp" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
          <div id="screenshot-preview" style="margin-top: 6px; max-height: 100px; overflow: hidden; border: 1px solid #2a3f5f; border-radius: 2px; display: none;">
            <img id="screenshot-preview-img" style="width: 100%; height: auto; display: block;">
          </div>
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Name (EN)</label>
          <input type="text" id="screenshot-name-en" placeholder="English name" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Name (DE)</label>
          <input type="text" id="screenshot-name-de" placeholder="Deutscher Name" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Name (ES)</label>
          <input type="text" id="screenshot-name-es" placeholder="Nombre español" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Description (EN)</label>
          <textarea id="screenshot-desc-en" placeholder="English description" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px; resize: vertical; min-height: 40px;"></textarea>
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Description (DE)</label>
          <textarea id="screenshot-desc-de" placeholder="Deutsche Beschreibung" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px; resize: vertical; min-height: 40px;"></textarea>
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Description (ES)</label>
          <textarea id="screenshot-desc-es" placeholder="Descripción española" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px; resize: vertical; min-height: 40px;"></textarea>
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Location</label>
          <input type="text" id="screenshot-location" placeholder="e.g., Alsius Castle" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
        </div>

        <div style="font-size: 10px; color: #e0e0e0;">
          <label style="display: block; margin-bottom: 3px; font-weight: 600;">Visible Characters</label>
          <input type="text" id="screenshot-characters" placeholder="e.g., PlayerName1, PlayerName2" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
          <div style="font-size: 8px; color: #888; margin-top: 2px;">Comma-separated list of character names</div>
        </div>

        <div style="display: flex; gap: 6px;">
          <div style="flex: 1; font-size: 10px; color: #e0e0e0;">
            <label style="display: block; margin-bottom: 3px; font-weight: 600;">X Coordinate *</label>
            <input type="number" id="screenshot-x" placeholder="X" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
          </div>
          <div style="flex: 1; font-size: 10px; color: #e0e0e0;">
            <label style="display: block; margin-bottom: 3px; font-weight: 600;">Y Coordinate *</label>
            <input type="number" id="screenshot-y" placeholder="Y" style="width: 100%; padding: 3px; background: rgba(0,0,0,0.4); border: 1px solid #2a3f5f; color: #e0e0e0; font-size: 10px; border-radius: 2px;">
          </div>
        </div>

        <div style="margin-top: 6px; display: flex; gap: 6px;">
          <button id="screenshot-save-btn" style="flex: 1; padding: 6px; background: linear-gradient(180deg, #3b82f6, #2563eb); border: 1px solid #1d4ed8; color: white; font-size: 10px; font-weight: 600; border-radius: 3px; cursor: pointer;">Save</button>
          <button id="screenshot-delete-btn" style="flex: 1; padding: 6px; background: linear-gradient(180deg, #ef4444, #dc2626); border: 1px solid #b91c1c; color: white; font-size: 10px; font-weight: 600; border-radius: 3px; cursor: pointer; display: none;">Delete</button>
          <button id="screenshot-cancel-btn" style="flex: 1; padding: 6px; background: linear-gradient(180deg, #6b7280, #4b5563); border: 1px solid #374151; color: white; font-size: 10px; font-weight: 600; border-radius: 3px; cursor: pointer;">Cancel</button>
        </div>
      </div>

      <!-- Right side: List -->
      <div style="width: 180px; display: flex; flex-direction: column; gap: 6px;">
        <div style="font-size: 10px; color: #e0e0e0; font-weight: 600; padding-bottom: 3px; border-bottom: 1px solid #2a3f5f;">Screenshots</div>
        <div id="screenshots-list" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 4px;">
          <div style="text-align: center; color: #888; font-size: 9px; padding: 20px;">No screenshots</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Quickbar (5 rows × 10 slots, bottom-left of HUD) -->
  <div id="quickbar"></div>

  <!-- Header actions moved into compass for top-right placement -->
  <!-- UI images overlay (rendered from public/assets/ui-v1) -->
  <div id="ui-image-overlay" aria-hidden="true">
    <div class="ui-bar-repeat"></div>
    <div class="ui-bar-right">
      <img src="https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-bottom-right-premium.png" alt="">
      <div class="ui-hud-group" aria-hidden="false">
        <button id="inventory-hud-btn" class="ui-hud-btn" data-action="inventory" aria-label="Open Inventory"></button>
        <button id="character-hud-btn" class="ui-hud-btn" data-action="character" aria-label="Open Character"></button>
        <button id="actions-hud-btn" class="ui-hud-btn" data-action="actions" aria-label="Actions"></button>
        <button id="party-hud-btn" class="ui-hud-btn" data-action="party" aria-label="Party"></button>
        <button id="premium-hud-btn" class="ui-hud-btn" data-action="premium" aria-label="Premium"></button>
        <button id="quests-hud-btn" class="ui-hud-btn" data-action="quests" aria-label="Quests"></button>
        <button id="spellbook-hud-btn" class="ui-hud-btn" data-action="spellbook" aria-label="Spellbook"></button>
      </div>
    </div>
    <div class="ui-bar-repeat ui-bar-repeat-right"></div>
  </div>
  <!-- Active spells display (to the left of compass) -->
  <div id="active-spells-container" aria-hidden="true"></div>
  <!-- Cast bar (shown at bottom-center during spell casting) -->
  <div id="cast-bar">
    <div id="cast-bar-label"></div>
    <div id="cast-bar-track"><div id="cast-bar-fill"></div></div>
    <div id="cast-bar-time"></div>
  </div>
  <!-- Top-right compass with interactive controls (map settings + logout) -->
    <div id="ui-compass" aria-hidden="false">
    <img src="https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-compass.png" alt="" draggable="false" ondragstart="return false;">
    <div class="compass-controls" aria-hidden="false">
      <button class="btn-logout" id="settings-btn">Settings</button>
      <button class="btn-logout" id="logout-btn">Logout</button>
    </div>
  </div>
  <!-- Server time icon (overlays the compass, shows tooltip on hover) -->
  <div id="ui-server-time" aria-hidden="false">
    <img id="server-time-icon" src="/assets/v1/time/ui-icon-time-day.png" alt="Server Time">
    <div id="server-time-tooltip" class="server-time-tooltip" role="status" aria-hidden="true"></div>
  </div>
  <!-- Top-left character status (non-interactive) -->
  <div id="ui-character-status" aria-hidden="true">
    <img src="https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-character-status.png" alt="" draggable="false" ondragstart="return false;">
    <div class="ui-character-overlay" aria-hidden="true">
      <div class="status-top">
        <div id="player-level" style="font-weight:700; color:#ffd700; font-size:13px; min-width:28px; text-align:left;">1</div>
      </div>
      <div class="status-name">
        <span id="player-username" style="font-size:13px; color:#ffffff;">-</span>
      </div>
      <div class="status-bars">
        <div style="display:flex; align-items:center;">
          <div class="territory-health-bar overlay-bar" style="margin-right:6px;">
            <div id="player-health-fill" class="territory-health-fill health-high" style="width:100%; height:100%;"></div>
            <div id="player-health-text" class="bar-text">1000/1000</div>
          </div>
        </div>
        <div style="display:flex; align-items:center; margin-top:0;">
          <div class="territory-health-bar overlay-bar" style="margin-right:6px;">
            <div id="player-mana-fill" class="territory-health-fill" style="width:100%; height:100%;"></div>
            <div id="player-mana-text" class="bar-text">500/500</div>
          </div>
        </div>
      </div>
      <div id="player-coords" style="font-size:11px; color:#e0e0e0; margin-top:4px;">Position: 0, 0</div>
    </div>
  </div>
    <!-- Mini info window is now loaded from a separate file -->
    <div id="mini-info-include"></div>
    <script>
      (function(){
        fetch('info-box.html').then(r => r.text()).then(html => {
          const container = document.getElementById('mini-info-include');
          if (container) container.innerHTML = html;
          try { if (typeof initWindows === 'function') initWindows(); } catch (e) {}
        }).catch(err => console.error('Failed to load info box:', err));
      })();
    </script>
  <div id="attribution" aria-label="Map author and source">
    <a href="https://github.com/CoR-Forum/RegnumNostalgia" target="_blank" rel="noopener noreferrer">GitHub</a>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <script src="regions.js"></script>
  <script src="screenshotManager.js"></script>
  <script>
    /**
     * @typedef {{x:number,y:number}} Coords
     * @typedef {{inventoryId?:number,item?:Object}} EquipmentSlotInfo
    * @typedef {{itemName:string,iconName?:string,rarity?:string,level?:number,quantity?:number,equipmentSlot?:string,stats?:Object,description?:string,itemType?:string}} Item
    * @typedef {{success?:boolean,position?:Coords,realm?:string,username?:string,health?:number,maxHealth?:number,mana?:number,maxMana?:number,damage?:number,armor?:number,xp?:number,xpToNext?:number,level?:number,stats?:Object,className?:string}} PlayerPositionResponse
     */

    // Configuration: 3 rows, 3 columns, tiles named `tiles/{row}-{col}.png`
    const rows = 3, cols = 3;
    let currentTileVersion = localStorage.getItem('tileVersion') || 'v1';
    const tileUrl = (r, c) => `https://cor-forum.de/regnum/RegnumNostalgia/map/tiles-${currentTileVersion}/${r}-${c}.png`;

    // Load first tile to determine tile pixel size at runtime
    const probe = new Image();
    probe.src = tileUrl(1,1);
    
    probe.onload = () => {
      const tileW = probe.width;
      const tileH = probe.height;

      // Original stitched image pixel size (e.g. 3 * 1024 = 3072 or 3 * 2048 = 6144)
      const origTotalW = cols * tileW;
      const origTotalH = rows * tileH;

      // Desired raster coordinates size. The world should behave as 6144x6144
      // v1: tiles are 1024x1024 (3072x3072 total) → baseScale = 6144/3072 = 2
      // v2: tiles are 2048x2048 (6144x6144 total) → baseScale = 6144/6144 = 1
      const baseScale = 6144 / origTotalW;

      // Allow small per-axis adjustments for tile variants. v2 tiles require
      // a slight manual shrink to better match the v1 appearance:
      // - width (X) : -1%  => 0.99
      // - height(Y) : -2%  => 0.98
      let scaleX = baseScale;
      let scaleY = baseScale;
      if (currentTileVersion === 'v2') {
        scaleX = baseScale * 1.00; // +1% width
        scaleY = baseScale * 1.01; // +2% height
      }

      // Scaled world size used by Leaflet (map coordinate units)
      totalW = origTotalW * scaleX;
      totalH = origTotalH * scaleY;

      // Use CRS.Simple so coordinates map directly to pixels
      // Disable the default zoomControl (placed top-left) so we can
      // re-add it on the right side.
      map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -3,
        maxZoom: 2,
        maxBoundsViscosity: 0.5,
        zoomControl: false,
        scrollWheelZoom: true,
        doubleClickZoom: false,
        boxZoom: false,
        touchZoom: true,
        keyboard: false
      });

      const fullBounds = [[0,0],[totalH,totalW]]; // [[y1,x1],[y2,x2]]
      map.fitBounds(fullBounds);

      // Snap back to bounds, but allow a larger padding buffer so users can
      // pan further outside before the map bounces back. Increase the
      // allowed off-screen drag by 50% over the original setting.
      const pad = 1000 * Math.max(scaleX, scaleY); // pixels of padding outside the image (scaled)
      const paddedBounds = [[-pad, -pad], [totalH + pad, totalW + pad]];
      map.setMaxBounds(paddedBounds);

      // Helper: add markers using raster coordinates (6144x6144 space)
      // Example: addRasterMarker(x, y) where x/y are in the 6144x6144 space.
      // Y-axis: user coords have origin at top-left, Leaflet has origin at bottom-left
      function addRasterMarker(x, y, opts){
        // Leaflet expects [lat, lng] -> [y, x], and invert Y
        return L.marker([totalH - y, x], opts).addTo(map);
      }

      // Convert position objects/arrays (x,y) to Leaflet latlngs
      function positionsToLatLngs(positions){
        return (positions||[]).map(p => {
          if (Array.isArray(p)) {
            // [x,y]
            return [totalH - p[1], p[0]];
          }
          // object {x,y}
          return [totalH - (p.y ?? p[1] ?? 0), (p.x ?? p[0] ?? 0)];
          });
        }

        // region display moved to public/regions.js (initRegionDisplay)
      try {
        if (typeof initRegionDisplay === 'function') {
          initRegionDisplay(map, gameState, apiCall, positionsToLatLngs);
        }
      } catch (e) { console.debug('initRegionDisplay failed', e); }

      // Add each tile as an ImageOverlay positioned by scaled pixel bounds
      // Note: flip vertical ordering so rows 1 and 3 are swapped
      let tileOverlays = [];
      let tileLayer = null;
      
      function loadTiles() {
        // Remove existing tiles
        tileOverlays.forEach(overlay => map.removeLayer(overlay));
        tileOverlays = [];
        
        if (tileLayer) {
          map.removeLayer(tileLayer);
          tileLayer = null;
        }
        
        // Both v1 and v2 use simple 3x3 grid
        for(let r=1; r<=rows; r++){
          for(let c=1; c<=cols; c++){
            const rowPos = rows - r; // invert row index
            const y1 = rowPos * tileH * scaleY;
            const x1 = (c-1) * tileW * scaleX;
            const y2 = (rowPos + 1) * tileH * scaleY;
            const x2 = c * tileW * scaleX;
            const overlay = L.imageOverlay(tileUrl(r,c), [[y1,x1],[y2,x2]]).addTo(map);
            tileOverlays.push(overlay);
          }
        }
      }
      loadTiles();

      L.control.scale({metric: false, imperial: false}).addTo(map);
      // Add zoom control on the right side
      // Zoom control removed to disable zoom UI (interactions disabled above)

      // Load markers/shapes/icons from JSON and render them
      fetch('assets/markers.json').then(r => r.json()).then(data => {
        const icons = {};
        // Create Leaflet icons (scale sizes by `scale` so they fit raster coords)
        for(const [key, def] of Object.entries(data.icons||{})){
          const size = def.size || [24,24];
          const anchor = def.anchor || [Math.floor(size[0]/2), size[1]];
          icons[key] = L.icon({
            iconUrl: def.url,
            iconSize: [size[0], size[1]],
            iconAnchor: [anchor[0], anchor[1]]
          });
        }
        // Store icons globally for territory markers
        territoryIcons = icons;

        const layerIndex = {};
        const overlays = {};

        function toLatLng(p){ return [totalH - p[1], p[0]]; }

        for(const f of (data.features||[])){
          let layer = null;
          if(f.type === 'marker'){
            const icon = f.icon && icons[f.icon] ? icons[f.icon] : undefined;
            layer = addRasterMarker(f.x, f.y, icon ? {icon} : undefined);
          } else if(f.type === 'circle'){
            const c = toLatLng(f.center);
            layer = L.circle(c, { radius: (f.radius||50), color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polygon'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polygon(pts, { color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polyline'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polyline(pts, { color: f.color || '#3388ff', weight: f.weight || 3 }).addTo(map);
          } else if(f.type === 'group'){
            const members = (f.members||[]).map(id => layerIndex[id]).filter(Boolean);
            layer = L.layerGroup(members).addTo(map);
            // register group as an overlay so it can be toggled in the layer control
            overlays[f.name || f.id || ('group-' + Object.keys(overlays).length)] = layer;
          }

          if(layer){
            if(f.popup) layer.bindPopup(f.popup);
            if(f.id) layerIndex[f.id] = layer;
          }
        }
          // If any overlays (groups) were registered, add a layer control
          if(Object.keys(overlays).length > 0){
            L.control.layers(null, overlays, { collapsed: false, position: 'bottomleft' }).addTo(map);
          }
        // Coordinate readout: show raster coords (original pixel space) while hovering
        const coordsEl = document.getElementById('coords');
        if(coordsEl){
          map.on('mousemove', (e) => {
            const mapX = e.latlng.lng; // scaled x in 0..totalW
            const mapY = e.latlng.lat; // scaled y in 0..totalH (origin at bottom)
            // X: 1-based left-to-right using scaled coords
            const displayX = Math.max(1, Math.min(totalW, Math.floor(mapX) + 1));
            // Y: invert because mapY origin is bottom; top should be 1
            const displayY = Math.max(1, Math.min(totalH, Math.floor(totalH - mapY) + 1));
            coordsEl.style.display = 'block';
            coordsEl.textContent = `${displayX}x${displayY}`;

            // delegate region hover handling to regions module (if present)
            try { if (window.handleRegionMouseMove) window.handleRegionMouseMove(e); } catch (err) { /* ignore */ }
          });
          map.on('mouseout', () => { coordsEl.style.display = 'none'; const indicator = document.getElementById('walk-indicator'); if (indicator) indicator.classList.remove('show'); });
        }
        
        // region overview logic moved to public/regions.js
      }).catch(err => console.error('Failed to load markers.json', err));
      
      // Process any collectables that were received before map was ready
      if (window.gameState && window.gameState.pendingCollectables && window.gameState.pendingCollectables.length > 0) {
        console.log('Processing', window.gameState.pendingCollectables.length, 'pending collectables');
        const pending = [...window.gameState.pendingCollectables];
        window.gameState.pendingCollectables = [];
        pending.forEach(item => {
          if (typeof createCollectableMarker === 'function') {
            createCollectableMarker(item);
          }
        });
      }
    };

    probe.onerror = () => {
      console.error('Failed to load probe tile:', probe.src);
      try { document.getElementById('map').innerText = 'Failed to load tiles. Check tiles/ filenames.'; } catch(e) {}
    };

    // ============================================================
    // GAME CLIENT CODE
    // ============================================================

    const API_BASE = '/api';
    const REALM_COLORS = { syrtis: '#22c55e', alsius: '#3b82f6', ignis: '#ef4444' };
    
    // Global map variables (set by probe.onload)
    let map = null;
    let totalH = 0;
    let totalW = 0;
    let territoryIcons = {};
    
    // Expose gameState on window so other modules can access it
    // Normalize stored session token: treat literal strings 'null'/'undefined' or empty
    // values as no token to avoid accidental auto-login attempts.
    let storedToken = null;
    try {
      const raw = localStorage.getItem('sessionToken');
      if (raw && raw !== 'null' && raw !== 'undefined' && String(raw).trim() !== '') {
        storedToken = raw;
      } else {
        storedToken = null;
      }
    } catch (e) {
      storedToken = null;
    }

    window.gameState = {
      sessionToken: storedToken,
      userId: null,
      username: null,
      realm: null,
      position: { x: 0, y: 0 },
      health: 1000,
      maxHealth: 1000,
      mana: 500,
      maxMana: 500,
      playerMarker: null,
      otherPlayers: new Map(),
      territories: new Map(),
      superbosses: new Map(),
      collectables: new Map(), // spawnId -> marker
      collectingSpawnIds: new Set(), // tracks items being collected (orange border)
      pendingCollectables: [], // items waiting for map to be ready
      pathsData: [],
      regionsData: [],
    pathsLayer: null,
    regionsLayer: null,
    showRegions: false,
    showPaths: false,
      buildPathPoints: [],
      buildPathPolyline: null,
      pollInterval: null,
      territoriesPollInterval: null,
      superbossesPollInterval: null
    };
    
    // Keep a local reference for convenience
    const gameState = window.gameState;

    const getRealmColor = (realm) => {
      const key = (realm || '').toString().toLowerCase();
      return REALM_COLORS[key] || REALM_COLORS.syrtis;
    };

    const buildGoHereIcon = () => L.divIcon({
      className: 'custom-go-here-marker',
      html: `<div style="width:14px;height:14px;background:#ffd700;border:2px solid #fff;border-radius:50%;box-shadow:0 0 6px rgba(255,215,0,0.8);"></div>`,
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });

    // API Helper functions
    async function apiCall(endpoint, options = {}) {
      const headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...options.headers
      };

      if (gameState && gameState.sessionToken && !options.skipAuth) {
        headers['X-Session-Token'] = gameState.sessionToken;
      }

      const response = await fetch(API_BASE + endpoint, {
        cache: 'no-store',
        ...options,
        headers
      });

      const status = response.status;
      let data = null;
      try { data = await response.json(); } catch (e) { data = null; }

      if (!response.ok) {
        const err = new Error((data && data.error) ? data.error : 'API call failed');
        err.status = status;
        err.body = data;
        throw err;
      }

      if (data && data.success === false) {
        const err = new Error(data.error || 'API call failed');
        err.status = status;
        err.body = data;
        throw err;
      }

      return data;
    }

    // Expose apiCall globally for use by other modules (login.html, etc.)
    window.apiCall = apiCall;

    // Socket.io connection management
    let socket = null;
    let reconnectAttempts = 0;
    
    // Helper to prefer WebSocket emits for equipment actions with HTTP fallback
    async function emitOrApi(eventName, payload, fallbackPath, fallbackForm) {
      if (socket && socket.connected) {
        return new Promise((resolve, reject) => {
          try {
            socket.emit(eventName, payload, (resp) => {
              if (!resp) return reject(new Error('No response from server'));
              if (resp.success === false) {
                const err = new Error(resp.error || 'Server error');
                err.body = resp;
                return reject(err);
              }
              resolve(resp);
            });
          } catch (e) {
            reject(e);
          }
        });
      }
      // Fallback to HTTP API
      return apiCall(fallbackPath, { method: 'POST', body: fallbackForm });
    }
    const MAX_RECONNECT_ATTEMPTS = 5;

    function initializeWebSocket() {
      if (socket) {
        socket.disconnect();
      }

      const token = gameState.sessionToken;
      if (!token) {
        console.warn('No session token available for WebSocket connection');
        return;
      }

      socket = io({
        auth: { token },
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        reconnectionAttempts: MAX_RECONNECT_ATTEMPTS
      });

      // Expose socket on window for legacy consumers that check `window.socket`
      try { window.socket = socket; } catch (e) { /* ignore non-writable window */ }

      socket.on('connect', () => {
        reconnectAttempts = 0;
        // Dispatch custom event for other components
        const event = new CustomEvent('websocket:connected');
        window.dispatchEvent(event);
      });

      socket.on('disconnect', (reason) => {
        console.log('WebSocket disconnected:', reason);
        try { if (window.socket === socket) window.socket = null; } catch (e) {}
        if (reason === 'io server disconnect' || reason === 'io client disconnect') {
          // Server disconnected us or client intentionally disconnected
          // Don't auto-reload, let user retry
        }
      });

      socket.on('connect_error', (error) => {
        console.error('WebSocket connection error:', error);
        reconnectAttempts++;
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          console.log('Max reconnection attempts reached, reloading page');
          window.location.reload();
        }
      });

      socket.on('error', (data) => {
        console.error('WebSocket error:', data.message);
        if (data.message && window.addLogMessage) {
          window.addLogMessage(data.message, 'error');
        }
      });

      // Player events
      socket.on('player:state', (data) => {
        // Initial state sync on connection
        updatePlayerFromState(data);
      });

      socket.on('player:health', (data) => {
        // Real-time health/mana updates
        if (data.userId === gameState.userId) {
          gameState.health = data.health ?? gameState.health;
          gameState.maxHealth = data.maxHealth ?? gameState.maxHealth;
          gameState.mana = data.mana ?? gameState.mana;
          gameState.maxMana = data.maxMana ?? gameState.maxMana;
          try { 
            if (window.updatePlayerStats) {
              window.updatePlayerStats();
            }
          } catch (e) {}

          // If server sent only current values but not max values, request full stats once
          if (typeof data.maxHealth === 'undefined') {
            try {
              const sock = window.getSocket && window.getSocket();
              if (sock && sock.connected) {
                sock.emit('player:stats:get', (resp) => {
                  if (resp && resp.success && resp.state) updatePlayerFromState(resp.state);
                });
              }
            } catch (e) { console.debug('requesting full player stats failed', e); }
          }
        }
      });

      socket.on('players:online', (data) => {
        if (data && data.players) {
          updateOtherPlayers(data.players);
        }
      });

      socket.on('players:position', (data) => {
        // Real-time position updates from server
        if (data && Array.isArray(data)) {
          data.forEach(player => {
            if (player.userId === gameState.userId) {
              // Update own position
              gameState.position.x = player.x;
              gameState.position.y = player.y;
              if (gameState.playerMarker) {
                gameState.playerMarker.setLatLng([totalH - player.y, player.x]);
              }
              updatePlayerCoords(player.x, player.y);
            } else {
              // Update other player position
              const playerId = String(player.userId);
              if (gameState.otherPlayers.has(playerId)) {
                const marker = gameState.otherPlayers.get(playerId);
                marker.setLatLng([totalH - player.y, player.x]);
              }
            }
          });
        }
      });

      socket.on('player:connected', (data) => {
        console.log('Player connected:', data.username);
      });

      socket.on('player:disconnected', (data) => {
        console.log('Player disconnected:', data.username);
        // Remove their marker
        if (gameState.otherPlayers.has(String(data.userId))) {
          const marker = gameState.otherPlayers.get(String(data.userId));
          map.removeLayer(marker);
          gameState.otherPlayers.delete(String(data.userId));
        }
      });

      // Walker events
      socket.on('walker:step', (data) => {
        if (data.userId === gameState.userId) {
          // Update own position
          gameState.position = data.position;
          if (gameState.playerMarker) {
            gameState.playerMarker.setLatLng([totalH - data.position.y, data.position.x]);
          }
          updatePlayerCoords(data.position.x, data.position.y);

          // update current index and refresh remaining path via build-path API
          if (typeof data.currentIndex === 'number' && window.buildPath && typeof window.buildPath.updateWalkerCurrentIndex === 'function') {
            try { window.buildPath.updateWalkerCurrentIndex(data.currentIndex); } catch (e) { console.debug('refresh walk path failed', e); }
          }

          if (data.completed) {
            // Walker finished
            if (gameState.walkDestinationMarker) {
              map.removeLayer(gameState.walkDestinationMarker);
              gameState.walkDestinationMarker = null;
            }
            gameState.walkingTarget = null;
            try { if (window.buildPath && typeof window.buildPath.clearWalkerPath === 'function') window.buildPath.clearWalkerPath(); } catch (e) { console.debug('clear walk path failed', e); }
          }
        }
      });

      socket.on('walker:completed', (data) => {
        if (data.userId === gameState.userId) {
          if (gameState.walkDestinationMarker) {
            map.removeLayer(gameState.walkDestinationMarker);
            gameState.walkDestinationMarker = null;
          }
          gameState.walkingTarget = null;
          try { if (window.buildPath && typeof window.buildPath.clearWalkerPath === 'function') window.buildPath.clearWalkerPath(); } catch (e) { console.debug('clear walk path failed', e); }
          
          // Clear collecting marks if this was our walker
          clearAllCollectingMarks();
        }
      });

      socket.on('move:started', (data) => {
        // Server confirmed movement started, show destination
        if (data.destination) {
          const [dx, dy] = data.destination;
          if (!gameState.walkDestinationMarker) {
            gameState.walkDestinationMarker = L.marker([totalH - dy, dx], {
              icon: buildGoHereIcon(),
              riseOnHover: true
            }).addTo(map);
          } else {
            gameState.walkDestinationMarker.setLatLng([totalH - dy, dx]);
          }
          gameState.walkingTarget = { x: dx, y: dy };
          if (data.positions && window.buildPath && typeof window.buildPath.setWalkerPositions === 'function') {
            try { window.buildPath.setWalkerPositions(data.positions, typeof data.currentIndex === 'number' ? data.currentIndex : 0); } catch (e) { console.debug('drawWalkPath failed', e); }
          }
        }
        
        // Clear old collecting marks when starting new movement
        clearAllCollectingMarks();
      });

      socket.on('walker:restore', (data) => {
        // Restore walking state after page reload
        if (data.destination) {
          const [dx, dy] = data.destination;
          if (!gameState.walkDestinationMarker) {
            gameState.walkDestinationMarker = L.marker([totalH - dy, dx], {
              icon: buildGoHereIcon(),
              riseOnHover: true
            }).addTo(map);
          } else {
            gameState.walkDestinationMarker.setLatLng([totalH - dy, dx]);
          }
          gameState.walkingTarget = { x: dx, y: dy };
          if (data.positions && window.buildPath && typeof window.buildPath.setWalkerPositions === 'function') {
            try { window.buildPath.setWalkerPositions(data.positions, typeof data.currentIndex === 'number' ? data.currentIndex : 0); } catch (e) { console.debug('drawWalkPath failed', e); }
          }
        }
        
        // Restore collecting state if present
        if (data.collectingSpawnId) {
          gameState.collectingSpawnIds.add(data.collectingSpawnId);
          // Try to update marker, will work once markers are loaded
          updateCollectableMarker(data.collectingSpawnId, true);
          
          // Also try again after a short delay in case markers aren't loaded yet
          setTimeout(() => {
            updateCollectableMarker(data.collectingSpawnId, true);
          }, 100);
        }
      });

      // Territory events
      socket.on('territories:list', (data) => {
        if (data && data.territories) {
          updateTerritories(data.territories);
        }
      });

      socket.on('territories:update', (data) => {
        if (data && data.territories) {
          updateTerritories(data.territories);
        } else if (data && data.territoryId) {
          // Single territory update
          // Refresh all territories for simplicity
          apiCall('/territories').then(resp => {
            if (resp && resp.territories) updateTerritories(resp.territories);
          }).catch(err => console.error('Failed to refresh territories:', err));
        }
      });

      socket.on('territories:capture', (data) => {
        if (data && data.captures) {
          console.log('Territories captured:', data.captures);
          // Show notification for captures using same overlay styling
          data.captures.forEach(capture => {
            const msg = `${capture.name} captured by ${capture.newOwner || 'neutral'}`;
            try { if (window.addLogMessage) window.addLogMessage(msg, 'error'); else alert(msg); } catch (e) { alert(msg); }
            console.log(msg);
          });
        }
      });

      // Superboss events
      socket.on('superbosses:list', (data) => {
        if (data && data.superbosses) {
          updateSuperbosses(data.superbosses);
        }
      });

      socket.on('superbosses:health', (data) => {
        if (data && data.superbosses) {
          updateSuperbosses(data.superbosses);
        }
      });

      // Time events
      socket.on('time:current', (data) => {
        if (data && typeof data.ingameHour !== 'undefined') {
          try {
            if (typeof window.updateServerTimeUI === 'function') {
              window.updateServerTimeUI({ serverTime: data });
            }
          } catch (e) {
            console.debug('updateServerTimeUI failed:', e);
          }
        }
      });

      // Paths and regions events
      socket.on('paths:list', (data) => {
        if (data && data.paths) {
          gameState.pathsData = data.paths;
          // Only render paths immediately if the Region Editor is open (user requested paths).
          try {
            if (gameState.showPaths && window.loadAndRenderPaths && typeof window.loadAndRenderPaths === 'function') {
              window.loadAndRenderPaths();
            }
          } catch (e) { console.debug('loadAndRenderPaths call failed', e); }
        }
      });

      socket.on('regions:list', (data) => {
        if (data && data.regions) {
          gameState.regionsData = data.regions;
          try { if (window.loadAndRenderRegions && typeof window.loadAndRenderRegions === 'function') window.loadAndRenderRegions(); } catch (e) { console.debug('loadAndRenderRegions call failed', e); }
        }
      });

      // Collectable items events
      socket.on('spawned-items:list', (data) => {
        if (data && data.spawnedItems) {
          // Clear existing markers
          gameState.collectables.forEach(marker => marker.remove());
          gameState.collectables.clear();

          // Add new markers
          data.spawnedItems.forEach(item => {
            createCollectableMarker(item);
          });
          
          // Reapply collecting marks for any items we were collecting
          gameState.collectingSpawnIds.forEach(spawnId => {
            updateCollectableMarker(spawnId, true);
          });
        }
      });

      socket.on('collectable:spawned', (data) => {
        if (data && data.spawnId) {
          // Check if marker already exists
          if (!gameState.collectables.has(data.spawnId)) {
            createCollectableMarker(data);
          }
        }
      });

      socket.on('collectable:collecting', (data) => {
        if (data && data.spawnId) {
          // Clear previous collecting states if this is our player
          if (data.userId === gameState.userId) {
            clearAllCollectingMarks();
          }
          
          // Mark item as being collected (add orange border)
          gameState.collectingSpawnIds.add(data.spawnId);
          updateCollectableMarker(data.spawnId, true);
        }
      });

      socket.on('collectable:collected', (data) => {
        if (data && data.spawnId) {
          // Remove marker
          const marker = gameState.collectables.get(data.spawnId);
          if (marker) {
            marker.remove();
            gameState.collectables.delete(data.spawnId);
          }
          gameState.collectingSpawnIds.delete(data.spawnId);
          
          // Toast notifications disabled
          // if (data.userId === gameState.userId && data.items && data.items.length > 0) {
          //   data.items.forEach(item => {
          //     showNotification(`+${item.quantity} ${item.name}`, 'success');
          //   });
          // }
        }
      });

      socket.on('collectable:failed', (data) => {
        if (data && data.spawnId) {
          // Remove collecting state but keep marker
          gameState.collectingSpawnIds.delete(data.spawnId);
          updateCollectableMarker(data.spawnId, false);
        }
      });

      socket.on('inventory:item-added', (data) => {
        if (data) {
          // Toast notifications disabled
          // showNotification(`+${data.quantity} ${data.name}`, 'success');
          
          // Refresh inventory if window is open
          try {
            const inventoryWindow = document.getElementById('inventory-window');
            if (inventoryWindow && inventoryWindow.style.display !== 'none') {
              socket.emit('inventory:get', (invData) => {
                if (invData && invData.success) {
                  const displayInventory = window.displayInventory;
                  if (typeof displayInventory === 'function') {
                    displayInventory(invData.items);
                  }
                }
              });
            }
          } catch (e) {
            console.debug('Failed to refresh inventory:', e);
          }
        }
      });

      socket.on('inventory:refresh', () => {
        // Refresh inventory if window is open
        try {
          const inventoryWindow = document.getElementById('inventory-window');
          if (inventoryWindow && inventoryWindow.style.display !== 'none') {
            socket.emit('inventory:get', (invData) => {
              if (invData && invData.success) {
                const displayInventory = window.displayInventory;
                if (typeof displayInventory === 'function') {
                  displayInventory(invData.items);
                }
              }
            });
          }
        } catch (e) {
          console.debug('Failed to refresh inventory:', e);
        }
      });

      // Helper function to clear all collecting marks
      function clearAllCollectingMarks() {
        gameState.collectingSpawnIds.forEach(spawnId => {
          updateCollectableMarker(spawnId, false);
        });
        gameState.collectingSpawnIds.clear();
      }

      // Helper function to update collectable marker border
      function updateCollectableMarker(spawnId, isCollecting) {
        const marker = gameState.collectables.get(spawnId);
        if (marker && marker.getElement) {
          const elem = marker.getElement();
          if (elem) {
            const innerDiv = elem.querySelector('div');
            if (innerDiv) {
              if (isCollecting) {
                innerDiv.style.border = '3px solid #ff8800';
                innerDiv.style.borderRadius = '50%';
              } else {
                innerDiv.style.border = '';
                innerDiv.style.borderRadius = '';
              }
            }
          }
        }
      }

      // Simple HTML escaper for tooltip content
      function escapeHtml(str){
        if (str === null || typeof str === 'undefined') return '';
        return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
      }

      // Helper function to create collectable marker
      function createCollectableMarker(item) {
        if (!item || !item.x || !item.y) return;
        
        // If map is not ready yet, queue the item for later processing
        if (!map || totalH === 0 || totalW === 0) {
          if (!gameState.pendingCollectables.some(p => p.spawnId === item.spawnId)) {
            gameState.pendingCollectables.push(item);
          }
          return;
        }

        const latLng = [totalH - item.y, item.x];
        const isCollecting = gameState.collectingSpawnIds.has(item.spawnId);

        const iconHtml = `
          <div style="
            width: 28px;
            height: 28px;
            background: url('https://cor-forum.de/regnum/RegnumNostalgia/markers/${item.visualIcon}') center center / contain no-repeat;
            ${isCollecting ? 'border: 3px solid #ff8800; border-radius: 50%;' : ''}
            cursor: pointer;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.6));
          "></div>
        `;

        const customIcon = L.divIcon({
          className: 'collectable-marker',
          html: iconHtml,
          iconSize: [28, 28],
          iconAnchor: [14, 14]
        });

        const marker = L.marker(latLng, { icon: customIcon }).addTo(map);

        // Tooltip for collectable (consistent with other map entries)
        try {
          const name = item.visualName || item.name || item.itemName || item.displayName || ('Item ' + (item.spawnId || ''));
          const qty = item.quantity ? String(item.quantity) : null;
          const desc = item.description || '';
          const rarity = item.rarity || '';
          const ttHtml = `
            <div class="tooltip-title">${escapeHtml(name)}</div>
            ${qty ? `<div class="tooltip-row"><strong>Qty:</strong> ${escapeHtml(qty)}</div>` : ''}
            ${rarity ? `<div class="tooltip-row"><strong>Rarity:</strong> ${escapeHtml(rarity)}</div>` : ''}
            ${desc ? `<div class="tooltip-row" style="color:#cfcfcf">${escapeHtml(desc)}</div>` : ''}
          `;
          marker.bindTooltip(ttHtml, { className: 'info-tooltip', direction: 'top', offset: [0, -20] });
        } catch (e) { /* ignore tooltip failures */ }

        // Click handler to collect
        marker.on('click', () => {
          if (!socket || !socket.connected) {
            // Toast notifications disabled
            // showNotification('Not connected to server', 'error');
            return;
          }

          socket.emit('collectable:click', { spawnId: item.spawnId }, (response) => {
            if (response && response.success) {
              // Remove any existing destination marker (from previous walk)
              if (gameState.walkDestinationMarker) {
                try { map.removeLayer(gameState.walkDestinationMarker); } catch (e) {}
                gameState.walkDestinationMarker = null;
              }
              
              // Draw the path if we have positions
              if (response.walker && response.walker.positions) {
                // Don't show destination marker when collecting items (item itself is already marked)
                const [dx, dy] = response.walker.destination;
                gameState.walkingTarget = { x: dx, y: dy };
                
                // Draw path line
                if (window.buildPath && typeof window.buildPath.setWalkerPositions === 'function') {
                  try {
                    window.buildPath.setWalkerPositions(
                      response.walker.positions, 
                      typeof response.walker.currentIndex === 'number' ? response.walker.currentIndex : 0
                    );
                  } catch (e) {
                    console.debug('drawWalkPath failed', e);
                  }
                }
              }
            } else if (response && response.error) {
              // Show error message to user
              if (window.addLogMessage) {
                window.addLogMessage(response.error, 'error');
              } else {
                console.error('Collection failed:', response.error);
              }
            }
          });
        });

        gameState.collectables.set(item.spawnId, marker);
      }

      // Helper function to show notifications
      function showNotification(message, type = 'info') {
        // Toast notifications disabled
        return;
      }

      // Audio manager - handle music and sfx pushed by server
      (function(){
        let musicAudio = null;
        let currentMusic = null;
        let pendingMusic = null; // store {file, volume, loop} if playback blocked
        let defaultSfxVolume = 1.0;
        // capture-specific default volume
        let defaultCaptureSfxVolume = 1.0;
        let musicEnabled = false;
        let soundsEnabled = true;

        function tryPlayMusic(file, volume = 0.6, loop = true) {
          if (!file) return Promise.resolve();
          if (currentMusic === file && musicAudio) return Promise.resolve();
          try {
            if (musicAudio) {
              musicAudio.pause();
            }
            musicAudio = new Audio('https://cor-forum.de/regnum/RegnumNostalgia/music/' + file);
            musicAudio.loop = !!loop;
            musicAudio.volume = typeof volume === 'number' ? volume : 0.6;
            return musicAudio.play().then(() => {
              currentMusic = file;
              pendingMusic = null;
            });
          } catch (e) {
            return Promise.reject(e);
          }
        }

        function playMusic(file, volume = 0.6, loop = true) {
          if (!file) return;
          try {
            tryPlayMusic(file, volume, loop).catch((err) => {
              // Likely blocked by autoplay policy — queue and wait for first user interaction
              pendingMusic = { file, volume, loop };
            });
          } catch (e) {
            pendingMusic = { file, volume, loop };
          }
        }

        function stopMusic() {
          try {
            if (musicAudio) {
              musicAudio.pause();
              musicAudio.currentTime = 0;
            }
            currentMusic = null;
            pendingMusic = null;
          } catch (e) {
            console.debug('stopMusic failed', e);
          }
        }

        // Expose simple runtime controls so UI can live-update settings
        window.AudioManager = {
          setMusicVolume(v){
            try {
              const vol = parseFloat(v) || 0;
              if (musicAudio) musicAudio.volume = vol;
            } catch(e){}
          },
          setSoundVolume(v){
              try { defaultSfxVolume = parseFloat(v) || 0; } catch(e) {}
          },
            setCaptureSoundVolume(v){
              try { defaultCaptureSfxVolume = parseFloat(v) || 0; } catch(e) {}
            },
          setMusicEnabled(enabled){
            try { musicEnabled = !!enabled; if (!musicEnabled) stopMusic(); }
            catch(e){}
          },
          setSoundsEnabled(enabled){
            try { soundsEnabled = !!enabled; }
            catch(e){}
          },
          // allow manual play/stop (used by server events)
          _playMusicInternal(file, volume, loop){ if (musicEnabled) playMusic(file, volume, loop); },
          _playSfxInternal(file, volume){ if (soundsEnabled) playSfx(file, typeof volume === 'number' ? volume : defaultSfxVolume); }
        };

        

        function playSfx(file, volume = 1.0) {
          if (!file) return;
          try {
            const s = new Audio('https://cor-forum.de/regnum/RegnumNostalgia/sounds/' + file);
            s.volume = typeof volume === 'number' ? volume : 1.0;
            s.play().catch(() => {});
          } catch (e) {
            console.debug('playSfx failed', e);
          }
        }

        // If playback was blocked earlier, attempt to play on first user interaction
        function resumePendingMusic() {
          if (!pendingMusic) return;
          tryPlayMusic(pendingMusic.file, pendingMusic.volume, pendingMusic.loop).catch(() => {});
        }

        // Listen once for user interaction to resume pending music
        const resumeOnce = () => {
          resumePendingMusic();
          document.removeEventListener('click', resumeOnce);
          document.removeEventListener('keydown', resumeOnce);
        };
        document.addEventListener('click', resumeOnce);
        document.addEventListener('keydown', resumeOnce);

        socket.on('audio:play', (data) => {
          if (!data) return;
          if (data.type === 'music') {
            // use exposed API which respects musicEnabled
            window.AudioManager && window.AudioManager._playMusicInternal(data.file, data.volume, data.loop);
          } else if (data.type === 'sfx') {
            // If server provides volume, use it. If not and it's a capture SFX, use capture default.
            const vol = (typeof data.volume === 'number') ? data.volume : (data.file && data.file.indexOf('capture') !== -1 ? (window.AudioManager && window.AudioManager.setCaptureSoundVolume ? defaultCaptureSfxVolume : null) : null);
            window.AudioManager && window.AudioManager._playSfxInternal(data.file, vol);
          }
        });

        socket.on('audio:stop', (data) => {
          if (!data) return;
          if (data.type === 'music') stopMusic();
        });
      })();

      socket.on('time:update', (data) => {
        if (data && typeof data.ingameHour !== 'undefined') {
          try {
            if (typeof window.updateServerTimeUI === 'function') {
              window.updateServerTimeUI({ serverTime: data });
            }
          } catch (e) {
            console.debug('updateServerTimeUI failed:', e);
          }
        }
      });

      // Shoutbox events
      socket.on('shoutbox:message', (data) => {
        if (window.onShoutboxMessage && typeof window.onShoutboxMessage === 'function') {
          window.onShoutboxMessage(data);
        }
      });

      // Player log events
      socket.on('log:message', (data) => {
        if (window.onLogMessage && typeof window.onLogMessage === 'function') {
          window.onLogMessage(data);
        }
      });

      return socket;
    }

    function updatePlayerFromState(data) {
          if (data.userId !== undefined) gameState.userId = data.userId;
          if (data.username !== undefined) gameState.username = data.username;
          if (data.realm !== undefined) gameState.realm = data.realm;
          // Handle nested position object and flat x/y properties
          if (data.position !== undefined) {
            if (data.position.x !== undefined) gameState.position.x = data.position.x;
            if (data.position.y !== undefined) gameState.position.y = data.position.y;
          }
          if (data.x !== undefined) gameState.position.x = data.x;
          if (data.y !== undefined) gameState.position.y = data.y;
          if (data.health !== undefined) gameState.health = data.health;
          if (data.maxHealth !== undefined) gameState.maxHealth = data.maxHealth;
          if (data.mana !== undefined) gameState.mana = data.mana;
          if (data.maxMana !== undefined) gameState.maxMana = data.maxMana;
          if (data.xp !== undefined) gameState.xp = data.xp;
          if (data.level !== undefined) gameState.level = data.level;
          if (data.intelligence !== undefined || data.strength !== undefined || data.dexterity !== undefined) {
            gameState.stats = {
              intelligence: data.intelligence ?? gameState.stats?.intelligence ?? 20,
              dexterity: data.dexterity ?? gameState.stats?.dexterity ?? 20,
              concentration: data.concentration ?? gameState.stats?.concentration ?? 20,
              strength: data.strength ?? gameState.stats?.strength ?? 20,
              constitution: data.constitution ?? gameState.stats?.constitution ?? 20
            };
          }
          // Per-type damage/armor and equipment weight
          if (data.damageTypes !== undefined) gameState.damageTypes = data.damageTypes || {};
          if (data.armorTypes !== undefined) gameState.armorTypes = data.armorTypes || {};
          if (data.totalEquipmentWeight !== undefined) gameState.totalEquipmentWeight = data.totalEquipmentWeight || 0;
      // Update player marker position if coordinates changed
      if ((data.position || data.x !== undefined || data.y !== undefined) && gameState.playerMarker) {
        const latLng = [totalH - gameState.position.y, gameState.position.x];
        gameState.playerMarker.setLatLng(latLng);
        updatePlayerCoords(gameState.position.x, gameState.position.y);
      }
      try { showPlayerInfo(); updateCharacterStats(); updatePlayerStats(); } catch (e) {}
    }

    window.initializeWebSocket = initializeWebSocket;
    window.getSocket = () => socket;

    // Small helper to format durations like respawn timers
    function formatDurationSeconds(s) {
      if (typeof s !== 'number' || isNaN(s)) return '';
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const sec = Math.floor(s % 60);
      let out = '';
      if (h) out += h + 'h ';
      if (m) out += m + 'm ';
      out += sec + 's';
      return out;
    }

    

    // Inventory button handler (legacy header button may be absent)
    const _inventoryBtn = document.getElementById('inventory-btn');
    if (_inventoryBtn) _inventoryBtn.addEventListener('click', () => {
      const inv = document.getElementById('inventory-window');
      if (inv && inv.style.display && inv.style.display !== 'none') closeWindow('inventory-window');
      else openWindow('inventory-window');
    });

    // Helper to toggle persistent pressed state on HUD buttons
    function setHudPressed(action, pressed) {
      try {
        const id = action === 'inventory' ? 'inventory-hud-btn' : (action === 'character' ? 'character-hud-btn' : null);
        if (!id) return;
        const el = document.getElementById(id);
        if (!el) return;
        if (pressed) el.classList.add('pressed'); else el.classList.remove('pressed');
      } catch (e) { /* ignore */ }
    }

    // Delegated handler for HUD buttons (inventory/character and future buttons)
    document.addEventListener('click', (e) => {
      const btn = e.target.closest && e.target.closest('.ui-hud-btn');
      if (!btn) return;
      const action = String(btn.dataset.action || '').trim();
      if (!action) return;
      try {
        // Prefer explicit known handlers and toggle if already open
        if (action === 'inventory') {
          const inv = document.getElementById('inventory-window');
          if (inv && inv.style.display && inv.style.display !== 'none') return closeWindow('inventory-window');
          return openWindow('inventory-window');
        }
        if (action === 'character') {
          const charWin = document.getElementById('character-window');
          if (charWin && charWin.style.display && charWin.style.display !== 'none') {
            setHudPressed('character', false);
            return closeWindow('character-window');
          }
          // Open character window (may be defined in character.html) and set pressed
          try { openWindow('character-window'); } catch (e) {}
          setHudPressed('character', true);
          try { saveWindowState('character-window', { open: true, display: 'flex' }); } catch (e) {}
          return;
        }

        // Try to call a global open<Action>() function if available (e.g. openParty)
        const fnName = 'open' + action.charAt(0).toUpperCase() + action.slice(1);
        const fn = window[fnName];
        if (typeof fn === 'function') return fn();

        console.debug('No handler for HUD action', action);
      } catch (err) { console.error('HUD button action failed', err); }
    });

    // Character button (header button may be absent)
    const _characterBtn = document.getElementById('character-btn');
    if (_characterBtn) _characterBtn.addEventListener('click', () => {
      const charWin = document.getElementById('character-window');
      if (charWin && charWin.style.display && charWin.style.display !== 'none') {
        setHudPressed('character', false);
        closeWindow('character-window');
      } else {
        try { openWindow('character-window'); } catch (e) {}
        setHudPressed('character', true);
        try { saveWindowState('character-window', { open: true, display: 'flex' }); } catch (e) {}
      }
    });

    // Window helpers
    function setTranslate(xPos, yPos, el) {
      if (!el) return;
      el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }

    // Persisted window state helpers
    function _getWindowsState() {
      try {
        const raw = localStorage.getItem('uiWindows');
        return raw ? JSON.parse(raw) : {};
      } catch (e) { return {}; }
    }
    function _saveWindowsState(state) {
      try { localStorage.setItem('uiWindows', JSON.stringify(state)); } catch (e) {}
    }
    function saveWindowState(id, patch) {
      if (!id) return;
      const s = _getWindowsState();
      s[id] = Object.assign({}, s[id] || {}, patch || {});
      _saveWindowsState(s);
    }
    function getWindowState(id) {
      const s = _getWindowsState();
      return s[id] || null;
    }

    // Try to call the window's open function after restore; retry until module loaded
    function tryRestoreOpen(id, saved) {
      if (!saved || !saved.open) return;
      const maxAttempts = 25; // ~5s at 200ms
      let attempts = 0;
      const tryOnce = () => {
        attempts++;
        try {
          if (id === 'inventory-window') {
            const sock = (window.getSocket && window.getSocket()) || window.socket;
            if (sock && sock.connected) { openWindow('inventory-window'); return true; }
            return false;
          }

          if (id === 'character-window') {
            const sock = (window.getSocket && window.getSocket()) || window.socket;
            if (sock && sock.connected) { openWindow('character-window'); return true; }
            return false;
          }

          if (id === 'screenshots-window' && window.screenshotManager && typeof window.screenshotManager.openModal === 'function') {
            // pass saved context coords if available
            try { window.screenshotManager.openModal(saved.contextX ?? null, saved.contextY ?? null); } catch (e) { window.screenshotManager.openModal(null, null); }
            return true;
          }
          // Add more window mappings here if needed
        } catch (e) { /* ignore and retry */ }
        return false;
      };

      if (tryOnce()) return;
      const iv = setInterval(() => {
        if (tryOnce() || attempts >= maxAttempts) clearInterval(iv);
      }, 200);
    }

    function makeDraggable(winEl, handleEl) {
      if (!winEl || !handleEl) return;
      let isDragging = false;
      let pointerOffsetX = 0;
      let pointerOffsetY = 0;
      let winW = 0;
      let winH = 0;

      const dragStart = (e) => {
        if (e.button && e.button !== 0) return; // only left button
        const rect = winEl.getBoundingClientRect();

        // Freeze current visual position to explicit left/top so subsequent
        // drags don't accumulate via transform and windows can be moved
        // independently without interfering with each other.
        const computed = window.getComputedStyle(winEl);
        // If positioned using right/bottom, remove them and set left/top
        if (computed.right && computed.right !== 'auto') winEl.style.right = 'auto';
        if (computed.bottom && computed.bottom !== 'auto') winEl.style.bottom = 'auto';

        winEl.style.left = rect.left + 'px';
        winEl.style.top = rect.top + 'px';
        winEl.style.transform = '';

        pointerOffsetX = e.clientX - rect.left;
        pointerOffsetY = e.clientY - rect.top;
        winW = rect.width;
        winH = rect.height;
        isDragging = true;
        document.body.style.userSelect = 'none';
      };

      const drag = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        // Compute proposed left/top such that the pointer maintains its offset
        let proposedLeft = e.clientX - pointerOffsetX;
        let proposedTop = e.clientY - pointerOffsetY;

        // Clamp so window stays fully inside viewport
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;
        let minLeft = 0;
        let maxLeft = Math.max(0, viewportW - winW);
        let minTop = 0;
        let maxTop = Math.max(0, viewportH - winH);

        if (winW > viewportW) { minLeft = viewportW - winW; maxLeft = 0; }
        if (winH > viewportH) { minTop = viewportH - winH; maxTop = 0; }

        proposedLeft = Math.min(Math.max(proposedLeft, minLeft), maxLeft);
        proposedTop = Math.min(Math.max(proposedTop, minTop), maxTop);

        winEl.style.left = Math.round(proposedLeft) + 'px';
        winEl.style.top = Math.round(proposedTop) + 'px';
      };

      const dragEnd = () => {
        isDragging = false;
        document.body.style.userSelect = '';
        // Persist final position
        try {
          const left = parseInt(winEl.style.left, 10);
          const top = parseInt(winEl.style.top, 10);
          if (!isNaN(left) && !isNaN(top)) saveWindowState(winEl.id, { left, top });
        } catch (e) {}
      };

      handleEl.addEventListener('mousedown', dragStart);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', dragEnd);
    }

    function initWindow({ id, headerId, closeId, onClose, draggable = true }) {
      const win = document.getElementById(id);
      if (!win) return;
      // Apply saved state (position + open/closed)
      try {
        const saved = getWindowState(id);
        if (saved) {
          if (typeof saved.left !== 'undefined' && typeof saved.top !== 'undefined') {
            try { if (win.style.right && win.style.right !== 'auto') win.style.right = 'auto'; } catch(e){}
            try { if (win.style.bottom && win.style.bottom !== 'auto') win.style.bottom = 'auto'; } catch(e){}
            // Clamp restored position so windows are not placed off-screen
            try {
              const viewportW = window.innerWidth || document.documentElement.clientWidth || 1024;
              const viewportH = window.innerHeight || document.documentElement.clientHeight || 768;
              const savedLeft = Number(saved.left) || 0;
              const savedTop = Number(saved.top) || 0;
              // Try to determine window size; fall back to reasonable defaults
              let winW = win.offsetWidth || parseInt(window.getComputedStyle(win).width, 10) || 304;
              let winH = win.offsetHeight || parseInt(window.getComputedStyle(win).height, 10) || 200;
              // Ensure positive sizes
              winW = Math.max(64, winW);
              winH = Math.max(64, winH);

              const maxLeft = Math.max(0, viewportW - winW);
              const maxTop = Math.max(0, viewportH - winH);
              const left = Math.min(Math.max(0, savedLeft), maxLeft);
              const top = Math.min(Math.max(0, savedTop), maxTop);

              win.style.left = (left) + 'px';
              win.style.top = (top) + 'px';
              win.style.transform = '';
              // Persist clamped values so future restores are sane
              try { saveWindowState(win.id, { left: Math.round(left), top: Math.round(top) }); } catch(e){}
            } catch(e) {
              // Fallback to directly restoring values if clamping fails
              win.style.left = (saved.left) + 'px';
              win.style.top = (saved.top) + 'px';
              win.style.transform = '';
            }
          }
          if (saved.open) {
            win.style.display = saved.display || 'flex';
            try { if (id === 'inventory-window') setHudPressed && setHudPressed('inventory', true); if (id === 'character-window') setHudPressed && setHudPressed('character', true); } catch(e){}
            tryRestoreOpen(id, saved);
          } else {
            win.style.display = 'none';
          }
        }
      } catch (e) { /* ignore state load errors */ }
      const header = headerId ? document.getElementById(headerId) : null;
      const closeBtn = closeId ? document.getElementById(closeId) : null;
      // Ensure a global window z-index tracker exists and that windows
      // are placed above UI textures/shoutbox by default.
      try {
        if (typeof window.__windowTopZ === 'undefined') window.__windowTopZ = 30000;
      } catch (e) { window.__windowTopZ = 30000; }

      // If element has an inline z-index that's lower than our base, override it.
      try {
        const current = parseInt(win.style.zIndex, 10);
        if (!current || current < window.__windowTopZ) {
          win.style.zIndex = (window.__windowTopZ++).toString();
        }
      } catch (e) { win.style.zIndex = (window.__windowTopZ++).toString(); }

      // Bring window to front when focused/clicked so stacking works for multiple windows
      const bringToFront = () => { try { win.style.zIndex = (++window.__windowTopZ).toString(); } catch (e) {} };
      win.addEventListener('mousedown', bringToFront);
      if (header) header.addEventListener('mousedown', bringToFront);

      if (draggable && header) makeDraggable(win, header);
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          // Ensure HUD pressed state is cleared when windows are closed via the close button
          try {
            if (id === 'inventory-window') setHudPressed && setHudPressed('inventory', false);
            if (id === 'character-window') setHudPressed && setHudPressed('character', false);
          } catch (e) {}
          // Persist closed state
          try { saveWindowState(id, { open: false, display: 'none' }); } catch (e) {}
          if (typeof onClose === 'function') onClose();
          else win.style.display = 'none';
        });
      }
      return win;
    }

    function initWindows() {
      initWindow({ id: 'inventory-window', headerId: 'inventory-header', closeId: 'inventory-close-btn', onClose: () => closeWindow('inventory-window') });
      initWindow({ id: 'character-window', headerId: 'character-header', closeId: 'character-close-btn', onClose: () => closeWindow('character-window') });
      // Shoutbox is initialized after its HTML is loaded (see bottom of page)
      initWindow({ id: 'mini-info-window', headerId: null, closeId: 'mini-info-close-btn', draggable: false });
    }

    // Build Path behavior moved to public/build-path.js

    // Tile version switcher handler (button removed from UI; guard for optional element)
    const tileVersionBtn = document.getElementById('tile-version-btn');
    if (tileVersionBtn) {
      tileVersionBtn.textContent = `Map: ${currentTileVersion}`;
      tileVersionBtn.addEventListener('click', () => {
        currentTileVersion = currentTileVersion === 'v1' ? 'v2' : 'v1';
        localStorage.setItem('tileVersion', currentTileVersion);
        tileVersionBtn.textContent = `Map: ${currentTileVersion}`;
        loadTiles();
        console.log('[Map] Switched to tiles-' + currentTileVersion);
      });
    }

    // Logout handler
    document.getElementById('logout-btn').addEventListener('click', () => {
      console.log('[Session] Logging out');
      localStorage.removeItem('sessionToken');
      gameState.sessionToken = null;
      if (gameState.pollInterval) {
        clearInterval(gameState.pollInterval);
      }
      if (gameState.territoriesPollInterval) {
        clearInterval(gameState.territoriesPollInterval);
      }
      if (gameState.superbossesPollInterval) {
        clearInterval(gameState.superbossesPollInterval);
      }
      location.reload();
    });

    

    // Generic open/close helpers that work across windows. These prefer
    // per-window specialized functions (e.g. `openInventory`) when present,
    // otherwise they perform a simple show/hide and persist state.
    function _normalizeWindowId(id){
      if(!id) return id;
      if(document.getElementById(id)) return id;
      // accept shorthand like 'inventory' -> 'inventory-window'
      const winId = id.endsWith('-window') ? id : (id + '-window');
      return document.getElementById(winId) ? winId : id;
    }

    async function openWindow(id){
      const winId = _normalizeWindowId(id);
      const base = String(winId).replace(/-window$/, '');
      const fnName = 'open' + base.charAt(0).toUpperCase() + base.slice(1);
      const el = document.getElementById(winId);
      if(!el) return Promise.resolve();
      // Inventory: implement inventory-specific initialization inline
      if (base === 'inventory') {
        el.style.display = 'flex';
        try { saveWindowState(winId, { open: true, display: el.style.display || 'flex' }); } catch(e){}
        try { setHudPressed && setHudPressed('inventory', true); } catch(e){}
        try { document.getElementById('inventory-loading').style.display = 'block'; } catch(e){}
        try { document.getElementById('inventory-items').style.display = 'none'; } catch(e){}
        try { document.getElementById('inventory-empty').style.display = 'none'; } catch(e){}

        try {
          let socket = window.getSocket && window.getSocket();
          if (!socket || !socket.connected) {
            if (window.initializeWebSocket) {
              window.initializeWebSocket();
              socket = window.getSocket && window.getSocket();
              if (socket && !socket.connected) {
                await new Promise((resolve, reject) => {
                  const timeout = setTimeout(() => reject(new Error('WebSocket connection timeout')), 3000);
                  socket.once('connect', () => { clearTimeout(timeout); resolve(); });
                });
              }
            }
          }
          if (!socket || !socket.connected) throw new Error('WebSocket not available');
          socket.emit('equipment:get', (equipData) => { if (equipData && equipData.success) displayEquipment(equipData.equipment); });
          socket.emit('inventory:get', (invData) => { if (invData && invData.success) displayInventory(invData.items); });
        } catch (error) {
          console.error('Failed to fetch inventory:', error);
          alert('Failed to load inventory: ' + (error && error.message ? error.message : 'Unknown error'));
          // Hide window on failure
          try { el.style.display = 'none'; } catch(e){}
          try { setHudPressed && setHudPressed('inventory', false); } catch(e){}
          try { saveWindowState(winId, { open: false, display: 'none' }); } catch(e){}
        }
        return Promise.resolve();
      }

      // Character: inline the previous openCharacter() flow
      if (base === 'character') {
        el.style.display = 'flex';
        try { saveWindowState(winId, { open: true, display: el.style.display || 'flex' }); } catch(e){}
        try { setHudPressed && setHudPressed('character', true); } catch(e){}

        try{
          const requestStats = () => new Promise((resolve) => {
            if (window.socket && socket && socket.connected) {
              socket.emit('player:stats:get', (resp) => {
                if (resp && resp.success && resp.state) return resolve(resp.state);
                resolve(null);
              });
              setTimeout(() => resolve(null), 1500);
            } else {
              resolve(null);
            }
          });

          let posData = await requestStats();
          if (!posData) {
            if (!(window.socket && socket && socket.connected)) {
              posData = await new Promise((resolve) => {
                function onConnect() {
                  window.removeEventListener('websocket:connected', onConnect);
                  const s = window.getSocket && window.getSocket();
                  if (s && s.connected) {
                    s.emit('player:stats:get', (resp) => { resolve(resp && resp.success && resp.state ? resp.state : null); });
                  } else resolve(null);
                }
                window.addEventListener('websocket:connected', onConnect);
                setTimeout(() => { window.removeEventListener('websocket:connected', onConnect); resolve(null); }, 10000);
              });
            }
          }

          if (posData) {
            gameState.xp = typeof posData.xp !== 'undefined' ? posData.xp : gameState.xp;
            gameState.level = typeof posData.level !== 'undefined' ? posData.level : gameState.level;
            gameState.xpToNext = typeof posData.xpToNext !== 'undefined' ? posData.xpToNext : gameState.xpToNext;
            gameState.stats = posData.stats || gameState.stats;
            gameState.damage = typeof posData.damage !== 'undefined' ? posData.damage : (gameState.damage || 0);
            gameState.armor = typeof posData.armor !== 'undefined' ? posData.armor : (gameState.armor || 0);
            gameState.username = typeof posData.username !== 'undefined' ? posData.username : gameState.username;
            gameState.realm = typeof posData.realm !== 'undefined' ? posData.realm : gameState.realm;
            gameState.className = typeof posData.className !== 'undefined' ? posData.className : gameState.className;
          }
        } catch (err) { console.error('Failed to load character data:', err); }

        try { if (typeof updateCharacterStats === 'function') updateCharacterStats(); } catch(e){}
        return Promise.resolve();
      }

      // Fallback: show generic window
      el.style.display = 'flex';
      try { saveWindowState(winId, { open: true, display: el.style.display || 'flex' }); } catch(e){}
      return Promise.resolve();
    }

    async function closeWindow(id){
      const winId = _normalizeWindowId(id);
      const base = String(winId).replace(/-window$/, '');
      const fnName = 'close' + base.charAt(0).toUpperCase() + base.slice(1);
      if(typeof window[fnName] === 'function'){
        try { return await window[fnName](); } catch(e){ console.debug(fnName + ' failed', e); }
      }

      const el = document.getElementById(winId);
      if(!el) return Promise.resolve();
      el.style.display = 'none';
      try { if(base === 'inventory') setHudPressed && setHudPressed('inventory', false); if(base === 'character') setHudPressed && setHudPressed('character', false); } catch(e){}
      try { saveWindowState(winId, { open: false, display: 'none' }); } catch(e){}
      return Promise.resolve();
    }

    // Character window functions moved to public/character.html
    
    function displayInventory(items) {
      document.getElementById('inventory-loading').style.display = 'none';

      const container = document.getElementById('inventory-items');
      const footer = document.getElementById('inventory-footer');
      
      // Reset scroll to top on refresh
      container.scrollTop = 0;
      
      container.innerHTML = '';

      if (items.length === 0) {
        document.getElementById('inventory-empty').style.display = 'block';
        footer.style.display = 'none';
        return;
      }

      document.getElementById('inventory-items').style.display = 'block';
      footer.style.display = 'flex';

      // Calculate total gold
      let totalGold = 0;

      // Render items as list
      items.forEach(item => {
        // Track gold
        if (getItemName(item) === 'Gold') {
          totalGold += item.quantity;
        }

        const itemDiv = document.createElement('div');
        itemDiv.className = 'inventory-item';

        const iconName = item.iconName;
        const iconSrc = iconName ? `https://cor-forum.de/regnum/RegnumNostalgia/items/${iconName}` : '';
        const iconHtml = iconSrc ? `<img src="${iconSrc}" alt="${getItemName(item)}">` : '';

        const rarityClass = (item.rarity || 'common');

        itemDiv.innerHTML = `
          <div class="item-icon">${iconHtml}</div>
          <div class="item-name ${rarityClass}">${getItemName(item)}${typeof item.level !== 'undefined' ? ` <span class="item-level">Lv ${item.level}</span>` : ''}</div>
          ${item.quantity > 1 ? `<div class="item-quantity">×${item.quantity}</div>` : ''}
        `;

        // Make draggable and attach dragstart payload (include equipmentSlot)
        const invId = item.inventoryId;
        const equipSlot = item.equipmentSlot ?? null;
        itemDiv.draggable = true;
        itemDiv.dataset.inventoryId = invId;
        itemDiv.dataset.equipmentSlot = equipSlot || '';
        // Do not visually de-emphasize non-equippable items; server still enforces equips
        itemDiv.addEventListener('dragstart', (ev) => {
          const payload = JSON.stringify({ inventoryId: invId, equipmentSlot: equipSlot });
          try { ev.dataTransfer.setData('application/json', payload); } catch(_) { ev.dataTransfer.setData('text/plain', payload); }
        });

        // Tooltip on hover
        itemDiv.addEventListener('mouseenter', (e) => showTooltip(e, item));
        itemDiv.addEventListener('mouseleave', (e) => { if (!tooltipKeepOpen) hideTooltip(); });
        itemDiv.addEventListener('mousemove', (e) => moveTooltip(e));
        itemDiv.addEventListener('click', () => { tooltipKeepOpen = true; });
        // Ensure tooltip stays above windows when item is clicked/pressed
        itemDiv.addEventListener('mousedown', () => {
          try {
            if (currentTooltip) {
              currentTooltip.style.zIndex = '50000';
            }
          } catch (e) {}
        });

        // Right-click context menu
        itemDiv.addEventListener('contextmenu', async (e) => {
          try {
            e.preventDefault();
            const id = itemDiv.dataset.inventoryId;
            if (!id) return;

            // Fetch full item details to check if it's usable
            const getItemDetails = () => new Promise((resolve, reject) => {
              if (window.socket && socket && socket.connected) {
                socket.emit('item:details', { inventoryId: id }, (resp) => {
                  if (resp && resp.success) {
                    resolve(resp.item);
                  } else {
                    reject(new Error('Failed to fetch item details'));
                  }
                });
              } else {
                reject(new Error('Not connected'));
              }
            });

            const itemDetails = await getItemDetails();
            const isUsable = itemDetails.type === 'premium' && itemDetails.stats && itemDetails.stats.loot_table;

            if (isUsable) {
              // Use item (open box)
              try {
                const useItem = () => new Promise((resolve, reject) => {
                  if (window.socket && socket && socket.connected) {
                    socket.emit('item:use', { inventoryId: id }, (resp) => {
                      if (resp && resp.success) {
                        resolve(resp);
                      } else {
                        reject(new Error(resp?.error || 'Failed to use item'));
                      }
                    });
                  } else {
                    reject(new Error('Not connected'));
                  }
                });

                const result = await useItem();
                if (result && result.rewards && result.rewards.length > 0) {
                  const rewardNames = result.rewards.map(r => r.name).join(', ');
                }
              } catch (err) {
                const msg = (err && err.message) ? err.message : 'Failed to use item';
                if (window.addLogMessage) window.addLogMessage(msg, 'error');
              }
            } else {
              // Try to equip item
              const form = new URLSearchParams();
              form.append('inventoryId', id);
              try {
                await emitOrApi('equipment:equip', { inventoryId: id }, '/equipment/equip', form);
              } catch (err) {
                const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to equip item';
                if (window.addLogMessage) window.addLogMessage(msg, 'error');
              }
              // Only refresh windows after equipping (not after using items)
              try { if (document.getElementById('character-window') && document.getElementById('character-window').style.display !== 'none') await openWindow('character-window'); } catch(e){}
              try { if (document.getElementById('inventory-window') && document.getElementById('inventory-window').style.display !== 'none') await openWindow('inventory-window'); } catch(e){}
            }
          } catch (e) { console.error('inventory right-click failed', e); }
        });

        container.appendChild(itemDiv);
      });
      
      // Update gold display
      document.getElementById('inventory-gold').textContent = `${totalGold.toLocaleString()} Gold`;
    }

    // Make inventory container accept drops from equipment slots (unequip)
    (function(){
      const invContainer = document.getElementById('inventory-items');
      if(!invContainer) return;
      invContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
      invContainer.addEventListener('drop', async (e) => {
        e.preventDefault();
        try {
          const payload = e.dataTransfer.getData('application/json') || e.dataTransfer.getData('text/plain');
          if(!payload) return;
          const data = JSON.parse(payload);
          if(data.fromSlot && data.slot){
            // Unequip slot
            const form = new URLSearchParams();
            form.append('slot', data.slot);
            try {
              await emitOrApi('equipment:unequip', { slot: data.slot }, '/equipment/unequip', form);
            } catch (err) {
              try {
                const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to unequip item';
                if (window.addLogMessage) window.addLogMessage(msg, 'error');
              } catch (e) { console.error('Failed to log unequip error', e); }
            }
            // refresh inventory and equipment
            try { await openWindow('inventory-window'); } catch(e){}
          }
        } catch(err){ console.error('Failed to unequip:', err); }
      });
    })();

    let currentTooltip = null;
    let pendingTooltipTimer = null;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let tooltipKeepOpen = false;

    function positionTooltip(tooltip, mouseX, mouseY) {
      if (!tooltip) return;
      // Temporarily position to get dimensions
      tooltip.style.left = '0px';
      tooltip.style.top = '0px';
      const tipRect = tooltip.getBoundingClientRect();
      const tipWidth = tipRect.width;
      const tipHeight = tipRect.height;
      const gap = 6;
      let left = mouseX - tipWidth - gap;
      if (left < 4) {
        left = mouseX + gap;
      }
      let top = mouseY - (tipHeight / 2);
      top = Math.max(4, Math.min(top, window.innerHeight - tipHeight - 4));
      tooltip.style.left = Math.round(left) + 'px';
      tooltip.style.top = Math.round(top) + 'px';
      // Adjust if still out
      const finalRect = tooltip.getBoundingClientRect();
      if (finalRect.right > window.innerWidth - 4) {
        left = window.innerWidth - finalRect.width - 4;
        tooltip.style.left = Math.round(left) + 'px';
      }
      if (finalRect.left < 4) {
        left = 4;
        tooltip.style.left = Math.round(left) + 'px';
      }
    }

    function showTooltip(event, item) {
      hideTooltip();

      // Clear any previously scheduled tooltip creation
      try { if (pendingTooltipTimer) { clearTimeout(pendingTooltipTimer.timer); pendingTooltipTimer = null; } } catch(e){}

      const anchorEl = event.currentTarget || event.target;
      const tooltipIconName = item.iconName;
      const tooltipIconSrc = tooltipIconName ? `https://cor-forum.de/regnum/RegnumNostalgia/items/${tooltipIconName}` : '';
      const rarityClass = (item.rarity || 'common');

      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      tooltipKeepOpen = false;

      // Schedule tooltip creation after 200ms. If the pointer moves away
      // before this timer fires, the tooltip will not be shown.
      const timer = setTimeout(() => {
        // Create and append tooltip now
        const tooltip = document.createElement('div');
        tooltip.className = 'item-tooltip';

        // Basic header (name + icon) shown after 200ms; detailed fields
        // will be filled in when the server responds.
        tooltip.innerHTML = `
          <div class="tooltip-header">
            <div class="tooltip-icon">${tooltipIconSrc ? `<img src="${tooltipIconSrc}" alt="${getItemName(item)}">` : ''}</div>
            <div class="tooltip-title">
              <div class="tooltip-name ${rarityClass}">${getItemName(item)} ${typeof item.level !== 'undefined' ? `<span class="tooltip-level">Lv ${item.level}</span>` : ''}</div>
            </div>
          </div>
          <div class="tooltip-type">${getItemTypeLabel(item)}</div>
          <div class="tooltip-rarity ${rarityClass}">${rarityClass}</div>
        `;

        document.body.appendChild(tooltip);
        if (typeof window.__windowTopZ === 'undefined') window.__windowTopZ = 30000;
        try { tooltip.style.zIndex = '40000'; } catch (e) { tooltip.style.zIndex = '40000'; }
        currentTooltip = tooltip;
        requestAnimationFrame(() => positionTooltip(tooltip, event.clientX, event.clientY));

        // After showing tooltip, fetch fresh details with a request
        const invId = item.inventoryId || null;
        if (invId && window.getSocket) {
          try {
            const sock = window.getSocket();
            const doEmit = (s) => {
              try {
                tooltip.__requestInventoryId = String(invId);
                s.emit('item:details', { inventoryId: invId }, (resp) => {
                  try {
                    if (!resp || !resp.success) return;
                    const det = resp.item || {};
                    if (!currentTooltip || currentTooltip !== tooltip) return;
                    if (String(tooltip.__requestInventoryId) !== String(invId)) return;

                    let newStatsHtml = '';
                    if (det.stats && Object.keys(det.stats || {}).length > 0) {
                      const parts = Object.entries(det.stats).map(([k,v]) => `+${v} ${k.replace('_',' ')}`);
                      newStatsHtml = `<div class="tooltip-stats">${parts.join('<br>')}</div>`;
                    }

                    const newIconName = det.iconName || null;
                    const newIconSrc = newIconName ? `https://cor-forum.de/regnum/RegnumNostalgia/items/${newIconName}` : (tooltipIconSrc || '');
                    const newRarity = det.rarity || rarityClass;

                    tooltip.innerHTML = `
                      <div class="tooltip-header">
                        <div class="tooltip-icon">${newIconSrc ? `<img src="${newIconSrc}" alt="${getItemName(det)}">` : ''}</div>
                        <div class="tooltip-title">
                          <div class="tooltip-name ${newRarity}">${getItemName(det)} ${typeof det.level !== 'undefined' ? `<span class="tooltip-level">Lv ${det.level}</span>` : ''}</div>
                        </div>
                      </div>
                      <div class="tooltip-type">${getItemTypeLabel(det)}</div>
                      ${det.description ? `<div class="tooltip-description">"${det.description}"</div>` : ''}
                      ${newStatsHtml}
                      <div class="tooltip-rarity ${newRarity}">${newRarity}</div>
                    `;

                    requestAnimationFrame(() => positionTooltip(tooltip, lastMouseX, lastMouseY));
                  } catch (e) { console.error('Failed to apply item details to tooltip', e); }
                });
              } catch (e) { /* ignore socket emit errors */ }
            };

            if (sock && sock.connected) {
              doEmit(sock);
            } else if (sock) {
              // Socket exists but isn't connected yet: retry until connected or timeout
              let retries = 0;
              const maxRetries = 20; // ~5 seconds at 250ms interval
              tooltip.__socketRetry = setInterval(() => {
                try {
                  const s2 = window.getSocket && window.getSocket();
                  if (s2 && s2.connected) {
                    clearInterval(tooltip.__socketRetry);
                    tooltip.__socketRetry = null;
                    doEmit(s2);
                    return;
                  }
                  retries += 1;
                  if (retries >= maxRetries) {
                    clearInterval(tooltip.__socketRetry);
                    tooltip.__socketRetry = null;
                  }
                } catch (e) { clearInterval(tooltip.__socketRetry); tooltip.__socketRetry = null; }
              }, 250);
            }
          } catch (e) { /* ignore socket errors */ }
        }
      }, 200);

      pendingTooltipTimer = { timer, anchorEl };
    }

    function moveTooltip(event) {
      if (!currentTooltip) return;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      positionTooltip(currentTooltip, event.clientX, event.clientY);
    }

    function hideTooltip() {
      if (currentTooltip) {
        try { if (currentTooltip.__detailsTimer) { clearTimeout(currentTooltip.__detailsTimer); currentTooltip.__detailsTimer = null; } } catch(e){}
        try { if (currentTooltip.__socketRetry) { clearInterval(currentTooltip.__socketRetry); currentTooltip.__socketRetry = null; } } catch(e){}
        try { if (currentTooltip.__requestInventoryId) { currentTooltip.__requestInventoryId = null; } } catch(e){}
        currentTooltip.remove();
        currentTooltip = null;
      }
      try { if (pendingTooltipTimer) { clearTimeout(pendingTooltipTimer.timer); pendingTooltipTimer = null; } } catch(e){}
    }

    // Equipment rendering and drag/drop handlers
    function getEquipIconSrc(item){
      const iconName = item.iconName;
      return iconName ? `https://cor-forum.de/regnum/RegnumNostalgia/items/${iconName}` : '';
    }

    // Friendly label for item type + equipment slot
    function getItemTypeLabel(item){
      const slot = item.equipmentSlot || null;
      if(slot){
        switch(slot){
          case 'head': return 'Armor (Head)';
          case 'body': return 'Armor (Body)';
          case 'hands': return 'Armor (Hands)';
          case 'shoulders': return 'Armor (Shoulders)';
          case 'legs': return 'Armor (Legs)';
          case 'weaponRight': return 'Weapon (Right Hand)';
          case 'weaponLeft': return 'Weapon (Left Hand)';
          case 'ringRight':
          case 'ringLeft': return 'Ring';
          case 'amulet': return 'Amulet';
          default: return item.itemType || '';
        }
      }
      const t = item.itemType || '';
      return t.charAt(0).toUpperCase() + t.slice(1);
    }

    // Normalize item display name across different API shapes
    function getItemName(item){
      if(!item) return 'Unknown Item';
      return item.itemName || item.name || item.displayName || 'Unknown Item';
    }

    function displayEquipment(equipment){
      try{
        const slots = ['head','body','hands','shoulders','legs','weaponRight','weaponLeft','ringRight','ringLeft','amulet'];
        slots.forEach(slot => {
          const el = document.querySelector(`.equipment-slot[data-slot="${slot}"]`);
          if(!el) return;
          const info = equipment[slot] || { inventoryId: null, item: null };
          el.classList.toggle('empty', !info || !info.inventoryId);
          el.dataset.slot = slot;
          // clear previous listeners by cloning node
          const newEl = el.cloneNode(true);
          el.parentNode.replaceChild(newEl, el);
          const target = newEl;

          if(info && info.inventoryId){
            const it = info.item || {};
            const iconSrc = getEquipIconSrc(it || {});
            target.innerHTML = iconSrc ? `<div class="slot-icon"><img src="${iconSrc}" alt="${it.name || it.itemName || 'Item'}"></div>` : '';
            target.dataset.inventoryId = info.inventoryId;
            // Tooltip
            target.addEventListener('mouseenter', (e)=>{
              const tooltipItem = {
                itemName: it.name || it.itemName || '',
                itemType: it.type || it.itemType || '',
                equipmentSlot: it.equipmentSlot || null,
                description: it.description || '',
                stats: it.stats || {},
                rarity: it.rarity || 'common',
                quantity: it.quantity || 1,
                level: typeof it.level !== 'undefined' ? it.level : 1,
                iconName: it.iconName || null,
                inventoryId: info.inventoryId || null
              };
              showTooltip(e, tooltipItem);
            });
            target.addEventListener('mousemove', moveTooltip);
            target.addEventListener('mouseleave', hideTooltip);
            // When slot is pressed/clicked, raise tooltip above windows
            target.addEventListener('mousedown', () => {
              try {
                if (currentTooltip) {
                  if (typeof window.__windowTopZ === 'undefined') window.__windowTopZ = 30000;
                  currentTooltip.style.zIndex = String(++window.__windowTopZ);
                }
              } catch (e) {}
            });

            // Make slot draggable to allow unequip (drag to inventory)
            target.draggable = true;
            target.addEventListener('dragstart', (ev) => {
              const payload = JSON.stringify({ fromSlot: true, slot: slot, inventoryId: info.inventoryId });
              try{ ev.dataTransfer.setData('application/json', payload); }catch(_){ ev.dataTransfer.setData('text/plain', payload); }
            });

            // Right-click to unequip
            target.addEventListener('contextmenu', async (e) => {
              try {
                e.preventDefault();
                const form = new URLSearchParams();
                form.append('slot', slot);
                try {
                  await emitOrApi('equipment:unequip', { slot }, '/equipment/unequip', form);
                } catch (err) {
                  const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to unequip item';
                  if (window.addLogMessage) window.addLogMessage(msg, 'error');
                }
                try { if (document.getElementById('inventory-window') && document.getElementById('inventory-window').style.display !== 'none') await openWindow('inventory-window'); } catch(e){}
                try { if (document.getElementById('character-window') && document.getElementById('character-window').style.display !== 'none') await openWindow('character-window'); } catch(e){}
              } catch (e) { console.error('equipment right-click unequip failed', e); }
            });
          } else {
            // empty slot: clear inner content — background image handles the icon
            target.innerHTML = '';
            target.removeAttribute('data-inventory-id');
            target.draggable = false;
            target.addEventListener('mouseenter', ()=>{});
          }

          // Accept drops from inventory items
          target.addEventListener('dragover', (e)=>{ e.preventDefault(); target.classList.add('drag-over'); });
          target.addEventListener('dragleave', ()=>{ target.classList.remove('drag-over'); });
          target.addEventListener('drop', async (e)=>{
            e.preventDefault(); target.classList.remove('drag-over');
            try{
              const payload = e.dataTransfer.getData('application/json') || e.dataTransfer.getData('text/plain');
              if(!payload) return;
              const data = JSON.parse(payload);
              if(data.inventoryId){
                // Allow dropping onto any slot; server will auto-assign the correct template slot.
                const form = new URLSearchParams();
                form.append('inventoryId', data.inventoryId);
                try {
                  await emitOrApi('equipment:equip', { inventoryId: data.inventoryId }, '/equipment/equip', form);
                } catch (err) {
                  try {
                    const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to equip item';
                    if (window.addLogMessage) window.addLogMessage(msg, 'error');
                  } catch (e) { console.error('Failed to log equip error', e); }
                }
                // Refresh equipment view and inventory if visible
                try {
                  if (document.getElementById('character-window') && document.getElementById('character-window').style.display !== 'none') {
                    await openWindow('character-window');
                  }
                } catch(e){}
                try {
                  if (document.getElementById('inventory-window') && document.getElementById('inventory-window').style.display !== 'none') {
                    await openWindow('inventory-window');
                  }
                } catch(e){}
              }
            }catch(err){ console.error('Equip failed', err); }
          });
        });
      }catch(err){ console.error('displayEquipment error', err); }
    }

    // hideModal and showRealmSelection functions now in login.html

    // Build Path UI moved to public/build-path.js

    // Build panel wiring moved to public/build-path.js

    function showPlayerInfo() {
      const username = gameState.username || '';
      const usernameEl = document.getElementById('player-username');
      const charNameEl = document.getElementById('char-name');
      const realmBadge = document.querySelector('#ui-character-status .realm-badge');
      console.debug('showPlayerInfo username=', username);
      if (usernameEl) usernameEl.textContent = username;
      if (charNameEl && !charNameEl.textContent.trim()) charNameEl.textContent = username || '-';
      if (realmBadge) realmBadge.className = `realm-badge ${gameState.realm}`;
      // populate level display if present
      const lvlEl = document.getElementById('player-level');
      if (lvlEl) lvlEl.textContent = gameState.level || 1;
    }

    function updatePlayerStats() {
      // Update health bar
      const healthPercent = (gameState.health / gameState.maxHealth) * 100;
      const healthFill = document.getElementById('player-health-fill');
      const healthText = document.getElementById('player-health-text');
      
      healthFill.style.width = `${healthPercent}%`;
      healthText.textContent = `${gameState.health}/${gameState.maxHealth}`;
      
      // Ensure the overlay player health fill uses the UI border-image and remains visible
      healthFill.className = 'territory-health-fill';
      healthFill.style.backgroundColor = 'transparent';
      healthFill.style.borderWidth = '0 2px 0 2px';
      healthFill.style.borderStyle = 'solid';
      healthFill.style.boxSizing = 'border-box';
      healthFill.style.borderImage = "url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-bar-health.png') 0 2 0 2 fill / 0 2px 0 2px / 0 stretch";

      // Update mana bar
      const manaPercent = (gameState.mana / gameState.maxMana) * 100;
      const manaFill = document.getElementById('player-mana-fill');
      const manaText = document.getElementById('player-mana-text');
      
      manaFill.style.width = `${manaPercent}%`;
      manaText.textContent = `${gameState.mana}/${gameState.maxMana}`;
    }

    function updatePlayerCoords(x, y) {
      document.getElementById('player-coords').textContent = `Position: ${x}, ${y}`;

      // If player reached walking target, clear walking UI
      if (gameState.walkingTarget && gameState.walkingTarget.x === x && gameState.walkingTarget.y === y) {
        // remove destination marker
        if (gameState.walkDestinationMarker) {
          try { map.removeLayer(gameState.walkDestinationMarker); } catch (e) {}
          gameState.walkDestinationMarker = null;
        }
        gameState.walkingTarget = null;
        // Also clear any displayed walk path immediately when the player
        // arrives so the yellow path indicator is removed.
        try { if (window.buildPath && typeof window.buildPath.clearWalkerPath === 'function') window.buildPath.clearWalkerPath(); } catch (e) { console.debug('clear walk path failed', e); }
      }
    }

    // Initialize game after login/realm selection
    async function initGame() {
      try {
        // WebSocket-only: request initial player state via socket.
        let data = null;
        const requestPlayerState = () => new Promise((resolve) => {
          if (window.socket && socket && socket.connected) {
            socket.emit('player:stats:get', (resp) => {
              if (resp && resp.success && resp.state) return resolve(resp.state);
              resolve(null);
            });
            // Also rely on server-emitted 'player:state' which will update via updatePlayerFromState
            setTimeout(() => resolve(null), 1500);
          } else {
            resolve(null);
          }
        });

        data = await requestPlayerState();
        if (data && data.position) {
          gameState.position = data.position;
        gameState.realm = data.realm ?? gameState.realm;
        gameState.username = typeof data.username !== 'undefined' ? data.username : gameState.username;
        gameState.health = data.health ?? gameState.health;
        gameState.maxHealth = data.maxHealth ?? gameState.maxHealth;
        gameState.mana = data.mana ?? gameState.mana;
        gameState.maxMana = data.maxMana ?? gameState.maxMana;
        gameState.damage = typeof data.damage !== 'undefined' ? data.damage : 0;
        gameState.armor = typeof data.armor !== 'undefined' ? data.armor : 0;
        // XP / level / stats
        gameState.xp = typeof data.xp !== 'undefined' ? data.xp : 0;
        gameState.level = typeof data.level !== 'undefined' ? data.level : 1;
        gameState.xpToNext = typeof data.xpToNext !== 'undefined' ? data.xpToNext : 0;
        gameState.stats = data.stats || { intelligence:20, dexterity:20, concentration:20, strength:20, constitution:20 };
        } else {
          // No socket response yet — rely on server-emitted 'player:state' or existing `gameState` defaults.
          console.warn('No initial player state received via WebSocket; waiting for server emission');
        }

        // Validate session: prefer socket-provided state, but verify via HTTP
        try {
          let httpPlayerData = null;
          try {
            httpPlayerData = await apiCall('/player/position');
            // If socket didn't provide a state, use the HTTP response
            if (!(data && data.position)) data = httpPlayerData;
          } catch (httpErr) {
            const msg = String(httpErr && httpErr.message ? httpErr.message : '');
            const status = httpErr && typeof httpErr.status !== 'undefined' ? httpErr.status : null;
            const authFailure = (status === 401 || status === 403) || /invalid|expired|unauthor/i.test(msg);
            const playerNotFound = /player not found/i.test(msg);
            if (authFailure || playerNotFound) {
              // Let outer catch handle clearing the token
              throw httpErr;
            }
            // Non-auth HTTP error (network/etc) — fall back to socket data if present
          }

          // Check if realm is selected after getting server data
          // If data has no realm or realm is null/empty, show realm selection
          if (data && (!data.realm || data.realm === null || data.realm === '')) {
            console.debug('No realm selected (from server), showing realm selection screen');
            if (typeof window.showRealmSelection === 'function') {
              window.showRealmSelection();
              return;
            }
          }

          // Only reveal UI if we have a valid player state. If the realm
          // selection flow already populated `gameState.position`, use it as
          // a fallback to avoid returning to login on first-time realm select.
          if (!(data && data.position)) {
            if (gameState && gameState.position && typeof gameState.position.x === 'number' && typeof gameState.position.y === 'number') {
              data = {
                position: gameState.position,
                realm: gameState.realm,
                username: gameState.username,
                health: gameState.health,
                maxHealth: gameState.maxHealth,
                mana: gameState.mana,
                maxMana: gameState.maxMana,
                damage: gameState.damage,
                armor: gameState.armor,
                xp: gameState.xp,
                level: gameState.level,
                xpToNext: gameState.xpToNext,
                stats: gameState.stats
              };
            } else {
              throw new Error('No player state received');
            }
          }

          document.body.classList.add('authenticated');
        } catch (e) {
          // Re-throw to be handled by outer catch block
          throw e;
        }
        // Allow layout to settle, then invalidate Leaflet size and re-center map
        try {
          setTimeout(() => {
            try {
              if (typeof map !== 'undefined' && map && typeof map.invalidateSize === 'function') {
                map.invalidateSize();
                // Center on middle of map
                const centerLatLng = [totalH / 2, totalW / 2];
                try { map.setView(centerLatLng, -2); } catch(e){}
              }
            } catch (e) {}
          }, 100);
        } catch(e) {}

        // Ensure regions are rendered after the map has been resized/recentered
        // This prevents a case where regions only appear after a manual zoom.
        try {
          setTimeout(() => {
            try {
              if (window.loadAndRenderRegions && typeof window.loadAndRenderRegions === 'function') {
                window.loadAndRenderRegions();
              }
            } catch (e) { console.debug('loadAndRenderRegions failed', e); }
          }, 250);
        } catch (e) {}

        hideModal();
        showPlayerInfo();
        updatePlayerStats();

        // Create player marker
        createPlayerMarker(gameState.position.x, gameState.position.y);

        // If the server provided an active walker path for this player, draw it
        // immediately so the player sees the walking path on login without
        // waiting for the periodic poller.
        try {
          if (data.walker && data.walker.positions && window.buildPath && typeof window.buildPath.setWalkerPositions === 'function') {
            try { window.buildPath.setWalkerPositions(data.walker.positions, typeof data.walker.currentIndex === 'number' ? data.walker.currentIndex : 0); } catch (e) { console.debug('drawWalkPath on init failed', e); }
          }
        } catch (e) { console.debug('drawWalkPath on init failed', e); }

        // If the server provided a walker destination, show the yellow
        // destination marker and set walkingTarget immediately so the UI is
        // consistent on login.
        try {
          if (data.walker && data.walker.destination) {
            const dest = data.walker.destination;
            const dx = parseInt(dest[0], 10);
            const dy = parseInt(dest[1], 10);
            if (gameState.walkDestinationMarker) {
              try { map.removeLayer(gameState.walkDestinationMarker); } catch (e) {}
            }
            gameState.walkDestinationMarker = L.marker([totalH - dy, dx], { icon: buildGoHereIcon(), riseOnHover: true }).addTo(map);
            gameState.walkingTarget = { x: dx, y: dy };
          }
        } catch (e) { console.debug('init: set walkDestinationMarker failed', e); }

        // Load and render paths from server only if enabled
        if (gameState.showPaths) await loadAndRenderPaths();

        // Enable click-to-move
        enableClickToMove();

        // Initialize WebSocket connection for real-time updates
        initializeWebSocket();

        // Do not load screenshots automatically on page load.
        // Screenshots will be loaded and displayed when the Screenshot Manager is opened.

        updatePlayerCoords(gameState.position.x, gameState.position.y);
      } catch (error) {
        // Initialization failed. Only remove the stored session token if the
        // server explicitly rejected it (401/403) or reported it as invalid/expired.
        console.debug('initGame failed, returning to login:', error && error.message ? error.message : error);
        try {
          const msg = String((error && error.message) ? error.message : '');
          const status = (error && typeof error.status !== 'undefined') ? error.status : null;
          const authFailure = (status === 401 || status === 403) || /invalid|expired|unauthor/i.test(msg);
          const playerNotFound = /player not found/i.test(msg);
          
          if (authFailure || playerNotFound) {
            console.log('[Session] Auth failure or player not found detected, clearing stored token');
            try { localStorage.removeItem('sessionToken'); } catch (e) {}
            try { sessionStorage.removeItem('sessionToken'); } catch (e) {}
            try { gameState.sessionToken = null; } catch (e) {}
          } else {
            // For transient/network errors, keep the token so the user isn't
            // forcibly logged out by a hard reload; allow them to retry.
            console.debug('initGame: keeping sessionToken due to non-auth error');
          }
        } catch (e) { console.debug('initGame: error while evaluating auth failure', e); }

        try {
          // Hide loading spinner and show login form
          const loginForm = document.getElementById('login-form');
          const autoLoginLoading = document.getElementById('auto-login-loading');
          if (loginForm) loginForm.style.display = 'block';
          if (autoLoginLoading) autoLoginLoading.classList.add('hidden');
          
          // Hide authenticated UI and show login modal
          document.body.classList.remove('authenticated');
          const overlay = document.getElementById('modal-overlay');
          if (overlay) overlay.classList.remove('hidden');
          
          // Ensure login step is active
          try { 
            document.getElementById('step-login').classList.add('active'); 
            document.getElementById('step-realm').classList.remove('active'); 
          } catch (e) {}
        } catch (e) {
          console.error('[InitGame] Error resetting UI:', e);
        }
        
        // Re-throw to propagate to caller
        throw error;
      }
    }

    // Expose initGame globally for use by login.html
    window.initGame = initGame;

    function createPlayerMarker(x, y) {
      if (gameState.playerMarker) {
        map.removeLayer(gameState.playerMarker);
      }

      const latLng = [totalH - y, x];
      const myColor = getRealmColor(gameState.realm);
      gameState.playerMarker = L.circleMarker(latLng, {
        radius: 8,
        fillColor: myColor,
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
      }).addTo(map);

      // store original player color for later restore when walking finishes

      gameState.playerMarker.bindPopup(`<b>${gameState.username}</b><br>Realm: ${gameState.realm}`);
      try {
        const name = escapeHtml(gameState.username || 'You');
        const tt = `
          <div class="tooltip-title">${name}</div>
          <div class="tooltip-row"><strong>Realm:</strong> ${escapeHtml(gameState.realm)}</div>
          <div class="tooltip-row"><strong>HP:</strong> ${escapeHtml(gameState.health)}/${escapeHtml(gameState.maxHealth)}</div>
        `;
        gameState.playerMarker.bindTooltip(tt, { permanent: false, direction: 'top', className: 'player-tooltip', offset: [0, -10] });
      } catch (e) { /* ignore tooltip binding errors */ }
      // Ensure player marker is rendered above other markers (spawn/territory icons)
      try {
        if (typeof gameState.playerMarker.setZIndexOffset === 'function') gameState.playerMarker.setZIndexOffset(1000);
        if (typeof gameState.playerMarker.bringToFront === 'function') gameState.playerMarker.bringToFront();
      } catch (e) {}
      // Center on middle of map
      const centerLatLng = [totalH / 2, totalW / 2];
      map.setView(centerLatLng, -2);
    }

    // Context menu + right-click move support
    let __lastContextLatLng = null;
    let __mapContextMenuEl = null;
    let __lastContextAllowed = null;

    function createMapContextMenu() {
      __mapContextMenuEl = document.createElement('div');
      __mapContextMenuEl.id = 'map-contextmenu';
      __mapContextMenuEl.className = 'map-contextmenu';
      __mapContextMenuEl.innerHTML = '<div class="map-contextmenu-item" id="map-walk-here">Walk here</div><div class="map-contextmenu-item" id="map-copy-coords">Copy Coords</div><div class="map-contextmenu-item" id="map-screenshots">Screenshots</div>';
      document.body.appendChild(__mapContextMenuEl);

      __mapContextMenuEl.querySelector('#map-walk-here').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        if (!__lastContextLatLng) return hideMapContextMenu();
        try {
          console.log('ContextMenu: Walk here clicked', __lastContextLatLng);
          // Defensive copy of latlng
          const ll = (typeof L !== 'undefined' && L && L.latLng) ? L.latLng(__lastContextLatLng.lat, __lastContextLatLng.lng) : __lastContextLatLng;
          // Ensure permission check (async) before initiating walk
          try {
            const allowed = await isLatLngWalkAllowedAsync(ll);
            if (!allowed) { try { if (window.addLogMessage) window.addLogMessage('Cannot walk to that region.', 'error'); else alert('Cannot walk to that region.'); } catch(e){ alert('Cannot walk to that region.'); } hideMapContextMenu(); return; }
          } catch (e) { console.error('Walk permission check failed', e); try { if (window.addLogMessage) window.addLogMessage('Cannot walk to that region.', 'error'); else alert('Cannot walk to that region.'); } catch(ex){ alert('Cannot walk to that region.'); } hideMapContextMenu(); return; }

          await performWalkAtLatLng(ll);
        } catch (err) {
          console.error('performWalkAtLatLng failed', err);
        }
        hideMapContextMenu();
      });

      __mapContextMenuEl.querySelector('#map-copy-coords').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        if (!__lastContextLatLng) return hideMapContextMenu();
        const x = Math.round(__lastContextLatLng.lng);
        const y = Math.round(totalH - __lastContextLatLng.lat);
        const text = `[${x}, ${y}]`;
        // try navigator.clipboard, fallback to textarea + execCommand
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
          }
          // small visual feedback: briefly show copied text in the menu without replacing innerHTML
          const temp = document.createElement('div');
          temp.className = 'map-contextmenu-temp';
          temp.style.padding = '8px';
          temp.style.color = '#fff';
          temp.style.pointerEvents = 'none';
          temp.textContent = 'Copied ' + text;
          __mapContextMenuEl.appendChild(temp);
          setTimeout(() => { if (temp.parentNode) temp.parentNode.removeChild(temp); hideMapContextMenu(); }, 700);
        } catch (e) {
          console.error('Copy failed', e);
          hideMapContextMenu();
        }
      });

      // Add Build Path menu item without touching innerHTML to preserve other listeners
      const buildItem = document.createElement('div');
      buildItem.className = 'map-contextmenu-item';
      buildItem.id = 'map-build-path';
      buildItem.textContent = 'Region Editor';
      __mapContextMenuEl.appendChild(buildItem);
      buildItem.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        hideMapContextMenu();
        try { if (window.buildPath && typeof window.buildPath.showPanel === 'function') window.buildPath.showPanel(); } catch (e) { console.error(e); }
      });

      // Add Screenshots menu item
      __mapContextMenuEl.querySelector('#map-screenshots').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        const ll = __lastContextLatLng;
        hideMapContextMenu();
        if (ll && window.screenshotManager && typeof window.screenshotManager.openModal === 'function') {
          const x = Math.round(ll.lng);
          const y = Math.round(totalH - ll.lat);
          window.screenshotManager.openModal(x, y);
        }
      });

      // Hide menu when clicking elsewhere or pressing Escape
      document.addEventListener('click', (ev) => { if (__mapContextMenuEl && !__mapContextMenuEl.contains(ev.target)) hideMapContextMenu(); });
      document.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') hideMapContextMenu(); });
    }

    function showMapContextMenuAt(containerPoint, latlng) {
      if (!__mapContextMenuEl) createMapContextMenu();
      __lastContextLatLng = latlng;
      const rect = map.getContainer().getBoundingClientRect();
      __mapContextMenuEl.style.left = (rect.left + containerPoint.x) + 'px';
      __mapContextMenuEl.style.top = (rect.top + containerPoint.y) + 'px';
      __mapContextMenuEl.style.display = 'block';
      // show/hide Walk Here item depending on whether the location is walkable
      try {
        const walkItem = __mapContextMenuEl.querySelector('#map-walk-here');
        if (walkItem) {
          if (typeof __lastContextAllowed === 'boolean') {
            // permission was precomputed by the contextmenu handler
            walkItem.style.display = __lastContextAllowed ? 'block' : 'none';
            walkItem.title = __lastContextAllowed ? '' : 'Cannot walk to that region';
            __lastContextAllowed = null;
          } else {
            // fallback: hide while checking then async update
            walkItem.style.display = 'none';
            walkItem.title = 'Checking...';
            (async () => {
              try {
                const allowed = await isLatLngWalkAllowedAsync(latlng);
                if (allowed) {
                  walkItem.style.display = 'block';
                  walkItem.title = '';
                } else {
                  walkItem.style.display = 'none';
                  walkItem.title = 'Cannot walk to that region';
                }
              } catch (e) {
                walkItem.style.display = 'none';
                walkItem.title = 'Cannot walk to that region';
              }
            })();
          }
        }
      } catch (e) { /* ignore */ }
    }

    function hideMapContextMenu() {
      if (!__mapContextMenuEl) return;
      __mapContextMenuEl.style.display = 'none';
      __lastContextLatLng = null;
    }

    // Region permission helpers moved to public/regions.js

    // Start walking toward a target; server will compute path and advance via cron.
    async function performWalkAtLatLng(latlng) {
      const x = Math.round(latlng.lng);
      const y = Math.round(totalH - latlng.lat);

      if (x < 0 || x > 6144 || y < 0 || y > 6144) return;

      try {
        console.log('performWalkAtLatLng: requested', {x,y});
        
        // Prevent walking into non-walkable or foreign-owned regions
        try {
          const allowed = await isLatLngWalkAllowedAsync(latlng);
                if (!allowed) { try { if (window.addLogMessage) window.addLogMessage('Cannot walk to that region.', 'error'); else alert('Cannot walk to that region.'); } catch(e){ alert('Cannot walk to that region.'); } return; }
        } catch (e) { console.debug('region check before walk failed', e); try { if (window.addLogMessage) window.addLogMessage('Cannot walk to that region.', 'error'); else alert('Cannot walk to that region.'); } catch(ex){ alert('Cannot walk to that region.'); } return; }

        // Use WebSocket for move request
        const socket = window.getSocket && window.getSocket();
        if (!socket || !socket.connected) {
          alert('WebSocket not connected');
          return;
        }

        socket.emit('move:request', { x, y });

        // The move:started event will be received via WebSocket handler
        // and will set up the destination marker there
        gameState.walkingTarget = { x, y };

      } catch (err) {
        console.error('Failed to start walking:', err);
        window.addLogMessage('Failed to start walking: ' + (err.message || 'Unknown error'), 'error');
      }
    }

    // Load and render paths from API

    // loadAndRenderPaths moved into public/build-path.js

    function enableClickToMove() {
      // Use left-click to start walking; Shift+left-click opens context menu
      map.on('click', async (e) => {
        // If build-path mode is active, let the builder handle the click
        if (gameState.buildPathMode && window.buildPath && typeof window.buildPath.onMapClick === 'function') {
          try { window.buildPath.onMapClick(e); } catch (err) { console.error(err); }
          return;
        }

        // Hide any existing context menu
        hideMapContextMenu();

        // If user holds Shift while left-clicking, show the context menu
        const shiftPressed = !!(e.originalEvent && e.originalEvent.shiftKey);
        if (shiftPressed) {
          try {
            __lastContextAllowed = await isLatLngWalkAllowedAsync(e.latlng);
          } catch (err) { __lastContextAllowed = false; }
          showMapContextMenuAt(e.containerPoint, e.latlng);
          return;
        }

        // Otherwise, attempt to start walking directly to the clicked location
        try {
          const allowed = await isLatLngWalkAllowedAsync(e.latlng);
          if (!allowed) { try { if (window.addLogMessage) window.addLogMessage('Cannot walk to that region.', 'error'); else alert('Cannot walk to that region.'); } catch(e){ alert('Cannot walk to that region.'); } return; }
          await performWalkAtLatLng(e.latlng);
        } catch (err) {
          console.error('Click walk failed', err);
          try { if (window.addLogMessage) window.addLogMessage('Failed to start walking: ' + (err && err.message ? err.message : 'Unknown error'), 'error'); } catch(e){}
        }
      });

      // Hide menu when map viewport changes
      map.on('movestart zoomstart', () => hideMapContextMenu());

      // Right-click (contextmenu) opens the map context menu
      map.on('contextmenu', async (e) => {
        // Prevent the browser default context menu
        if (e.originalEvent && typeof e.originalEvent.preventDefault === 'function') e.originalEvent.preventDefault();
        try {
          __lastContextAllowed = await isLatLngWalkAllowedAsync(e.latlng);
        } catch (err) { __lastContextAllowed = false; }
        showMapContextMenuAt(e.containerPoint, e.latlng);
      });
    }

    

    function updateOtherPlayers(players) {
      // Ensure we don't have an "other player" marker for the current user
      try {
        for (const [uid, marker] of gameState.otherPlayers.entries()) {
          if (String(uid) === String(gameState.userId)) {
            map.removeLayer(marker);
            gameState.otherPlayers.delete(uid);
          }
        }
      } catch (e) {}

      const currentPlayerIds = new Set();

      players.forEach(player => {
        // Normalize player id to string to avoid type-mismatch duplicates
        const pid = String(player.userId);

        // Skip own player
        if (pid === String(gameState.userId)) return;

        currentPlayerIds.add(pid);

        const latLng = [totalH - player.y, player.x];
        const healthPercent = Math.max(0, Math.min(100, Math.round(((Number(player.health) || 0) / (Number(player.maxHealth) || 1)) * 100)));
        // Determine ally vs enemy (same realm = ally). Use case-insensitive compare and treat missing realm as enemy.
        const playerRealm = (player.realm || '').toString().toLowerCase();

        if (gameState.otherPlayers.has(pid)) {
          // Update existing marker - remove and recreate with new health
          const oldMarker = gameState.otherPlayers.get(pid);
          map.removeLayer(oldMarker);

          const customIcon = L.divIcon({
            className: 'custom-player-marker',
            html: `
              <div style="text-align: center;">
                <div style="width: 12px; height: 12px; background: ${getRealmColor(playerRealm)}; border: 2px solid #fff; border-radius: 50%; margin: 0 auto;"></div>
                <div class="territory-health-bar" style="margin-top: 2px;">
                  <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
                </div>
              </div>
            `,
            iconSize: [40, 20],
            iconAnchor: [20, 10]
          });
          
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(`<b>${escapeHtml(player.username)}</b><br>Realm: ${escapeHtml(player.realm)}<br>Health: ${escapeHtml(player.health)}/${escapeHtml(player.maxHealth)}`);
          const playerName = escapeHtml(player.username || 'Unknown');
          const levelHtml = (typeof player.level !== 'undefined') ? `<div class="tooltip-row"><strong>Level:</strong> ${escapeHtml(player.level)}</div>` : '';
          const ttHtml = `
            <div class="tooltip-title">${playerName}</div>
            <div class="tooltip-row"><strong>Realm:</strong> ${escapeHtml(player.realm)}</div>
            <div class="tooltip-row"><strong>HP:</strong> ${escapeHtml(player.health)}/${escapeHtml(player.maxHealth)}</div>
            ${levelHtml}
          `;
          marker.bindTooltip(ttHtml, { permanent: false, direction: 'top', className: 'player-tooltip', offset: [0, -10] });
          gameState.otherPlayers.set(pid, marker);
        } else {
          // Create new marker with health bar
          const customIcon = L.divIcon({
            className: 'custom-player-marker',
            html: `
              <div style="text-align: center;">
                <div style="width: 12px; height: 12px; background: ${getRealmColor(playerRealm)}; border: 2px solid #fff; border-radius: 50%; margin: 0 auto;"></div>
                <div class="territory-health-bar" style="margin-top: 2px;">
                  <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
                </div>
              </div>
            `,
            iconSize: [40, 20],
            iconAnchor: [20, 10]
          });

          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(`<b>${escapeHtml(player.username)}</b><br>Realm: ${escapeHtml(player.realm)}<br>Health: ${escapeHtml(player.health)}/${escapeHtml(player.maxHealth)}`);
          const playerNameNew = escapeHtml(player.username || 'Unknown');
          const levelHtmlNew = (typeof player.level !== 'undefined') ? `<div class="tooltip-row"><strong>Level:</strong> ${escapeHtml(player.level)}</div>` : '';
          const ttHtmlNew = `
            <div class="tooltip-title">${playerNameNew}</div>
            <div class="tooltip-row"><strong>Realm:</strong> ${escapeHtml(player.realm)}</div>
            <div class="tooltip-row"><strong>HP:</strong> ${escapeHtml(player.health)}/${escapeHtml(player.maxHealth)}</div>
            ${levelHtmlNew}
          `;
          marker.bindTooltip(ttHtmlNew, { permanent: false, direction: 'top', className: 'player-tooltip', offset: [0, -10] });
          gameState.otherPlayers.set(pid, marker);
        }
      });

      // Remove markers for players no longer online
      for (const [userId, marker] of gameState.otherPlayers.entries()) {
        if (!currentPlayerIds.has(String(userId))) {
          map.removeLayer(marker);
          gameState.otherPlayers.delete(userId);
        }
      }
    }

    

    function updateTerritories(territories) {
      const currentTerritoryIds = new Set();

      territories.forEach(territory => {
        const territoryId = territory.territoryId;
        const iconName = territory.iconName;
        const iconNameContested = territory.iconNameContested;
        const maxHealth = territory.maxHealth;
        const ownerRealm = territory.ownerRealm;
        
        currentTerritoryIds.add(territoryId);

        const latLng = [totalH - territory.y, territory.x];
        const isContested = territory.contested;
        
        // Prefer server-provided icon URLs; fall back to marker map
        const iconUrl = isContested
          ? (territory.iconUrlContested || (iconNameContested ? `https://cor-forum.de/regnum/RegnumNostalgia/markers/${iconNameContested}` : null))
          : (territory.iconUrl || (iconName ? `https://cor-forum.de/regnum/RegnumNostalgia/markers/${iconName}` : null));

        if (!iconUrl) return;

        if (iconUrl) {
          // Determine health bar color and calculate percentage
          const health = territory.health;
          
          const healthPercent = Math.max(0, Math.min(100, Math.round(((Number(health) || 0) / (Number(maxHealth) || 1)) * 100)));
          
          let healthClass = 'health-high';
          if (healthPercent < 30) {
            healthClass = 'health-low';
          } else if (healthPercent < 70) {
            healthClass = 'health-medium';
          }

          // Get icon URL from the icon object
          // Create custom HTML marker with health bar
          const customIcon = L.divIcon({
            className: 'custom-territory-marker',
            html: `
              <div class="territory-marker">
                <div class="territory-icon" style="background-image: url('${iconUrl}');"></div>
                <div class="territory-health-bar">
                  <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
                </div>
              </div>
            `,
            iconSize: [40, 44],
            iconAnchor: [20, 38]
          });

          if (gameState.territories.has(territoryId)) {
            // Update existing marker - remove and recreate
            const oldMarker = gameState.territories.get(territoryId);
            map.removeLayer(oldMarker);
            
            const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
            const statusText = isContested ? '<div class="status-contested">⚔️ Contested!</div>' : '';
            const ttHtml = `
              <div class="tooltip-title">${territory.name}</div>
              <div class="tooltip-row"><strong>Health:</strong> ${health.toLocaleString()}/${maxHealth.toLocaleString()}</div>
              ${statusText}
            `;
            marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: false, permanent: false, interactive: false, direction: 'top', offset: [0, -40] });
            gameState.territories.set(territoryId, marker);
          } else {
            // Create new marker with custom icon
            const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
            const statusText = isContested ? '<div class="status-contested">⚔️ Contested!</div>' : '';
            const ttHtml = `
              <div class="tooltip-title">${territory.name}</div>
              <div class="tooltip-row"><strong>Health:</strong> ${health.toLocaleString()}/${maxHealth.toLocaleString()}</div>
              ${statusText}
            `;
            marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: false, permanent: false, interactive: false, direction: 'top', offset: [0, -40] });
            gameState.territories.set(territoryId, marker);
          }
        }
      });

      // Remove markers for territories no longer in response (shouldn't happen normally)
      for (const [tId, marker] of gameState.territories.entries()) {
        if (!currentTerritoryIds.has(tId)) {
          map.removeLayer(marker);
          gameState.territories.delete(tId);
        }
      }
    }

    

    function updateSuperbosses(bosses) {
      const currentBossIds = new Set();

      bosses.forEach(boss => {
        const bossId = boss.bossId;
        const iconName = boss.iconName;
        const maxHealth = boss.maxHealth;
        
        currentBossIds.add(bossId);

        const latLng = [totalH - boss.y, boss.x];
        const healthPercent = Math.max(0, Math.min(100, Math.round(((Number(boss.health) || 0) / (Number(maxHealth) || 1)) * 100)));
        
        const iconUrl = boss.iconUrl || (iconName ? `https://cor-forum.de/regnum/RegnumNostalgia/markers/${iconName}` : null);

        if (!iconUrl) return;

        // Create custom HTML marker with health bar
        const customIcon = L.divIcon({
          className: 'custom-territory-marker',
          html: `
            <div class="territory-marker">
              <div class="territory-icon" style="background-image: url('${iconUrl}');"></div>
              <div class="territory-health-bar">
                <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
              </div>
            </div>
          `,
          iconSize: [40, 44],
          iconAnchor: [20, 38]
        });

        if (gameState.superbosses.has(bossId)) {
          // Update existing marker
          const oldMarker = gameState.superbosses.get(bossId);
          map.removeLayer(oldMarker);
          
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          const bossLevel = boss.level || boss.lvl || null;
          // Do not display raw coords in tooltip (clientside). Keep server coords for marker placement only.
          const respawnHtml = (typeof boss.respawnInSeconds === 'number') ? `<div class="tooltip-row"><strong>Respawn:</strong> ${formatDurationSeconds(boss.respawnInSeconds)}</div>` : '';
          const levelHtml = bossLevel ? `<div class="tooltip-row"><strong>Level:</strong> ${bossLevel}</div>` : '';
          const ttHtml = `
            <div class="tooltip-title">${boss.name}</div>
            <div class="tooltip-row"><strong>Health:</strong> ${boss.health.toLocaleString()}/${maxHealth.toLocaleString()}</div>
            ${levelHtml}
            
            ${respawnHtml}
          `;
          marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: false, permanent: false, interactive: false, direction: 'top', offset: [0, -40] });
          gameState.superbosses.set(bossId, marker);
        } else {
          // Create new marker
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          const bossLevel = boss.level || boss.lvl || null;
          const respawnHtml = (typeof boss.respawnInSeconds === 'number') ? `<div class="tooltip-row"><strong>Respawn:</strong> ${formatDurationSeconds(boss.respawnInSeconds)}</div>` : '';
          const levelHtml = bossLevel ? `<div class="tooltip-row"><strong>Level:</strong> ${bossLevel}</div>` : '';
          const ttHtml = `
            <div class="tooltip-title">${boss.name}</div>
            <div class="tooltip-row"><strong>Health:</strong> ${boss.health.toLocaleString()}/${maxHealth.toLocaleString()}</div>
            ${levelHtml}
            ${respawnHtml}
          `;
          marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: false, permanent: false, interactive: false, direction: 'top', offset: [0, -40] });
          gameState.superbosses.set(bossId, marker);
        }
      });

      // Remove markers for bosses no longer alive
      for (const [bossId, marker] of gameState.superbosses.entries()) {
        if (!currentBossIds.has(bossId)) {
          map.removeLayer(marker);
          gameState.superbosses.delete(bossId);
        }
      }
    }

    // Screenshot markers management
    async function loadAndDisplayScreenshots() {
      try {
        const headers = {};
        if (gameState && gameState.sessionToken) {
          headers['X-Session-Token'] = gameState.sessionToken;
        }
        const res = await fetch('/api/screenshots', { 
          method: 'GET', 
          headers, 
          credentials: 'same-origin',
          cache: 'no-store'
        });
        const data = await res.json();
        if (data.success && data.screenshots) {
          displayScreenshotMarkers(data.screenshots);
        }
      } catch (e) {
        console.error('Failed to load screenshots:', e);
      }
    }

    function displayScreenshotMarkers(screenshots) {
      // Initialize screenshots map in gameState if not present
      if (!gameState.screenshots) {
        gameState.screenshots = new Map();
      }

      const currentIds = new Set();

      screenshots.forEach(screenshot => {
        currentIds.add(screenshot.id);
        const latLng = [totalH - screenshot.y, screenshot.x];

        // Create tiny gray transparent dot marker
        const dotIcon = L.divIcon({
          className: 'screenshot-marker',
          html: '<div class="screenshot-dot"></div>',
          iconSize: [8, 8],
          iconAnchor: [4, 4]
        });

        if (gameState.screenshots.has(screenshot.id)) {
          // Update existing marker (remove and recreate)
          const oldMarker = gameState.screenshots.get(screenshot.id);
          map.removeLayer(oldMarker);
        }

        const marker = L.marker(latLng, { icon: dotIcon }).addTo(map);

        // Build tooltip content with screenshot image and details
        const name = screenshot.name?.en || screenshot.name?.de || screenshot.name?.es || 'Unnamed';
        const description = screenshot.description?.en || screenshot.description?.de || screenshot.description?.es || '';
        const location = screenshot.location || '';
        const visibleCharacters = screenshot.visibleCharacters || '';
        
        const tooltipHtml = `
          <div style="max-width: 250px;">
            <div style="margin-bottom: 6px;">
              <img src="${window.screenshotManager.getScreenshotUrl(screenshot.filename)}" style="width: 100%; height: auto; border-radius: 3px; display: block;">
            </div>
            <div style="font-weight: 700; margin-bottom: 4px; font-size: 13px; color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.8);">${name}</div>
            ${location ? `<div style="color: #aaa; font-size: 10px; margin-bottom: 4px; font-weight: 500;">${location}</div>` : ''}
            ${visibleCharacters ? `<div style="color: #60a5fa; font-size: 10px; margin-bottom: 4px; font-weight: 500;">👥 ${visibleCharacters}</div>` : ''}
            ${description ? `<div style="font-size: 10px; line-height: 1.3; color: #ccc;">${description}</div>` : ''}
          </div>
        `;

        marker.bindTooltip(tooltipHtml, { 
          className: 'screenshot-tooltip', 
          direction: 'top', 
          offset: [0, -4]
        });

        gameState.screenshots.set(screenshot.id, marker);
      });

      // Remove markers for deleted screenshots
      for (const [id, marker] of gameState.screenshots.entries()) {
        if (!currentIds.has(id)) {
          map.removeLayer(marker);
          gameState.screenshots.delete(id);
        }
      }
    }

    // Initialize reusable window wiring (drag + close)
    initWindows();

    // Wait for login.html to be loaded before checking auto-login
    function checkAutoLogin() {
      let overlay = document.getElementById('modal-overlay');
      if (!overlay) {
        // Login HTML not loaded yet: try to fetch it on-demand, then retry.
        if (typeof window.loadLoginForm === 'function') {
          window.loadLoginForm().then(() => { setTimeout(checkAutoLogin, 50); }).catch(() => { setTimeout(checkAutoLogin, 250); });
          return;
        }
        // Fallback: wait a bit and retry
        setTimeout(checkAutoLogin, 50);
        return;
      }

      // Auto-login if session token exists
      if (gameState.sessionToken) {
        // Show loading animation
        try {
          const loginForm = document.getElementById('login-form');
          const autoLoginLoading = document.getElementById('auto-login-loading');
          if (loginForm) loginForm.style.display = 'none';
          if (autoLoginLoading) autoLoginLoading.classList.remove('hidden');
          // Fallback: if auto-login stalls, show login form after 5s
          try { if (window.__autoLoginFallback) clearTimeout(window.__autoLoginFallback); } catch (e) {}
          window.__autoLoginFallback = setTimeout(() => {
            try {
              const lf = document.getElementById('login-form');
              const al = document.getElementById('auto-login-loading');
              const ov = document.getElementById('modal-overlay');
              if (lf) lf.style.display = 'block';
              if (al) al.classList.add('hidden');
              if (ov) ov.classList.remove('hidden');
              try { document.getElementById('step-login').classList.add('active'); document.getElementById('step-realm').classList.remove('active'); } catch (e) {}
            } catch (e) {}
          }, 5000);
        } catch (e) {}
        
        setTimeout(() => {
          initGame().then(() => {
            try { if (window.__autoLoginFallback) { clearTimeout(window.__autoLoginFallback); window.__autoLoginFallback = null; } } catch (e) {}
          }).catch((err) => {
            console.debug('[Auto-login] Failed:', err);
            // Auto-login failed. `initGame` already clears token if auth failure.
            try {
              // Hide loading and show login form
              const loginForm = document.getElementById('login-form');
              const autoLoginLoading = document.getElementById('auto-login-loading');
              if (loginForm) loginForm.style.display = 'block';
              if (autoLoginLoading) autoLoginLoading.classList.add('hidden');
              try { if (window.__autoLoginFallback) { clearTimeout(window.__autoLoginFallback); window.__autoLoginFallback = null; } } catch (e) {}
              document.body.classList.remove('authenticated');
              const overlay = document.getElementById('modal-overlay'); 
              if (overlay) { 
                overlay.classList.remove('hidden');
              }
              try { 
                document.getElementById('step-login').classList.add('active'); 
                document.getElementById('step-realm').classList.remove('active'); 
              } catch (e) {}
            } catch (e) {
              console.error('[Auto-login] Error showing login form:', e);
            }
          });
        }, 500);
      } else {
        // Ensure modal is visible and login screen is active
        try {
          const overlay = document.getElementById('modal-overlay');
          if (overlay) overlay.classList.remove('hidden');
          document.getElementById('step-login').classList.add('active');
          document.getElementById('step-realm').classList.remove('active');
        } catch (e) {}
      }
    }

    // Start checking for auto-login
    checkAutoLogin();
  </script>

  <script>
    (function(){
      const ICON = document.getElementById('server-time-icon');
      const TOOLTIP = document.getElementById('server-time-tooltip');

      function getDaytimeLabel(h){
        const hour = Number(h) || 0;
        if(hour === 5) return 'Dawn';
        if(hour >= 6 && hour <= 8) return 'Morning';
        if(hour >= 9 && hour <= 11) return 'Day';
        if(hour >= 12 && hour <= 16) return 'Afternoon';
        if(hour === 17) return 'Sunset';
        if(hour === 18) return 'Dusk';
        if(hour >= 19 && hour <= 20) return 'Nightfall';
        return 'Night';
      }

      // Expose a global helper so other modules can update the server time UI
      window.updateServerTimeUI = function(data){
        try {
          if (!data) return;
          // data may be a full /player/position response or a simple serverTime object
          const st = data.serverTime || data;
          const hour = Number(st && st.ingameHour) || 0;
          const minute = Number(st && st.ingameMinute) || 0;

          // prefer daytimeIcon from position API, fall back to icon
          if (data.daytimeIcon) ICON.src = data.daytimeIcon;
          else if (data.icon) ICON.src = data.icon;

          const hh = String(hour).padStart(2, '0');
          const mm = String(minute).padStart(2, '0');
          const label = getDaytimeLabel(hour);
          TOOLTIP.textContent = `${hh}:${mm} — ${label}`;
          TOOLTIP.setAttribute('aria-hidden', 'false');
        } catch (e) { console.warn('updateServerTimeUI failed', e); }
      };

      async function fetchServerTime(){
        try{
          const headers = {};
          if (typeof gameState !== 'undefined' && gameState && gameState.sessionToken) {
            headers['X-Session-Token'] = gameState.sessionToken;
          }
          // WebSocket-only: request server time/player state via socket
          if (window.socket && socket && socket.connected) {
            socket.emit('player:stats:get', (resp) => {
              if (resp && resp.success && resp.state) {
                if (window.updateServerTimeUI) window.updateServerTimeUI(resp.state);
              }
            });
          } else {
            console.warn('WebSocket not connected — skipping server time fetch');
          }
        }catch(e){ console.warn('Failed to fetch server time', e); }
      }

      // Initial fetch (position API will refresh server time)
      fetchServerTime();
    })();
  </script>
  <script src="build-path.js"></script>
  <style>
    .info-tooltip { background: rgba(20,20,24,0.95); color: #fff; border-radius:6px; padding:8px; font-size:13px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
    .info-tooltip .tooltip-title { font-weight:700; margin-bottom:6px; font-size:14px }
    .info-tooltip .tooltip-row { margin-bottom:4px }
    .info-tooltip .status-contested { color:#ffb4b4; font-weight:700 }
    /* UI image overlay (bottom-right) */
    #ui-image-overlay{
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 73px; /* scaled up ~30% */
      z-index: 20000;
      pointer-events: none;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
    }
    #ui-image-overlay .ui-bar-repeat{
      flex: 1 1 auto;
      height: 73px;
      background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-bottom-bar-left.png');
      background-repeat: repeat-x;
      background-position: left top;
      background-size: auto 100%;
    }
    #ui-image-overlay .ui-bar-repeat-right{
      flex: 1 1 auto;
      height: 73px;
      background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-bottom-bar-left.png');
      background-repeat: repeat-x;
      background-position: right top;
      background-size: auto 100%;
      transform: scaleX(-1);
      pointer-events: none;
    }
    #ui-image-overlay .ui-bar-right{ flex: 0 0 auto; position: relative; }
    #ui-image-overlay .ui-bar-right img{ height: 73px; display:block; pointer-events: none; }
    /* Anchor HUD buttons to the right image container so they follow it on resize */
    #ui-image-overlay .ui-hud-group{
      position: absolute;
      right: 0;
      bottom: 0;
      left: 0;
      top: 0;
      pointer-events: none;
    }
    /* Place each HUD button absolutely so existing per-button `right:` rules apply */
    #ui-image-overlay .ui-hud-group .ui-hud-btn{
      position: absolute;
      bottom: 4px;
      width: 38px;
      height: 38px;
      pointer-events: auto;
    }
    /* Top-right compass image (now interactive) */
    #ui-compass{ position: fixed; top: 0; right: 0; z-index: 20001; pointer-events: auto; }
    #ui-compass img{ height: 166px; display:block; }

    /* Active spells display (to the left of compass) */
    #active-spells-container{ position: fixed; top: 8px; right: 176px; z-index: 20001; display: flex; flex-direction: row; gap: 6px; pointer-events: auto; }
    .active-spell{ position: relative; width: 40px; height: 40px; border: 2px solid rgba(255,210,122,0.6); border-radius: 6px; background: rgba(0,0,0,0.55); overflow: visible; cursor: default; }
    .active-spell img{ width: 100%; height: 100%; display: block; border-radius: 4px; }
    .active-spell .spell-timer{ position: absolute; bottom: 0; left: 0; right: 0; text-align: center; font-size: 10px; font-weight: 700; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.9); background: linear-gradient(transparent, rgba(0,0,0,0.7)); padding: 1px 0; line-height: 1; }
    .active-spell .spell-cooldown-overlay{ position: absolute; top: 0; left: 0; right: 0; background: rgba(0,0,0,0.45); pointer-events: none; transition: height 1s linear; border-radius: 4px 4px 0 0; }
    .active-spell .spell-tooltip{ display: none; position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%); background: rgba(10,12,15,0.95); color: #e6e6e6; padding: 3px 8px; border-radius: 4px; font-size: 11px; white-space: nowrap; z-index: 20005; pointer-events: none; }
    .active-spell:hover .spell-tooltip{ display: block; }
    .item-cd-overlay{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.55); display: flex; align-items: center; justify-content: center; pointer-events: none; border-radius: 3px; }
    .item-cd-timer{ font-size: 10px; font-weight: 700; color: #ff9e9e; text-shadow: 0 1px 2px rgba(0,0,0,0.9); }

    /* Quickbar */
    #quickbar{ position: fixed; bottom: 6px; left: 50%; transform: translateX(calc(-50% - 20px)); z-index: 20001; display: flex; align-items: center; gap: 4px; pointer-events: auto; }
    #quickbar-row-indicator{ width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; background: rgba(10,12,15,0.85); border: 1px solid rgba(255,210,122,0.45); border-radius: 4px; color: #ffd27a; font-size: 12px; font-weight: 700; cursor: default; user-select: none; }
    #quickbar-slots{ display: flex; gap: 2px; }
    .quickbar-slot{ position: relative; width: 40px; height: 40px; background: rgba(10,12,15,0.7); border: 1px solid rgba(255,210,122,0.3); border-radius: 4px; cursor: pointer; overflow: hidden; display: flex; align-items: center; justify-content: center; user-select: none; transition: border-color 0.15s; }
    .quickbar-slot:hover{ border-color: rgba(255,210,122,0.7); }
    .quickbar-slot.drag-over{ border-color: #ffd27a; background: rgba(255,210,122,0.15); }
    .quickbar-slot.filled{ background: rgba(20,25,35,0.85); }
    .quickbar-slot img{ width: 34px; height: 34px; display: block; image-rendering: auto; pointer-events: none; border-radius: 3px; }
    .quickbar-slot-key{ position: absolute; top: 1px; left: 3px; font-size: 9px; font-weight: 600; color: rgba(255,255,255,0.35); z-index: 2; pointer-events: none; user-select: none; line-height: 1; }
    .quickbar-cd-overlay{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.55); display: flex; align-items: center; justify-content: center; pointer-events: none; border-radius: 3px; }
    .quickbar-cd-timer{ font-size: 10px; font-weight: 700; color: #ff9e9e; text-shadow: 0 1px 2px rgba(0,0,0,0.9); }

    /* Cast bar (bottom-center during spell casting) */
    #cast-bar{ display: none; position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%); z-index: 20010; width: 260px; background: rgba(10,12,15,0.92); border: 1px solid rgba(255,210,122,0.4); border-radius: 6px; padding: 6px 10px; pointer-events: none; box-shadow: 0 4px 16px rgba(0,0,0,0.6); }
    #cast-bar.visible{ display: block; }
    #cast-bar-label{ font-size: 11px; color: #ffd27a; margin-bottom: 4px; text-align: center; font-weight: 600; }
    #cast-bar-track{ width: 100%; height: 10px; background: rgba(255,255,255,0.08); border-radius: 4px; overflow: hidden; }
    #cast-bar-fill{ height: 100%; width: 0%; background: linear-gradient(90deg, #f59e0b, #fbbf24); border-radius: 4px; }
    #cast-bar-time{ font-size: 10px; color: #aaa; text-align: center; margin-top: 3px; }

    /* Compass controls (map settings + logout) */
    #ui-compass .compass-controls{ position: absolute; top: 36px; right: 12px; display: flex; flex-direction: column; gap: 6px; pointer-events: auto; z-index: 20002; }
    #ui-compass .compass-controls .btn-logout{ font-size: 11px; padding: 6px 8px; background: linear-gradient(180deg, #2b6cb0, #1e40af); border: 1px solid rgba(0,0,0,0.4); color: #fff; border-radius: 4px; cursor: pointer; }
    #ui-compass .compass-controls .btn-logout:hover{ filter: brightness(1.05); }

    /* Server time icon overlay (placed above compass) */
    #ui-server-time{ position: fixed; top: 0px; right: 2px; z-index: 20003; pointer-events: auto; width:29px; height:29px; display:flex; align-items:center; justify-content:center; }
    #ui-server-time img{ width:26px; height:26px; display:block; image-rendering: pixelated; cursor:default; }
    .server-time-tooltip{ position: absolute; top: 38px; right: 0; display: none; background: linear-gradient(180deg, rgba(20,22,26,0.98), rgba(10,12,15,0.98)); color: #e6e6e6; padding: 4px 6px; border-radius: 6px; font-size: 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); white-space: nowrap; pointer-events: none; z-index: 20004; }
    #ui-server-time:hover .server-time-tooltip{ display: block; }

    /* Top-left character status (overlay) */
    /* Allow hover on the character overlay so its health/mana bars can be revealed on hover. */
    #ui-character-status{ position: fixed; top: 0; left: 0; z-index: 20001; pointer-events: auto; }
    #ui-character-status img{ height: 86px; width: auto; display:block; }
    #ui-character-status .ui-character-overlay{ position: absolute; top: 4px; left: 6px; right: 6px; bottom: 4px; display:flex; flex-direction:column; justify-content:flex-start; align-items:center; gap:4px; box-sizing:border-box; pointer-events: none; z-index:20002; transform: translate(-6px, -2px); }
    #ui-character-status .ui-character-overlay .status-top{ position:absolute; top:2px; left:4px; display:flex; align-items:center; gap:6px; z-index:20003; }
    #ui-character-status .ui-character-overlay .status-name{ margin-top:6px; padding-top:0; font-size:13px; color:#ffffff; font-weight:600; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; text-align:center; align-self:center; max-width:160px; text-shadow:0 1px 0 rgba(0,0,0,0.8); transform: translateX(-20px); }
    #ui-character-status .ui-character-overlay .status-bars{ display:flex; flex-direction:column; gap:1px; transform: translateX(-15px) translateY(7px); }
    /* Add padding to the level number so it sits away from top/left edges */
    #ui-character-status .ui-character-overlay .status-top #player-level{ padding-top:8px; padding-left:12px; }
    /* Username visibility */
    #ui-character-status .ui-character-overlay .status-top #player-username{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:inline-block; max-width:120px; font-weight:600; text-shadow:0 1px 0 rgba(0,0,0,0.8); color:#fff; }
    /* Use UI bar images for overlay health/mana fills and stretch them horizontally */
    #ui-character-status .ui-character-overlay .territory-health-bar{ background: transparent; border: none; }
    #ui-character-status .ui-character-overlay .territory-health-bar .territory-health-fill{ background-color: transparent; }
    /* Use border-image 9-slice style like window title/body so caps are preserved and center repeats */
    #ui-character-status .ui-character-overlay #player-health-fill{
      background-color: transparent;
      height:100%;
      border-width: 0 2px 0 2px;
      border-style: solid;
      border-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-bar-health.png') 0 2 0 2 fill / 0 2px 0 2px / 0 stretch;
      box-sizing: border-box;
    }
    #ui-character-status .ui-character-overlay #player-mana-fill{
      background-color: transparent;
      height:100%;
      border-width: 0 2px 0 2px;
      border-style: solid;
      border-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-bar-mana.png') 0 2 0 2 fill / 0 2px 0 2px / 0 stretch;
      box-sizing: border-box;
    }
    /* Nudge health/mana fills vertically: health down 1px, mana up 2px */
    #ui-character-status .ui-character-overlay #player-health-fill{ position: relative; top: -3px; }
    #ui-character-status .ui-character-overlay #player-mana-fill{ position: relative; top: -1px; }
    /* Overlay-specific bar sizing: less wide, taller */
    #ui-character-status .ui-character-overlay .overlay-bar{ flex: 0 0 auto; width: 218px; height: 15px; border-radius: 4px; overflow: hidden; }
    /* Ensure the top-left character overlay bars are always visible and interactive. */
    #ui-character-status .ui-character-overlay .overlay-bar { opacity: 1 !important; pointer-events: auto !important; }
    /* Center bar text on top of the bar */
    #ui-character-status .ui-character-overlay .overlay-bar{ position: relative; }
    #ui-character-status .ui-character-overlay .bar-text{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size:11px; color:#ffffff; text-shadow:0 1px 0 rgba(0,0,0,0.8); pointer-events: none; }
    /* hide small realm badge in the compact overlay (was showing as a green dot) */
    #ui-character-status .ui-character-overlay .status-top .realm-badge{ display:none; }

    /* Unified HUD button styles */
    .ui-hud-btn{
      position: absolute;
      bottom: 4px;
      width: 38px;
      height: 38px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center center;
      border: none;
      padding: 0;
      margin: 0;
      cursor: pointer;
      pointer-events: auto; /* allow clicks */
      z-index: 20002;
      background-color: transparent;
    }
    .ui-hud-btn[data-action="spellbook"]{ right: 303px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-spellbook-base.png'); }
    .ui-hud-btn[data-action="spellbook"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-spellbook-hover.png'); }
    .ui-hud-btn[data-action="spellbook"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-spellbook-pressed.png'); }

    .ui-hud-btn[data-action="character"]{ right: 251px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-character-base.png'); }
    .ui-hud-btn[data-action="character"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-character-hover.png'); }
    .ui-hud-btn[data-action="character"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-character-pressed.png'); }

    .ui-hud-btn[data-action="inventory"]{ right: 207px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-inventory-base.png'); }
    .ui-hud-btn[data-action="inventory"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-inventory-hover.png'); }
    .ui-hud-btn[data-action="inventory"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-inventory-pressed.png'); }

    /* Persisted pressed state (ensure correct ui asset path used) */
    .ui-hud-btn.pressed[data-action="inventory"]{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-inventory-pressed.png'); }
    .ui-hud-btn.pressed[data-action="character"]{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-character-pressed.png'); }

    .ui-hud-btn[data-action="actions"]{ right: 164px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-actions-base.png'); }
    .ui-hud-btn[data-action="actions"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-actions-hover.png'); }
    .ui-hud-btn[data-action="actions"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-actions-pressed.png'); }

    .ui-hud-btn[data-action="party"]{ right: 123px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-party-base.png'); }
    .ui-hud-btn[data-action="party"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-party-hover.png'); }
    .ui-hud-btn[data-action="party"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-party-pressed.png'); }

    .ui-hud-btn[data-action="quests"]{ right: 78px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-quests-base.png'); }
    .ui-hud-btn[data-action="quests"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-quests-hover.png'); }
    .ui-hud-btn[data-action="quests"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-quests-pressed.png'); }

    .ui-hud-btn[data-action="premium"]{ right: 34px; background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-premium-base.png'); }
    .ui-hud-btn[data-action="premium"]:hover{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-premium-hover.png'); }
    .ui-hud-btn[data-action="premium"]:active{ background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-icon-premium-pressed.png'); }

    /* 9-slice window styling (title bar + body) */
    .ui-window{
      /* No backgrounds - pure image-based */
    }
    .ui-window-titlebar{
      height: 16px;
      padding: 0 4px;
      position: relative;
      z-index: 1;
      /* 9-slice: repeat center 10px strip horizontally (128px - 59px - 59px = 10px) */
      border-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-window-title-bar.png') 0 59 0 59 fill / 0 59px 0 59px / 0 repeat;
    }
    .ui-window-body{
      margin-top: -16px;
      padding-top: 16px;
      /* 9-slice: repeat center 10px horizontally, 1px vertically (128px - 49px - 78px = 1px), moved 10px up */
      border-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-window-main.png') 49 59 78 59 fill / 49px 59px 78px 59px / 0 repeat repeat;
      background: rgba(0,0,0,0.3);
    }
    .ui-window-close-btn{
      width: 16px;
      height: 16px;
      padding: 0;
      border: none;
      cursor: pointer;
      background: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-window-close-base.png') center center no-repeat;
      background-size: 16px 16px;
      flex-shrink: 0;
    }
    .ui-window-close-btn:hover{
      background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-window-close-hover.png');
    }
    .ui-window-close-btn:active{
      background-image: url('https://cor-forum.de/regnum/RegnumNostalgia/ui/ui-window-close-pressed.png');
    }
  </style>
  
  <!-- Shoutbox (loaded from separate file with its JS) -->
  <div id="shoutbox-include"></div>
  <script>
    (function(){
      fetch('shoutbox.html').then(r => r.text()).then(html => {
        const container = document.getElementById('shoutbox-include');
        if (!container) return;
        const tmp = document.createElement('div');
        tmp.innerHTML = html;

        // Move non-script nodes into the container
        Array.from(tmp.childNodes).forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'script') return;
          container.appendChild(node);
        });

        // Execute inline scripts and load external scripts
        const scripts = tmp.querySelectorAll('script');
        scripts.forEach(s => {
          const ns = document.createElement('script');
          if (s.src) ns.src = s.src;
          else ns.textContent = s.textContent;
          document.body.appendChild(ns);
        });

        // Initialize shoutbox window after it's loaded
        try {
          const shoutboxWin = document.getElementById('shoutbox-window');
          if (shoutboxWin && typeof getWindowState === 'function' && typeof saveWindowState === 'function') {
            const shoutboxState = getWindowState('shoutbox-window');
            if (!shoutboxState || typeof shoutboxState.open === 'undefined') {
              // Default to open on first load
              saveWindowState('shoutbox-window', { open: true, display: 'flex' });
              shoutboxWin.style.display = 'flex';
            }
          }
          if (typeof initWindow === 'function') {
            initWindow({ id: 'shoutbox-window', headerId: 'shoutbox-header', closeId: 'shoutbox-close-btn' });
          }
        } catch (e) {
          console.error('Failed to initialize shoutbox window:', e);
        }
      }).catch(err => console.error('Failed to load shoutbox:', err));
    })();
  </script>

</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Regnum Nostalgia - Old World Interactive Map & Browser Game</title>

  <!-- Basic metadata -->
  <meta name="description" content="Experience Regnum Online's Old World in this nostalgic browser-based RPG. Explore the classic map, battle monsters, complete quests, and relive the golden age of Champions of Regnum.">
  <meta name="keywords" content="Regnum Nostalgia, Regnum Online, Champions of Regnum, Old World, browser game, RPG, MMORPG, interactive map, retro game, nostalgia, fantasy RPG, online game">
  <meta name="author" content="Joshua Treudler">
  <meta name="robots" content="index,follow">
  <meta name="theme-color" content="#8b4513">

  <!-- Social preview -->
  <meta property="og:title" content="Regnum Nostalgia - Relive the Old World">
  <meta property="og:description" content="Experience the classic Regnum Online Old World in this nostalgic browser-based RPG. Explore, battle, and quest in the legendary realm of Champions of Regnum.">
  <meta property="og:type" content="game">
  <meta property="og:image" content="assets/preview.png">
  <meta property="og:url" content="">
  <meta property="og:site_name" content="Regnum Nostalgia">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Regnum Nostalgia - Relive the Old World">
  <meta name="twitter:description" content="Experience the classic Regnum Online Old World in this nostalgic browser-based RPG.">
  <meta name="twitter:image" content="assets/preview.png">

  <link rel="icon" href="assets/favicon.png" sizes="32x32">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    /* Prevent the page from scrolling; map handles panning */
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
    /* Map fills the viewport */
    #map { width: 100vw; height: 100vh; margin: 0; padding: 0; background: url('assets/background.jpg') center center / cover no-repeat; }
      #coords {
        .ui-hud-btn{
          width: 39px;
          height: 39px;
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center center;
          border: none;
          padding: 0;
          margin: 0;
          cursor: pointer;
          pointer-events: auto; /* allow clicks */
          z-index: 20002;
          background-color: transparent;
          flex: 0 0 auto;
        }

        /* HUD group layout */
        .ui-bar-right{ position: relative; }
        .ui-hud-group{ position: absolute; right: 12px; bottom: 8px; display:flex; gap:8px; align-items:flex-end; pointer-events: auto; }

        /* per-action icons (base/hover/pressed) */
        .ui-hud-btn[data-action="inventory"]{ background-image: url('assets/ui-v1/hud/ui-icon-inventory-base.png'); }
        .ui-hud-btn[data-action="inventory"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-inventory-hover.png'); }
        .ui-hud-btn[data-action="inventory"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-inventory-pressed.png'); }

        .ui-hud-btn[data-action="character"]{ background-image: url('assets/ui-v1/hud/ui-icon-character-base.png'); }
        .ui-hud-btn[data-action="character"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-character-hover.png'); }
        .ui-hud-btn[data-action="character"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-character-pressed.png'); }

        .ui-hud-btn[data-action="actions"]{ background-image: url('assets/ui-v1/hud/ui-icon-actions-base.png'); }
        .ui-hud-btn[data-action="actions"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-actions-hover.png'); }
        .ui-hud-btn[data-action="actions"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-actions-pressed.png'); }

        .ui-hud-btn[data-action="party"]{ background-image: url('assets/ui-v1/hud/ui-icon-party-base.png'); }
        .ui-hud-btn[data-action="party"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-party-hover.png'); }
        .ui-hud-btn[data-action="party"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-party-pressed.png'); }

        .ui-hud-btn[data-action="premium"]{ background-image: url('assets/ui-v1/hud/ui-icon-premium-base.png'); }
        .ui-hud-btn[data-action="premium"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-premium-hover.png'); }
        .ui-hud-btn[data-action="premium"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-premium-pressed.png'); }

        .ui-hud-btn[data-action="quests"]{ background-image: url('assets/ui-v1/hud/ui-icon-quests-base.png'); }
        .ui-hud-btn[data-action="quests"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-quests-hover.png'); }
        .ui-hud-btn[data-action="quests"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-quests-pressed.png'); }

        .ui-hud-btn[data-action="spellbook"]{ background-image: url('assets/ui-v1/hud/ui-icon-spellbook-base.png'); }
        .ui-hud-btn[data-action="spellbook"]:hover{ background-image: url('assets/ui-v1/hud/ui-icon-spellbook-hover.png'); }
        .ui-hud-btn[data-action="spellbook"]:active{ background-image: url('assets/ui-v1/hud/ui-icon-spellbook-pressed.png'); }
      z-index: 1100;
      display: flex;
      gap: 8px;
      align-items: center;
      pointer-events: auto;
    }
    #header-actions .btn-logout{
      pointer-events: auto;
    }

    /* Login/Realm Modal Styles */
    #modal-overlay{
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    #modal-overlay.hidden{ display: none; }

    /* Hide all UI elements until the user is authenticated. Keep the modal overlay and background map visible. */
    body:not(.authenticated) > :not(#modal-overlay):not(#map):not(script):not(style) {
      display: none !important;
    }

    .modal-content{
      background: transparent;
      border: none;
      padding: 0;
      max-width: 252px;
      width: 90%;
      position: relative;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }
    .modal-content::before{
      display: none;
    }

    .modal-step{ display: none; }
    .modal-step.active{ display: block; }
    /* Map context menu (right-click) */
    .map-contextmenu{
      position: absolute;
      background: #1f2937;
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      font-size: 13px;
      z-index: 20000;
      display: none;
      min-width: 96px;
      pointer-events: auto;
    }
    .map-contextmenu .map-contextmenu-item{
      padding: 6px 10px;
      cursor: pointer;
      border-radius: 4px;
    }
    .map-contextmenu .map-contextmenu-item:hover{ background: rgba(255,255,255,0.04) }

    .modal-title{
      /* Now using ui-window-titlebar styling */
    }

    .modal-body{
      /* Now using ui-window-body styling with 9-slice border-image */
      padding-left: 16px;
      padding-right: 16px;
      padding-bottom: 16px;
    }

    .form-group{
      margin-bottom: 14px;
    }

    .form-label{
      display: block;
      color: #e0e0e0;
      font-size: 11px;
      margin-bottom: 4px;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }

    .form-input{
      width: 100%;
      padding: 3px 8px;
      border: 1px solid #444;
      background: #2a2a2a;
      color: #e0e0e0;
      font-size: 11px;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      box-sizing: border-box;
      transition: none;
    }
    .form-input:focus{
      outline: 1px solid #0d6efd;
      outline-offset: 0;
      border-color: #0d6efd;
    }

    .btn{
      width: 100%;
      padding: 4px 12px;
      border: 1px solid #444;
      font-size: 11px;
      font-weight: 400;
      cursor: pointer;
      transition: background 0.2s;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .btn-primary{
      background: #4a4a4a;
      color: #ffffff;
      border-color: #4a4a4a;
    }
    .btn-primary:hover{ background: #5a5a5a; }
    .btn-primary:active{
      background: #3a3a3a;
    }
    .btn-primary:disabled{
      background: #2a2a2a;
      color: #666;
      cursor: not-allowed;
      border-color: #333;
    }

    .realm-cards{
      display: flex;
      flex-direction: row;
      gap: 8px;
      margin-top: 12px;
    }

    .realm-card{
      padding: 8px;
      border: 1px solid #444;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      background: #2a2a2a;
      color: #e0e0e0;
      flex: 1;
      text-align: center;
    }
    .realm-card:hover{
      background: #333;
      border-color: #555;
    }
    .realm-card:active{
      background: #1a1a1a;
    }

    .realm-card.syrtis{
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .realm-card.alsius{
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .realm-card.ignis{
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .realm-icon{
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
    }
    .realm-icon img{
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .realm-info h3{
      margin: 0 0 2px 0;
      font-size: 11px;
      font-weight: 700;
    }
    .realm-info p{
      margin: 0;
      font-size: 11px;
      opacity: 1;
    }

    .error-message{
      background: #3a1a1a;
      color: #ff6b6b;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 11px;
      border: 1px solid #661a1a;
    }
    .error-message.hidden{ display: none; }

    .loading-spinner{
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin{
      to{ transform: rotate(360deg); }
    }



    .realm-badge{
      display: inline-block;
      width: 10px;
      height: 10px;
    }
    .realm-badge.syrtis{ background: #008000; }
    .realm-badge.alsius{ background: #0000ff; }
    .realm-badge.ignis{ background: #ff0000; }

    .player-info-body{
      padding: 8px;
      background: transparent;
    }

    .player-coords{
      font-size: 11px;
      color: #e0e0e0;
      margin-bottom: 8px;
    }

    .btn-logout{
      padding: 4px 8px;
      background: #2a2a2a;
      color: #e0e0e0;
      border: 1px solid #444;
      cursor: pointer;
      font-size: 11px;
      width: 100%;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      transition: background 0.2s;
      text-shadow: none;
      box-shadow: none;
      margin-bottom: 4px;
    }
    .btn-logout:hover{ 
      background: #333;
    }
    .btn-logout:active{
      background: #1a1a1a;
    }

    /* Territory Health Bar Styles */
    .territory-marker{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .territory-icon{
      width: 32px;
      height: 32px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    .territory-health-bar{
      width: 40px;
      height: 4px;
      background: rgba(0,0,0,0.5);
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .territory-health-fill{
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    /* Allies (same realm / self) */
    .health-ally{ background-color: #22c55e; }
    /* Enemies (other realms) */
    .health-enemy{ background-color: #ef4444; }
    /* Status-based helpers (kept for compatibility) */
    .health-medium{ background-color: #eab308; }
    .health-low{ background-color: #ef4444; }

    /* Inventory Grid Styles */
    .inventory-grid{
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border: 2px solid #1a2538;
      border-radius: 3px;
    }

    /* Inventory window sizing */
    #inventory-window{
      max-height: 600px;
    }
    #inventory-list{
      overflow-y: auto;
      flex: 1 1 auto;
      min-height: 0;
    }

    /* Equipment Slot Styles */
    .equipment-area{ padding: 8px; border: 2px solid #1a2538; border-radius: 3px; margin-bottom: 8px; background: transparent;}    
    .equipment-row{ display:flex; gap:6px; justify-content: flex-start; margin-bottom:6px; }
    .equipment-slot{ width:44px; height:44px; background: transparent; border: 2px solid #2a3f5f; border-radius: 4px; display:flex; align-items:center; justify-content:center; position:relative; cursor:pointer; background-size: contain; background-position: center; background-repeat: no-repeat; }
    .equipment-slot.empty{ opacity:0.45; }
    .equipment-slot .slot-icon{ font-size:22px; }
    .equipment-slot .slot-rarity-border{ inset: -2px; border-radius:4px; }
    .equipment-slot.drag-over{ outline: 2px dashed #0d6efd; }
    
    /* Equipment slot background icons */
    .equipment-slot[data-slot="head"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-head.png'); }
    .equipment-slot[data-slot="body"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-torso.png'); }
    .equipment-slot[data-slot="hands"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-arms.png'); }
    .equipment-slot[data-slot="shoulders"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-pauldron.png'); }
    .equipment-slot[data-slot="legs"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-legs.png'); }
    .equipment-slot[data-slot="weapon_right"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-hand-right.png'); }
    .equipment-slot[data-slot="weapon_left"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-hand-left.png'); }
    .equipment-slot[data-slot="ring_right"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-rings.png'); }
    .equipment-slot[data-slot="ring_left"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-rings.png'); }
    .equipment-slot[data-slot="amulet"].empty{ background-image: url('assets/ui-v1/ui-equip-slot-amulet.png'); }

    /* Character window (classic layout) */
    .char-section{ border: 1px solid rgba(255,255,255,0.08); background: rgba(0,0,0,0.25); }
    .char-section + .char-section{ margin-top: 4px; }
    .char-section-title{
      padding: 4px 6px;
      font-size: 11px;
      font-weight: 700;
      text-align: center;
      color: #e0e0e0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.35);
    }
    .char-section-body{ padding: 6px; font-size: 12px; color: #e0e0e0; }
    .char-line{ margin: 2px 0; }
    .char-xp-bar{ height: 8px; border: 1px solid rgba(255,255,255,0.25); background: rgba(0,0,0,0.4); margin: 6px 0; }
    #char-xp-fill{ height: 100%; width: 0%; background: linear-gradient(90deg,#2dd4bf,#60a5fa); }
    .char-attr-row{ display:flex; justify-content:space-between; gap: 8px; margin: 2px 0; }
    .char-attr-name{ flex: 1; color: #ffffff; }
    .char-attr-name.char-attr-good,
    .char-attr-name.char-attr-bad{ color: #ffffff; }
    .char-attr-value{ min-width: 40px; text-align: right; }
    .char-attr-good{ color: #22c55e; }
    .char-attr-bad{ color: #ef4444; }
    .char-stat-row{ display:flex; justify-content:space-between; gap: 8px; margin: 2px 0; }
    .char-status{ display:flex; justify-content:space-between; color: #ef4444; font-weight: 700; }

    /* Visual for items that cannot be equipped into any slot */
    .not-equippable{ opacity: 0.6; filter: grayscale(80%); }

    /* Brief invalid equip animation (flash) */
    .invalid-equip{ animation: invalidFlash 0.35s ease-in-out; }
    @keyframes invalidFlash{ 0%{ box-shadow: 0 0 0 rgba(255,0,0,0); } 50%{ box-shadow: 0 0 8px rgba(255,0,0,0.8); } 100%{ box-shadow: 0 0 0 rgba(255,0,0,0); } }

    .inventory-slot{
      aspect-ratio: 1;
      background: transparent;
      border: 2px solid #2a3f5f;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.15s;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    }
    .inventory-slot:hover{
      border-color: #4a6f9f;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(74,111,159,0.4);
    }
    .inventory-slot.empty{
      opacity: 0.5;
    }

    .slot-icon{
      font-size: 32px;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.7));
    }

    .slot-quantity{
      position: absolute;
      bottom: 2px;
      right: 4px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      padding: 1px 4px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .slot-rarity-border{
      position: absolute;
      inset: -2px;
      border-radius: 3px;
      pointer-events: none;
    }
    .slot-rarity-border.common{ border: 2px solid #6b7280; }
    .slot-rarity-border.uncommon{ border: 2px solid #22c55e; box-shadow: 0 0 6px rgba(34,197,94,0.3); }
    .slot-rarity-border.rare{ border: 2px solid #3b82f6; box-shadow: 0 0 6px rgba(59,130,246,0.3); }
    .slot-rarity-border.epic{ border: 2px solid #a855f7; box-shadow: 0 0 6px rgba(168,85,247,0.3); }

    .item-tooltip{
      position: fixed;
      background: #ffffe1;
      border: 1px solid #000000;
      padding: 4px 6px;
      color: #000000;
      font-size: 11px;
      z-index: 10001;
      pointer-events: none;
      box-shadow: 1px 1px 0 rgba(0,0,0,0.5);
      max-width: 200px;
      line-height: 1.3;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }
    .item-tooltip .tooltip-name{
      font-weight: 700;
      font-size: 11px;
      margin-bottom: 2px;
      color: #000000;
    }
    .item-tooltip .tooltip-type{
      font-size: 9px;
      color: #000000;
      margin-bottom: 3px;
      text-transform: capitalize;
    }
    .item-tooltip .tooltip-description{
      color: #000000;
      font-size: 9px;
      margin-bottom: 3px;
      font-style: normal;
    }
    .item-tooltip .tooltip-stats{
      font-size: 9px;
      color: #000000;
      border-top: 1px solid #808080;
      padding-top: 3px;
      margin-top: 3px;
    }
    .item-tooltip .tooltip-rarity{
      font-size: 9px;
      text-transform: uppercase;
      font-weight: 400;
      margin-top: 2px;
      color: #000000;
    }
    .item-tooltip .tooltip-rarity.common,
    .item-tooltip .tooltip-rarity.uncommon,
    .item-tooltip .tooltip-rarity.rare,
    .item-tooltip .tooltip-rarity.epic{ color: #000000; }

    /* Inventory Item Styles */
    .inventory-item{
      background: #2a2a2a;
      border: 1px solid #444;
      padding: 4px 6px;
      margin-bottom: 2px;
      display: flex;
      gap: 6px;
      align-items: center;
      transition: background 0.2s;
    }
    .inventory-item:hover{
      background: #0d6efd;
      color: #ffffff;
    }
    .inventory-item:hover .item-name,
    .inventory-item:hover .item-type,
    .inventory-item:hover .item-description,
    .inventory-item:hover .item-stats{
      color: #ffffff;
    }

    .item-icon{
      width: 24px;
      height: 24px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .item-details{
      flex: 1;
      min-width: 0;
    }

    .item-header{
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .item-name{
      font-weight: 400;
      font-size: 11px;
      color: #e0e0e0;
      margin: 0;
    }

    .item-level{
      font-size: 9px;
      color: #cfcfcf;
      margin-left: 6px;
      font-weight: 700;
      background: #111;
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #333;
    }

    .tooltip-level{
      font-size: 9px;
      color: #000;
      margin-left: 6px;
      font-weight: 700;
      background: #ffffe1;
      padding: 1px 4px;
      border-radius: 2px;
      border: 1px solid #000;
    }

    .item-rarity{
      font-size: 9px;
      padding: 1px 3px;
      text-transform: uppercase;
      font-weight: 400;
      letter-spacing: 0;
      background: #1a1a1a;
      color: #e0e0e0;
      border: 1px solid #444;
    }

    .item-type{
      font-size: 9px;
      color: #aaa;
      text-transform: capitalize;
    }

    .item-description{
      font-size: 9px;
      color: #bbb;
      margin: 2px 0 0 0;
      line-height: 1.3;
    }

    .item-stats{
      font-size: 9px;
      color: #22c55e;
      margin-top: 2px;
    }

    .item-quantity{
      font-size: 11px;
      color: #e0e0e0;
      font-weight: 400;
      background: #1a1a1a;
      padding: 2px 4px;
      border: 1px solid #444;
      align-self: center;
    }
  </style>
</head>
<body>
  <!-- Login/Realm Selection Modal -->
  <div id="modal-overlay">
    <div class="modal-content ui-window">
      <!-- Step 1: Login -->
      <div id="step-login" class="modal-step active">
        <div class="modal-title ui-window-titlebar">
          <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff; font-family: 'MS Sans Serif', Arial, sans-serif; text-align: center;">Regnum Online - Login</h2>
        </div>
        <div class="modal-body ui-window-body">
          <div style="color:#e0e0e0;margin-bottom:12px;font-size:11px;text-align:center;padding-top:12px;">
        Login with your cor-forum.de account
          </div>
          <div id="login-error" class="error-message hidden"></div>
          <form id="login-form">
        <div class="form-group">
          <label class="form-label" for="username">Username</label>
          <input type="text" id="username" class="form-input" placeholder="Enter your cor-forum.de username" required>
        </div>
        <div class="form-group">
          <label class="form-label" for="password">Password</label>
          <input type="password" id="password" class="form-input" placeholder="Enter your password" required>
        </div>
        <button type="submit" id="login-btn" class="btn btn-primary">
          <span id="login-text">Login</span>
          <span id="login-spinner" class="loading-spinner" style="display:none;"></span>
        </button>
          </form>
          <p style="margin-top:8px;font-size:11px;color:#e0e0e0;text-align:center;">
        <a href="https://cor-forum.de/board/register/" target="_blank" rel="noopener noreferrer" style="color:#00d9ff;text-decoration:underline;">Sign up</a>&nbsp;|&nbsp;<a href="https://cor-forum.de/board/lost-password/" target="_blank" rel="noopener noreferrer" style="color:#00d9ff;text-decoration:underline;">Reset password</a>
          </p>
        </div>
      </div>
      

      <!-- Step 2: Realm Selection -->
      <div id="step-realm" class="modal-step">
        <div class="modal-title ui-window-titlebar">
          <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff; font-family: 'MS Sans Serif', Arial, sans-serif; text-align: center;">Regnum Online - Select Realm</h2>
        </div>
        <div class="modal-body ui-window-body">
          <p style="color:#e0e0e0;text-align:center;margin-bottom:8px;font-size:11px;">You may change your realm later</p>
          <div id="realm-error" class="error-message hidden"></div>
          <div class="realm-cards">
            <div class="realm-card syrtis" data-realm="syrtis">
              <div class="realm-icon"><img src="assets/logo-syrtis.webp" alt="Syrtis"></div>
              <div class="realm-info">
                <h3>Syrtis</h3>
                <p>The Elven Kingdom</p>
              </div>
            </div>
            <div class="realm-card alsius" data-realm="alsius">
              <div class="realm-icon"><img src="assets/logo-alsius.webp" alt="Alsius"></div>
              <div class="realm-info">
                <h3>Alsius</h3>
                <p>The Dwarven Realm</p>
              </div>
            </div>
            <div class="realm-card ignis" data-realm="ignis">
              <div class="realm-icon"><img src="assets/logo-ignis.webp" alt="Ignis"></div>
              <div class="realm-info">
                <h3>Ignis</h3>
                <p>The Human Empire</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Inventory Window -->
  <div id="inventory-window" class="ui-window" style="position: absolute; right: 12px; bottom: 12px; width: 304px; z-index: 1000; display: none; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
    <div id="inventory-header" class="ui-window-titlebar" style="cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none;">
      <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff; font-family: 'MS Sans Serif', Arial, sans-serif;">Inventory</h2>
      <button id="inventory-close-btn" class="ui-window-close-btn"></button>
    </div>

    <div class="ui-window-body" style="padding: 10px 10px 0 10px;">
      <div class="equipment-area">
        <div class="equipment-row" id="equipment-row-top">
          <div class="equipment-slot empty" data-slot="head" title="Head"></div>
          <div class="equipment-slot empty" data-slot="body" title="Body"></div>
          <div class="equipment-slot empty" data-slot="hands" title="Hands"></div>
          <div class="equipment-slot empty" data-slot="shoulders" title="Shoulders"></div>
          <div class="equipment-slot empty" data-slot="legs" title="Legs"></div>
        </div>
        <div class="equipment-row" id="equipment-row-bottom">
          <div class="equipment-slot empty" data-slot="weapon_right" title="Weapon R"></div>
          <div class="equipment-slot empty" data-slot="weapon_left" title="Weapon L"></div>
          <div class="equipment-slot empty" data-slot="ring_right" title="Ring R"></div>
          <div class="equipment-slot empty" data-slot="ring_left" title="Ring L"></div>
          <div class="equipment-slot empty" data-slot="amulet" title="Amulet"></div>
        </div>
      </div>
    </div>

    <div id="inventory-list" class="ui-window-body" style="padding: 20px;">
      <div id="inventory-loading" style="text-align: center; color: #e0e0e0; padding: 40px;">
        <div class="loading-spinner" style="margin: 0 auto 12px;"></div>
        <div style="font-size: 11px;">Loading inventory...</div>
      </div>
      <div id="inventory-items" style="display: none;"></div>
      <div id="inventory-empty" style="text-align: center; color: #e0e0e0; padding: 40px; display: none; font-size: 11px;">
        Your inventory is empty
      </div>
    </div>
    <div id="inventory-footer" class="ui-window-body" style="padding: 20px; display: none;">
      <div style="display: flex; align-items: center; gap: 4px; color: #e0e0e0; font-size: 11px;">
        <span style="font-size: 14px;">ðŸ’°</span>
        <span id="inventory-gold" style="font-weight: 400;">0 Gold</span>
      </div>
    </div>
  </div>
  
  <!-- Build Path panel moved to public/build-path.js -->

  <!-- Player info moved into the top-left character-status overlay -->

  <div id="map"></div>
  <div id="coords" aria-hidden="true"></div>
  
  <!-- Character Window (equipment + stats) -->
  <div id="character-window" class="ui-window" style="position: absolute; left: 12px; bottom: 12px; width: 320px; z-index: 1000; display: none; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
    <div id="character-header" class="ui-window-titlebar" style="cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none;">
      <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff;">Character</h2>
      <button id="character-close-btn" class="ui-window-close-btn"></button>
    </div>

    <div id="character-body" class="ui-window-body" style="padding: 8px; display: flex; flex-direction: column; gap: 6px;">
      <div class="char-section">
        <div class="char-section-title">Name</div>
        <div class="char-section-body">
          <div id="char-name" class="char-line">-</div>
          <div id="char-realm" class="char-line">-</div>
          <div id="char-class" class="char-line">-</div>
          <div class="char-line">Level <span id="char-level">1</span></div>
        </div>
      </div>

      <div class="char-section">
        <div class="char-section-title">Experience</div>
        <div class="char-section-body">
          <div id="char-xp-text" class="char-line">0 / 0</div>
          <div class="char-xp-bar">
            <div id="char-xp-fill"></div>
          </div>
          <div id="char-rp" class="char-line">0 Regnum Points</div>
        </div>
      </div>

      <div class="char-section">
        <div class="char-section-title">Attributes</div>
        <div class="char-section-body">
          <div class="char-attr-row"><span class="char-attr-name char-attr-good">Intelligence</span><span id="stat-int" class="char-attr-value char-attr-good">20</span></div>
          <div class="char-attr-row"><span class="char-attr-name char-attr-bad">Dexterity</span><span id="stat-dex" class="char-attr-value char-attr-bad">20</span></div>
          <div class="char-attr-row"><span class="char-attr-name char-attr-bad">Concentration</span><span id="stat-con" class="char-attr-value char-attr-bad">20</span></div>
          <div class="char-attr-row"><span class="char-attr-name char-attr-bad">Strength</span><span id="stat-str" class="char-attr-value char-attr-bad">20</span></div>
          <div class="char-attr-row"><span class="char-attr-name char-attr-bad">Constitution</span><span id="stat-const" class="char-attr-value char-attr-bad">20</span></div>
        </div>
      </div>

      <div class="char-section">
        <div class="char-section-body">
          <div class="char-stat-row"><span>Attack:</span><span id="stat-attack">0</span></div>
          <div class="char-stat-row"><span>Armor:</span><span id="stat-armor">0</span></div>
          <div class="char-stat-row"><span>Hit Chance:</span><span id="stat-hit">0</span></div>
          <div class="char-stat-row"><span>Evasion:</span><span id="stat-evasion">0</span></div>
          <div class="char-stat-row"><span>Block Chance:</span><span id="stat-block">0</span></div>
        </div>
      </div>

      <div class="char-section">
        <div class="char-section-body char-status">
          <span>Weakness of the Dead</span><span id="stat-weakness">0%</span>
        </div>
      </div>
    </div>
  </div>
  <div id="header-actions">
    <button class="btn-logout" id="logout-btn">Logout</button>
  </div>
  <!-- UI images overlay (rendered from public/assets/ui-v1) -->
  <div id="ui-image-overlay" aria-hidden="true">
    <div class="ui-bar-repeat"></div>
    <div class="ui-bar-right">
      <img src="assets/ui-v1/ui-bottom-right-premium.png" alt="">
      <div class="ui-hud-group" aria-hidden="false">
        <button id="inventory-hud-btn" class="ui-hud-btn" data-action="inventory" aria-label="Open Inventory"></button>
        <button id="character-hud-btn" class="ui-hud-btn" data-action="character" aria-label="Open Character"></button>
        <button id="actions-hud-btn" class="ui-hud-btn" data-action="actions" aria-label="Actions"></button>
        <button id="party-hud-btn" class="ui-hud-btn" data-action="party" aria-label="Party"></button>
        <button id="premium-hud-btn" class="ui-hud-btn" data-action="premium" aria-label="Premium"></button>
        <button id="quests-hud-btn" class="ui-hud-btn" data-action="quests" aria-label="Quests"></button>
        <button id="spellbook-hud-btn" class="ui-hud-btn" data-action="spellbook" aria-label="Spellbook"></button>
      </div>
    </div>
  </div>
  <!-- Top-right compass (non-interactive) -->
  <div id="ui-compass" aria-hidden="true">
    <img src="assets/ui-v1/ui-compass.png" alt="">
  </div>
  <!-- Top-left character status (non-interactive) -->
  <div id="ui-character-status" aria-hidden="true">
    <img src="assets/ui-v1/ui-character-status.png" alt="">
    <div class="ui-character-overlay" aria-hidden="true">
      <div class="status-top">
        <div id="player-level" style="font-weight:700; color:#ffd700; font-size:13px; min-width:28px; text-align:left;">1</div>
      </div>
      <div class="status-name">
        <span id="player-username" style="font-size:13px; color:#ffffff;">-</span>
      </div>
      <div class="status-bars">
        <div style="display:flex; align-items:center;">
          <div class="territory-health-bar overlay-bar" style="margin-right:6px;">
            <div id="player-health-fill" class="territory-health-fill health-high" style="width:100%; height:100%;"></div>
            <div id="player-health-text" class="bar-text">1000/1000</div>
          </div>
        </div>
        <div style="display:flex; align-items:center; margin-top:0;">
          <div class="territory-health-bar overlay-bar" style="margin-right:6px;">
            <div id="player-mana-fill" class="territory-health-fill" style="width:100%; height:100%;"></div>
            <div id="player-mana-text" class="bar-text">500/500</div>
          </div>
        </div>
      </div>
      <div id="player-coords" style="font-size:11px; color:#e0e0e0; margin-top:4px;">Position: 0, 0</div>
    </div>
  </div>
  <div id="attribution" aria-label="Map author and source">
    <a href="https://github.com/CoR-Forum/RegnumMap-Nostalgia" target="_blank" rel="noopener noreferrer">GitHub</a>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="regions.js"></script>
  <script>
    // Configuration: 3 rows, 3 columns, tiles named `tiles/{row}-{col}.png`
    const rows = 3, cols = 3;
    const tileUrl = (r, c) => `assets/tiles/${r}-${c}.png`;

    // Load first tile to determine tile pixel size at runtime
    const probe = new Image();
    probe.src = tileUrl(1,1);
    probe.onload = () => {
      const tileW = probe.width;
      const tileH = probe.height;

      // Original stitched image pixel size (e.g. 3 * 1024 = 3072)
      const origTotalW = cols * tileW;
      const origTotalH = rows * tileH;

      // Desired raster coordinates size. The world should behave as 6144x6144
      // while the actual stitched image is 3072x3072. scale = 6144/3072 = 2
      const scale = 2;

      // Scaled world size used by Leaflet (map coordinate units)
      totalW = origTotalW * scale;
      totalH = origTotalH * scale;

      // Use CRS.Simple so coordinates map directly to pixels
      // Disable the default zoomControl (placed top-left) so we can
      // re-add it on the right side.
      map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -3,
        maxZoom: 0,
        maxBoundsViscosity: 0.5,
        zoomControl: false,
        scrollWheelZoom: true,
        doubleClickZoom: false,
        boxZoom: false,
        touchZoom: true,
        keyboard: false
      });

      const fullBounds = [[0,0],[totalH,totalW]]; // [[y1,x1],[y2,x2]]
      map.fitBounds(fullBounds);

      // Snap back to bounds, but allow a padding buffer so users can pan slightly
      // outside before the map bounces back. Adjust `pad` (pixels) and
      // `maxBoundsViscosity` above to tune feel.
      const pad = 200 * scale; // pixels of padding outside the image (scaled)
      const paddedBounds = [[-pad, -pad], [totalH + pad, totalW + pad]];
      map.setMaxBounds(paddedBounds);

      // Helper: add markers using raster coordinates (6144x6144 space)
      // Example: addRasterMarker(x, y) where x/y are in the 6144x6144 space.
      // Y-axis: user coords have origin at top-left, Leaflet has origin at bottom-left
      function addRasterMarker(x, y, opts){
        // Leaflet expects [lat, lng] -> [y, x], and invert Y
        return L.marker([totalH - y, x], opts).addTo(map);
      }

      // Convert position objects/arrays (x,y) to Leaflet latlngs
      function positionsToLatLngs(positions){
        return (positions||[]).map(p => {
          if (Array.isArray(p)) {
            // [x,y]
            return [totalH - p[1], p[0]];
          }
          // object {x,y}
          return [totalH - (p.y ?? p[1] ?? 0), (p.x ?? p[0] ?? 0)];
        });
      }

      // region display moved to public/regions.js (initRegionDisplay)
      try {
        if (typeof initRegionDisplay === 'function') {
          initRegionDisplay(map, gameState, apiCall, positionsToLatLngs);
        }
      } catch (e) { console.debug('initRegionDisplay failed', e); }

      // Add each tile as an ImageOverlay positioned by scaled pixel bounds
      // Note: flip vertical ordering so rows 1 and 3 are swapped
      for(let r=1; r<=rows; r++){
        for(let c=1; c<=cols; c++){
          const rowPos = rows - r; // invert row index
          const y1 = rowPos * tileH * scale;
          const x1 = (c-1) * tileW * scale;
          const y2 = (rowPos + 1) * tileH * scale;
          const x2 = c * tileW * scale;
          L.imageOverlay(tileUrl(r,c), [[y1,x1],[y2,x2]]).addTo(map);
        }
      }

      L.control.scale({metric: false, imperial: false}).addTo(map);
      // Add zoom control on the right side
      // Zoom control removed to disable zoom UI (interactions disabled above)

      // Load markers/shapes/icons from JSON and render them
      fetch('assets/markers.json').then(r => r.json()).then(data => {
        const icons = {};
        // Create Leaflet icons (scale sizes by `scale` so they fit raster coords)
        for(const [key, def] of Object.entries(data.icons||{})){
          const size = def.size || [24,24];
          const anchor = def.anchor || [Math.floor(size[0]/2), size[1]];
          icons[key] = L.icon({
            iconUrl: def.url,
            iconSize: [size[0], size[1]],
            iconAnchor: [anchor[0], anchor[1]]
          });
        }
        // Store icons globally for territory markers
        territoryIcons = icons;

        const layerIndex = {};
        const overlays = {};

        function toLatLng(p){ return [totalH - p[1], p[0]]; }

        for(const f of (data.features||[])){
          let layer = null;
          if(f.type === 'marker'){
            const icon = f.icon && icons[f.icon] ? icons[f.icon] : undefined;
            layer = addRasterMarker(f.x, f.y, icon ? {icon} : undefined);
          } else if(f.type === 'circle'){
            const c = toLatLng(f.center);
            layer = L.circle(c, { radius: (f.radius||50), color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polygon'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polygon(pts, { color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polyline'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polyline(pts, { color: f.color || '#3388ff', weight: f.weight || 3 }).addTo(map);
          } else if(f.type === 'group'){
            const members = (f.members||[]).map(id => layerIndex[id]).filter(Boolean);
            layer = L.layerGroup(members).addTo(map);
            // register group as an overlay so it can be toggled in the layer control
            overlays[f.name || f.id || ('group-' + Object.keys(overlays).length)] = layer;
          }

          if(layer){
            if(f.popup) layer.bindPopup(f.popup);
            if(f.id) layerIndex[f.id] = layer;
          }
        }
          // If any overlays (groups) were registered, add a layer control
          if(Object.keys(overlays).length > 0){
            L.control.layers(null, overlays, { collapsed: false, position: 'bottomleft' }).addTo(map);
          }
        // Coordinate readout: show raster coords (original pixel space) while hovering
        const coordsEl = document.getElementById('coords');
        if(coordsEl){
          map.on('mousemove', (e) => {
            const mapX = e.latlng.lng; // scaled x in 0..totalW
            const mapY = e.latlng.lat; // scaled y in 0..totalH (origin at bottom)
            // X: 1-based left-to-right using scaled coords
            const displayX = Math.max(1, Math.min(totalW, Math.floor(mapX) + 1));
            // Y: invert because mapY origin is bottom; top should be 1
            const displayY = Math.max(1, Math.min(totalH, Math.floor(totalH - mapY) + 1));
            coordsEl.style.display = 'block';
            coordsEl.textContent = `${displayX}x${displayY}`;

            // delegate region hover handling to regions module (if present)
            try { if (window.handleRegionMouseMove) window.handleRegionMouseMove(e); } catch (err) { /* ignore */ }
          });
          map.on('mouseout', () => { coordsEl.style.display = 'none'; const indicator = document.getElementById('walk-indicator'); if (indicator) indicator.classList.remove('show'); });
        }
        
        // region overview logic moved to public/regions.js
      }).catch(err => console.error('Failed to load markers.json', err));
    };

    probe.onerror = () => {
      console.error('Failed to load probe tile:', probe.src);
      document.getElementById('map').innerText = 'Failed to load tiles. Check tiles/ filenames.';
    };

    // ============================================================
    // GAME CLIENT CODE
    // ============================================================

    const API_BASE = '/api';
    
    // Global map variables (set by probe.onload)
    let map = null;
    let totalH = 0;
    let totalW = 0;
    let territoryIcons = {};
    
    let gameState = {
      sessionToken: localStorage.getItem('sessionToken'),
      userId: null,
      username: null,
      realm: null,
      position: { x: 0, y: 0 },
      health: 1000,
      maxHealth: 1000,
      mana: 500,
      maxMana: 500,
      playerMarker: null,
      otherPlayers: new Map(),
      territories: new Map(),
      superbosses: new Map(),
    pathsLayer: null,
    regionsLayer: null,
    showRegions: false,
    showPaths: false,
      buildPathPoints: [],
      buildPathPolyline: null,
      pollInterval: null,
      territoriesPollInterval: null,
      superbossesPollInterval: null
    };

    // API Helper functions
    async function apiCall(endpoint, options = {}) {
      const headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...options.headers
      };

      if (gameState.sessionToken && !options.skipAuth) {
        headers['X-Session-Token'] = gameState.sessionToken;
      }

      const response = await fetch(API_BASE + endpoint, {
        ...options,
        headers
      });

      const status = response.status;
      let data = null;
      try { data = await response.json(); } catch (e) { data = null; }

      if (!response.ok) {
        const err = new Error((data && data.error) ? data.error : 'API call failed');
        err.status = status;
        err.body = data;
        throw err;
      }

      if (data && data.success === false) {
        const err = new Error(data.error || 'API call failed');
        err.status = status;
        err.body = data;
        throw err;
      }

      return data;
    }

    // Small helper to format durations like respawn timers
    function formatDurationSeconds(s) {
      if (typeof s !== 'number' || isNaN(s)) return '';
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const sec = Math.floor(s % 60);
      let out = '';
      if (h) out += h + 'h ';
      if (m) out += m + 'm ';
      out += sec + 's';
      return out;
    }

    // Login handler
    document.getElementById('login-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      const loginBtn = document.getElementById('login-btn');
      const loginText = document.getElementById('login-text');
      const loginSpinner = document.getElementById('login-spinner');
      const errorEl = document.getElementById('login-error');

      loginBtn.disabled = true;
      loginText.style.display = 'none';
      loginSpinner.style.display = 'inline-block';
      errorEl.classList.add('hidden');

      try {
        const formData = new URLSearchParams();
        formData.append('username', username);
        formData.append('password', password);

        const data = await apiCall('/login', {
          method: 'POST',
          body: formData,
          skipAuth: true
        });

        gameState.sessionToken = data.sessionToken;
        gameState.userId = data.userId;
        gameState.username = data.username;
        gameState.realm = data.realm;

        localStorage.setItem('sessionToken', data.sessionToken);

        if (data.needsRealmSelection) {
          showRealmSelection();
        } else {
          await initGame();
        }
      } catch (error) {
        errorEl.textContent = error.message;
        errorEl.classList.remove('hidden');
        loginBtn.disabled = false;
        loginText.style.display = 'inline';
        loginSpinner.style.display = 'none';
      }
    });

    // Realm selection handler
    document.querySelectorAll('.realm-card').forEach(card => {
      card.addEventListener('click', async () => {
        const realm = card.dataset.realm;
        const errorEl = document.getElementById('realm-error');
        errorEl.classList.add('hidden');

        try {
          const formData = new URLSearchParams();
          formData.append('realm', realm);

          const data = await apiCall('/realm/select', {
            method: 'POST',
            body: formData
          });

          gameState.realm = data.realm;
          gameState.position = data.position;

          await initGame();
        } catch (error) {
          errorEl.textContent = error.message;
          errorEl.classList.remove('hidden');
        }
      });
    });

    // Inventory button handler (legacy header button may be absent)
    const _inventoryBtn = document.getElementById('inventory-btn');
    if (_inventoryBtn) _inventoryBtn.addEventListener('click', () => { openInventory(); });

    // Delegated handler for HUD buttons (inventory/character and future buttons)
    document.addEventListener('click', (e) => {
      const btn = e.target.closest && e.target.closest('.ui-hud-btn');
      if (!btn) return;
      const action = String(btn.dataset.action || '').trim();
      if (!action) return;
      try {
        // Prefer explicit known handlers
        if (action === 'inventory') { return openInventory(); }
        if (action === 'character') { return openCharacter(); }

        // Try to call a global open<Action>() function if available (e.g. openParty)
        const fnName = 'open' + action.charAt(0).toUpperCase() + action.slice(1);
        const fn = window[fnName];
        if (typeof fn === 'function') return fn();

        console.debug('No handler for HUD action', action);
      } catch (err) { console.error('HUD button action failed', err); }
    });

    // Close inventory handler
    document.getElementById('inventory-close-btn').addEventListener('click', () => {
      closeInventory();
    });

    // Character button and close handler (header button may be absent)
    const _characterBtn = document.getElementById('character-btn');
    if (_characterBtn) _characterBtn.addEventListener('click', () => { openCharacter(); });
    document.getElementById('character-close-btn').addEventListener('click', () => {
      closeCharacter();
    });

    // Make inventory window draggable
    // Global helper to translate windows
    function setTranslate(xPos, yPos, el) {
      if (!el) return;
      el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }

    (function() {
      const inventoryWindow = document.getElementById('inventory-window');
      const header = document.getElementById('inventory-header');
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;
      let xOffset = 0;
      let yOffset = 0;

      header.addEventListener('mousedown', dragStart);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', dragEnd);

      function dragStart(e) {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        isDragging = true;
      }

      function drag(e) {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          xOffset = currentX;
          yOffset = currentY;
          setTranslate(currentX, currentY, inventoryWindow);
        }
      }

      function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
      }
    
    })();

    // Build Path behavior moved to public/build-path.js

    // Logout handler
    document.getElementById('logout-btn').addEventListener('click', () => {
      localStorage.removeItem('sessionToken');
      gameState.sessionToken = null;
      if (gameState.pollInterval) {
        clearInterval(gameState.pollInterval);
      }
      if (gameState.territoriesPollInterval) {
        clearInterval(gameState.territoriesPollInterval);
      }
      if (gameState.superbossesPollInterval) {
        clearInterval(gameState.superbossesPollInterval);
      }
      location.reload();
    });

    function showRealmSelection() {
      document.getElementById('step-login').classList.remove('active');
      document.getElementById('step-realm').classList.add('active');
    }

    async function openInventory() {
      const window = document.getElementById('inventory-window');
      window.style.display = 'flex';
      document.getElementById('inventory-loading').style.display = 'block';
      document.getElementById('inventory-items').style.display = 'none';
      document.getElementById('inventory-empty').style.display = 'none';

      try {
        const [equipData, invData] = await Promise.all([apiCall('/equipment'), apiCall('/inventory')]);
        if (equipData) displayEquipment(equipData.equipment);
        if (invData) displayInventory(invData.items);
      } catch (error) {
        console.error('Failed to fetch inventory:', error);
        alert('Failed to load inventory: ' + error.message);
        closeInventory();
      }
    }

    function closeInventory() {
      document.getElementById('inventory-window').style.display = 'none';
    }

    // Character window functions
    async function openCharacter(){
      const win = document.getElementById('character-window');
      if (!win) return;
      win.style.display = 'flex';
      try{
        const posData = await apiCall('/player/position');
        if (posData) {
          gameState.xp = typeof posData.xp !== 'undefined' ? posData.xp : gameState.xp;
          gameState.level = typeof posData.level !== 'undefined' ? posData.level : gameState.level;
          gameState.xpToNext = typeof posData.xpToNext !== 'undefined' ? posData.xpToNext : gameState.xpToNext;
          gameState.stats = posData.stats || gameState.stats;
          gameState.damage = typeof posData.damage !== 'undefined' ? posData.damage : (gameState.damage || 0);
          gameState.armor = typeof posData.armor !== 'undefined' ? posData.armor : (gameState.armor || 0);
          gameState.username = typeof posData.username !== 'undefined' ? posData.username : gameState.username;
          gameState.realm = typeof posData.realm !== 'undefined' ? posData.realm : gameState.realm;
          // prefer explicit className, fall back to class
          gameState.className = typeof posData.className !== 'undefined' ? posData.className : (typeof posData.class !== 'undefined' ? posData.class : gameState.className);
        }
      }catch(err){ console.error('Failed to load character data:', err); }
      updateCharacterStats();
    }

    function closeCharacter(){
      const el = document.getElementById('character-window'); if(el) el.style.display = 'none';
    }

    function updateCharacterStats(){
      try{
        const lvlEl = document.getElementById('char-level'); if (lvlEl) lvlEl.textContent = gameState.level || 1;
        const nameEl = document.getElementById('char-name'); if (nameEl) nameEl.textContent = gameState.username || '-';
        const realmEl = document.getElementById('char-realm');
        if (realmEl) {
          const realm = gameState.realm ? (String(gameState.realm).charAt(0).toUpperCase() + String(gameState.realm).slice(1)) : '-';
          realmEl.textContent = realm;
        }
        const classEl = document.getElementById('char-class');
        if (classEl) classEl.textContent = gameState.className || gameState.class || 'Unknown';
        try {
          const fill = document.getElementById('char-xp-fill');
          const xp = Number(gameState.xp || 0);
          const xpToNextVal = Number(gameState.xpToNext || 0);
          const pct = (xpToNextVal > 0) ? Math.round((xp / (xp + xpToNextVal)) * 100) : 100;
          if (fill) fill.style.width = pct + '%';
          const xpText = document.getElementById('char-xp-text');
          if (xpText) xpText.textContent = `${xp} / ${xp + xpToNextVal}`;
          const rpEl = document.getElementById('char-rp');
          const rpVal = Number(gameState.regnumPoints || 0);
          if (rpEl) rpEl.textContent = `${rpVal} Regnum Points`;
        } catch (e) {}
        const s = gameState.stats || { intelligence:20, dexterity:20, concentration:20, strength:20, constitution:20 };
        document.getElementById('stat-int').textContent = `${s.intelligence || 20}`;
        document.getElementById('stat-dex').textContent = `${s.dexterity || 20}`;
        document.getElementById('stat-con').textContent = `${s.concentration || 20}`;
        document.getElementById('stat-str').textContent = `${s.strength || 20}`;
        document.getElementById('stat-const').textContent = `${s.constitution || 20}`;
        try {
          const dmg = Number(gameState.damage || 0);
          const arm = Number(gameState.armor || 0);
          const dmgEl = document.getElementById('stat-attack');
          const armEl = document.getElementById('stat-armor');
          if (dmgEl) dmgEl.textContent = `${dmg}`;
          if (armEl) armEl.textContent = `${arm}`;
          const hitEl = document.getElementById('stat-hit');
          const evasionEl = document.getElementById('stat-evasion');
          const blockEl = document.getElementById('stat-block');
          if (hitEl) hitEl.textContent = `${Number(gameState.hitChance || 0)}`;
          if (evasionEl) evasionEl.textContent = `${Number(gameState.evasion || 0)}`;
          if (blockEl) blockEl.textContent = `${Number(gameState.blockChance || 0)}`;
          const weaknessEl = document.getElementById('stat-weakness');
          if (weaknessEl) weaknessEl.textContent = `${Number(gameState.weakness || 0)}%`;
        } catch (e) {}
      }catch(e){}
    }

    function displayInventory(items) {
      document.getElementById('inventory-loading').style.display = 'none';

      const container = document.getElementById('inventory-items');
      const footer = document.getElementById('inventory-footer');
      container.innerHTML = '';

      if (items.length === 0) {
        document.getElementById('inventory-empty').style.display = 'block';
        footer.style.display = 'none';
        return;
      }

      document.getElementById('inventory-items').style.display = 'block';
      footer.style.display = 'flex';

      // Icon mapping
      const iconMap = {
        weapon: 'âš”ï¸',
        armor: 'ðŸ›¡ï¸',
        consumable: 'ðŸ§ª',
        currency: 'ðŸ’°',
        misc: 'ðŸ“¦'
      };

      // Make character window draggable
      (function() {
        const characterWindow = document.getElementById('character-window');
        const header = document.getElementById('character-header');
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        header.addEventListener('mousedown', dragStartChar);
        document.addEventListener('mousemove', dragChar);
        document.addEventListener('mouseup', dragEndChar);

        function dragStartChar(e) {
          initialX = e.clientX - xOffset;
          initialY = e.clientY - yOffset;
          isDragging = true;
        }

        function dragChar(e) {
          if (isDragging) {
            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            xOffset = currentX;
            yOffset = currentY;
            setTranslate(currentX, currentY, characterWindow);
          }
        }

        function dragEndChar(e) {
          initialX = currentX;
          initialY = currentY;
          isDragging = false;
        }
      })();

      // Calculate total gold
      let totalGold = 0;

      // Render items as list
      items.forEach(item => {
        // Track gold
        if (item.itemName === 'Gold Coin') {
          totalGold += item.quantity;
        }

        const itemDiv = document.createElement('div');
        itemDiv.className = 'inventory-item';

        const icon = iconMap[item.itemType] || 'ðŸ“¦';

        itemDiv.innerHTML = `
          <div class="item-icon">${icon}</div>
          <div class="item-details">
            <div class="item-header">
              <h4 class="item-name">${item.itemName} ${typeof item.level !== 'undefined' ? `<span class="item-level">Lv ${item.level}</span>` : ''}</h4>
              <span class="item-rarity ${item.rarity}">${item.rarity}</span>
            </div>
            <div class="item-type">${getItemTypeLabel(item)}</div>
            ${item.description ? `<div class="item-description">${item.description}</div>` : ''}
            ${item.stats && Object.keys(item.stats).length > 0 ? `<div class="item-stats">Stats: ${Object.entries(item.stats).map(([k, v]) => `+${v} ${k.replace('_', ' ')}`).join(', ')}</div>` : ''}
          </div>
          ${item.quantity > 1 ? `<div class="item-quantity">Ã—${item.quantity}</div>` : ''}
        `;

        // Make draggable and attach dragstart payload (include equipmentSlot)
        const invId = item.inventoryId ?? item.inventory_id ?? item.inventoryId ?? item.inventoryId;
        const equipSlot = item.equipmentSlot ?? item.equipment_slot ?? null;
        itemDiv.draggable = true;
        itemDiv.dataset.inventoryId = invId;
        itemDiv.dataset.equipmentSlot = equipSlot || '';
        // Do not visually de-emphasize non-equippable items; server still enforces equips
        itemDiv.addEventListener('dragstart', (ev) => {
          const payload = JSON.stringify({ inventoryId: invId, equipmentSlot: equipSlot });
          try { ev.dataTransfer.setData('application/json', payload); } catch(_) { ev.dataTransfer.setData('text/plain', payload); }
        });

        // Tooltip on hover
        itemDiv.addEventListener('mouseenter', (e) => showTooltip(e, item));
        itemDiv.addEventListener('mouseleave', hideTooltip);
        itemDiv.addEventListener('mousemove', (e) => moveTooltip(e));

        // Right-click to equip
        itemDiv.addEventListener('contextmenu', async (e) => {
          try {
            e.preventDefault();
            const id = itemDiv.dataset.inventoryId;
            if (!id) return;
            const form = new URLSearchParams();
            form.append('inventoryId', id);
            try {
              await apiCall('/equipment/equip', { method: 'POST', body: form });
            } catch (err) {
              const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to equip item';
              if (window.addLogMessage) window.addLogMessage(msg, 'error');
            }
            try { if (document.getElementById('character-window') && document.getElementById('character-window').style.display !== 'none') await openCharacter(); } catch(e){}
            try { if (document.getElementById('inventory-window') && document.getElementById('inventory-window').style.display !== 'none') await openInventory(); } catch(e){}
          } catch (e) { console.error('inventory right-click equip failed', e); }
        });

        container.appendChild(itemDiv);
      });
      
      // Update gold display
      document.getElementById('inventory-gold').textContent = `${totalGold.toLocaleString()} Gold`;
    }

    // Make inventory container accept drops from equipment slots (unequip)
    (function(){
      const invContainer = document.getElementById('inventory-items');
      if(!invContainer) return;
      invContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
      invContainer.addEventListener('drop', async (e) => {
        e.preventDefault();
        try {
          const payload = e.dataTransfer.getData('application/json') || e.dataTransfer.getData('text/plain');
          if(!payload) return;
          const data = JSON.parse(payload);
          if(data.fromSlot && data.slot){
            // Unequip slot
            const form = new URLSearchParams();
            form.append('slot', data.slot);
            try {
              await apiCall('/equipment/unequip', { method: 'POST', body: form });
            } catch (err) {
              try {
                const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to unequip item';
                if (window.addLogMessage) window.addLogMessage(msg, 'error');
              } catch (e) { console.error('Failed to log unequip error', e); }
            }
            // refresh inventory and equipment
            try { await openInventory(); } catch(e){}
          }
        } catch(err){ console.error('Failed to unequip:', err); }
      });
    })();

    let currentTooltip = null;

    function showTooltip(event, item) {
      hideTooltip();
      
    const tooltip = document.createElement('div');
    tooltip.className = 'item-tooltip';
      
      // Format stats
      let statsHtml = '';
      if (item.stats && Object.keys(item.stats).length > 0) {
        const statsParts = Object.entries(item.stats).map(([key, value]) => {
          return `+${value} ${key.replace('_', ' ')}`;
        });
        statsHtml = `<div class="tooltip-stats">${statsParts.join('<br>')}</div>`;
      }
      
      tooltip.innerHTML = `
        <div class="tooltip-name">${item.itemName} ${typeof item.level !== 'undefined' ? `<span class="tooltip-level">Lv ${item.level}</span>` : ''}</div>
        <div class="tooltip-type">${getItemTypeLabel(item)}</div>
        ${item.description ? `<div class="tooltip-description">"${item.description}"</div>` : ''}
        ${statsHtml}
        <div class="tooltip-rarity ${item.rarity}">${item.rarity}</div>
      `;
      
      document.body.appendChild(tooltip);
      currentTooltip = tooltip;
      moveTooltip(event);
    }

    function moveTooltip(event) {
      if (!currentTooltip) return;
      const offsetX = 15;
      const offsetY = 15;
      currentTooltip.style.left = (event.clientX + offsetX) + 'px';
      currentTooltip.style.top = (event.clientY + offsetY) + 'px';
    }

    function hideTooltip() {
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
      }
    }

    // Equipment rendering and drag/drop handlers
    function getEquipIcon(type, slotName){
      const map = {
        weapon: 'âš”ï¸',
        armor: 'ðŸ›¡ï¸',
        consumable: 'ðŸ§ª',
        currency: 'ðŸ’°',
        misc: 'ðŸ“¦'
      };
      if(slotName && slotName.startsWith('ring')) return 'ðŸ’';
      if(slotName && slotName.includes('weapon')) return 'âš”ï¸';
      if(type && map[type]) return map[type];
      return 'ðŸ”¹';
    }

    // Friendly label for item type + equipment slot
    function getItemTypeLabel(item){
      const slot = item.equipmentSlot || item.equipment_slot || null;
      if(slot){
        switch(slot){
          case 'head': return 'Armor (Head)';
          case 'body': return 'Armor (Body)';
          case 'hands': return 'Armor (Hands)';
          case 'shoulders': return 'Armor (Shoulders)';
          case 'legs': return 'Armor (Legs)';
          case 'weapon_right': return 'Weapon (Right Hand)';
          case 'weapon_left': return 'Weapon (Left Hand)';
          case 'ring_right':
          case 'ring_left': return 'Ring';
          case 'amulet': return 'Amulet';
          default: return item.itemType || '';
        }
      }
      const t = item.itemType || '';
      return t.charAt(0).toUpperCase() + t.slice(1);
    }

    function displayEquipment(equipment){
      try{
        const slots = ['head','body','hands','shoulders','legs','weapon_right','weapon_left','ring_right','ring_left','amulet'];
        slots.forEach(slot => {
          const el = document.querySelector(`.equipment-slot[data-slot="${slot}"]`);
          if(!el) return;
          const info = equipment[slot] || { inventoryId: null, item: null };
          el.classList.toggle('empty', !info || !info.inventoryId);
          el.dataset.slot = slot;
          // clear previous listeners by cloning node
          const newEl = el.cloneNode(true);
          el.parentNode.replaceChild(newEl, el);
          const target = newEl;

          if(info && info.inventoryId){
            const it = info.item || {};
            const icon = getEquipIcon(it.type, slot);
            target.innerHTML = `<div class="slot-icon">${icon}</div>`;
            target.dataset.inventoryId = info.inventoryId;
            // Tooltip
            target.addEventListener('mouseenter', (e)=>{
              const tooltipItem = {
                itemName: it.name || it.itemName || '',
                itemType: it.type || it.itemType || '',
                equipmentSlot: it.equipmentSlot || it.equipment_slot || null,
                description: it.description || '',
                stats: it.stats || {},
                rarity: it.rarity || 'common',
                quantity: it.quantity || 1,
                level: typeof it.level !== 'undefined' ? it.level : 1
              };
              showTooltip(e, tooltipItem);
            });
            target.addEventListener('mousemove', moveTooltip);
            target.addEventListener('mouseleave', hideTooltip);

            // Make slot draggable to allow unequip (drag to inventory)
            target.draggable = true;
            target.addEventListener('dragstart', (ev) => {
              const payload = JSON.stringify({ fromSlot: true, slot: slot, inventoryId: info.inventoryId });
              try{ ev.dataTransfer.setData('application/json', payload); }catch(_){ ev.dataTransfer.setData('text/plain', payload); }
            });

            // Right-click to unequip
            target.addEventListener('contextmenu', async (e) => {
              try {
                e.preventDefault();
                const form = new URLSearchParams();
                form.append('slot', slot);
                try {
                  await apiCall('/equipment/unequip', { method: 'POST', body: form });
                } catch (err) {
                  const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to unequip item';
                  if (window.addLogMessage) window.addLogMessage(msg, 'error');
                }
                try { if (document.getElementById('inventory-window') && document.getElementById('inventory-window').style.display !== 'none') await openInventory(); } catch(e){}
                try { if (document.getElementById('character-window') && document.getElementById('character-window').style.display !== 'none') await openCharacter(); } catch(e){}
              } catch (e) { console.error('equipment right-click unequip failed', e); }
            });
          } else {
            // empty slot: clear inner content â€” background image handles the icon
            target.innerHTML = '';
            target.removeAttribute('data-inventory-id');
            target.draggable = false;
            target.addEventListener('mouseenter', ()=>{});
          }

          // Accept drops from inventory items
          target.addEventListener('dragover', (e)=>{ e.preventDefault(); target.classList.add('drag-over'); });
          target.addEventListener('dragleave', ()=>{ target.classList.remove('drag-over'); });
          target.addEventListener('drop', async (e)=>{
            e.preventDefault(); target.classList.remove('drag-over');
            try{
              const payload = e.dataTransfer.getData('application/json') || e.dataTransfer.getData('text/plain');
              if(!payload) return;
              const data = JSON.parse(payload);
              if(data.inventoryId){
                // Allow dropping onto any slot; server will auto-assign the correct template slot.
                const form = new URLSearchParams();
                form.append('inventoryId', data.inventoryId);
                try {
                  await apiCall('/equipment/equip', { method: 'POST', body: form });
                } catch (err) {
                  try {
                    const msg = (err && err.body && err.body.error) ? err.body.error : (err && err.message) ? err.message : 'Failed to equip item';
                    if (window.addLogMessage) window.addLogMessage(msg, 'error');
                  } catch (e) { console.error('Failed to log equip error', e); }
                }
                // Refresh equipment view and inventory if visible
                try {
                  if (document.getElementById('character-window') && document.getElementById('character-window').style.display !== 'none') {
                    await openCharacter();
                  }
                } catch(e){}
                try {
                  if (document.getElementById('inventory-window') && document.getElementById('inventory-window').style.display !== 'none') {
                    await openInventory();
                  }
                } catch(e){}
              }
            }catch(err){ console.error('Equip failed', err); }
          });
        });
      }catch(err){ console.error('displayEquipment error', err); }
    }

    function hideModal() {
      const overlay = document.getElementById('modal-overlay');
      overlay.classList.add('hidden');
      // restore overlay pointer behavior
      try { overlay.style.pointerEvents = 'auto'; } catch (e) {}
      // leave build mode off when modal hidden
      try { gameState.buildPathMode = false; } catch (e) {}
      // clear any inline styles applied to build modal step
      try {
        const step = document.getElementById('step-build-path');
        if (step) {
          step.style.position = '';
          step.style.left = '';
          step.style.top = '';
          step.style.zIndex = '';
          step.style.pointerEvents = '';
          step.style.maxWidth = '';
        }
      } catch (e) {}
    }

    // Build Path UI moved to public/build-path.js

    // Build panel wiring moved to public/build-path.js

    function showPlayerInfo() {
      const username = gameState.username || '';
      const usernameEl = document.getElementById('player-username');
      const charNameEl = document.getElementById('char-name');
      const realmBadge = document.querySelector('#ui-character-status .realm-badge');
      console.debug('showPlayerInfo username=', username);
      if (usernameEl) usernameEl.textContent = username;
      if (charNameEl && !charNameEl.textContent.trim()) charNameEl.textContent = username || '-';
      if (realmBadge) realmBadge.className = `realm-badge ${gameState.realm}`;
      // populate level display if present
      const lvlEl = document.getElementById('player-level');
      if (lvlEl) lvlEl.textContent = gameState.level || 1;
    }

    function updatePlayerStats() {
      // Update health bar
      const healthPercent = (gameState.health / gameState.maxHealth) * 100;
      const healthFill = document.getElementById('player-health-fill');
      const healthText = document.getElementById('player-health-text');
      
      healthFill.style.width = `${healthPercent}%`;
      healthText.textContent = `${gameState.health}/${gameState.maxHealth}`;
      
      // Ensure the overlay player health fill uses the UI border-image and remains visible
      healthFill.className = 'territory-health-fill';
      healthFill.style.backgroundColor = 'transparent';
      healthFill.style.borderWidth = '0 2px 0 2px';
      healthFill.style.borderStyle = 'solid';
      healthFill.style.boxSizing = 'border-box';
      healthFill.style.borderImage = "url('assets/ui-v1/ui-bar-health.png') 0 2 0 2 fill / 0 2px 0 2px / 0 stretch";

      // Update mana bar
      const manaPercent = (gameState.mana / gameState.maxMana) * 100;
      const manaFill = document.getElementById('player-mana-fill');
      const manaText = document.getElementById('player-mana-text');
      
      manaFill.style.width = `${manaPercent}%`;
      manaText.textContent = `${gameState.mana}/${gameState.maxMana}`;
    }

    function updatePlayerCoords(x, y) {
      document.getElementById('player-coords').textContent = `Position: ${x}, ${y}`;

      // If player reached walking target, clear walking UI
      if (gameState.walkingTarget && gameState.walkingTarget.x === x && gameState.walkingTarget.y === y) {
        // remove destination marker
        if (gameState.walkDestinationMarker) {
          try { map.removeLayer(gameState.walkDestinationMarker); } catch (e) {}
          gameState.walkDestinationMarker = null;
        }
        gameState.walkingTarget = null;
      }
    }

    // Initialize game after login/realm selection
    async function initGame() {
      try {
        // Get current position
        const data = await apiCall('/player/position');
        if (!data || !data.position) {
          throw new Error('Invalid /player/position response');
        }
        gameState.position = data.position;
        gameState.realm = data.realm;
        gameState.username = typeof data.username !== 'undefined' ? data.username : gameState.username;
        gameState.health = data.health;
        gameState.maxHealth = data.maxHealth;
        gameState.mana = data.mana;
        gameState.maxMana = data.maxMana;
        gameState.damage = typeof data.damage !== 'undefined' ? data.damage : 0;
        gameState.armor = typeof data.armor !== 'undefined' ? data.armor : 0;
        // XP / level / stats
        gameState.xp = typeof data.xp !== 'undefined' ? data.xp : 0;
        gameState.level = typeof data.level !== 'undefined' ? data.level : 1;
        gameState.xpToNext = typeof data.xpToNext !== 'undefined' ? data.xpToNext : 0;
        gameState.stats = data.stats || { intelligence:20, dexterity:20, concentration:20, strength:20, constitution:20 };

        // Reveal main UI now that session is validated
        try { document.body.classList.add('authenticated'); } catch(e){}
        // Allow layout to settle, then invalidate Leaflet size and re-center map
        try {
          setTimeout(() => {
            try {
              if (typeof map !== 'undefined' && map && typeof map.invalidateSize === 'function') {
                map.invalidateSize();
                if (gameState && gameState.position) {
                  const latLng = [totalH - gameState.position.y, gameState.position.x];
                  try { map.setView(latLng, map.getZoom()); } catch(e){}
                }
              }
            } catch (e) {}
          }, 100);
        } catch(e) {}

        hideModal();
        showPlayerInfo();
        updatePlayerStats();

        // Create player marker
        createPlayerMarker(gameState.position.x, gameState.position.y);

        // Load and render paths from server only if enabled
        if (gameState.showPaths) await loadAndRenderPaths();

        // Enable click-to-move
        enableClickToMove();

        // Start polling for other players
        startPlayerPolling();

        // Start polling for territories
        startTerritoriesPolling();

        // Start polling for superbosses
        startSuperbossesPolling();

        updatePlayerCoords(gameState.position.x, gameState.position.y);
      } catch (error) {
        console.error('Failed to initialize game:', error);
        alert('Failed to initialize game: ' + error.message);
        localStorage.removeItem('sessionToken');
        location.reload();
      }
    }

    function createPlayerMarker(x, y) {
      if (gameState.playerMarker) {
        map.removeLayer(gameState.playerMarker);
      }

      const realmColors = {
        syrtis: '#22c55e',
        alsius: '#3b82f6',
        ignis: '#ef4444'
      };

      const latLng = [totalH - y, x];
      const myRealmKey = (gameState.realm || '').toString().toLowerCase();
      const myColor = realmColors[myRealmKey] || '#22c55e';
      gameState.playerMarker = L.circleMarker(latLng, {
        radius: 8,
        fillColor: myColor,
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
      }).addTo(map);

      // store original player color for later restore when walking finishes

      gameState.playerMarker.bindPopup(`<b>${gameState.username}</b><br>Realm: ${gameState.realm}`);
      // Ensure player marker is rendered above other markers (spawn/territory icons)
      try {
        if (typeof gameState.playerMarker.setZIndexOffset === 'function') gameState.playerMarker.setZIndexOffset(1000);
        if (typeof gameState.playerMarker.bringToFront === 'function') gameState.playerMarker.bringToFront();
      } catch (e) {}
      map.setView(latLng, map.getZoom());
    }

    // Context menu + right-click move support
    let __lastContextLatLng = null;
    let __mapContextMenuEl = null;
    let __lastContextAllowed = null;

    function createMapContextMenu() {
      __mapContextMenuEl = document.createElement('div');
      __mapContextMenuEl.id = 'map-contextmenu';
      __mapContextMenuEl.className = 'map-contextmenu';
      __mapContextMenuEl.innerHTML = '<div class="map-contextmenu-item" id="map-walk-here">Walk here</div><div class="map-contextmenu-item" id="map-teleport">Teleport</div><div class="map-contextmenu-item" id="map-copy-coords">Copy Coords</div>';
      document.body.appendChild(__mapContextMenuEl);

      __mapContextMenuEl.querySelector('#map-teleport').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        if (!__lastContextLatLng) return hideMapContextMenu();
        await performMoveAtLatLng(__lastContextLatLng);
        hideMapContextMenu();
      });

      __mapContextMenuEl.querySelector('#map-walk-here').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        if (!__lastContextLatLng) return hideMapContextMenu();
        try {
          console.log('ContextMenu: Walk here clicked', __lastContextLatLng);
          // Defensive copy of latlng
          const ll = (typeof L !== 'undefined' && L && L.latLng) ? L.latLng(__lastContextLatLng.lat, __lastContextLatLng.lng) : __lastContextLatLng;
          // Ensure permission check (async) before initiating walk
          try {
            const allowed = await isLatLngWalkAllowedAsync(ll);
            if (!allowed) { alert('Cannot walk to that region.'); hideMapContextMenu(); return; }
          } catch (e) { console.error('Walk permission check failed', e); alert('Cannot walk to that region.'); hideMapContextMenu(); return; }

          await performWalkAtLatLng(ll);
        } catch (err) {
          console.error('performWalkAtLatLng failed', err);
        }
        hideMapContextMenu();
      });

      __mapContextMenuEl.querySelector('#map-copy-coords').addEventListener('click', async (ev) => {
        ev.stopPropagation();
        if (!__lastContextLatLng) return hideMapContextMenu();
        const x = Math.round(__lastContextLatLng.lng);
        const y = Math.round(totalH - __lastContextLatLng.lat);
        const text = `[${x}, ${y}]`;
        // try navigator.clipboard, fallback to textarea + execCommand
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
          }
          // small visual feedback: briefly show copied text in the menu without replacing innerHTML
          const temp = document.createElement('div');
          temp.className = 'map-contextmenu-temp';
          temp.style.padding = '8px';
          temp.style.color = '#fff';
          temp.style.pointerEvents = 'none';
          temp.textContent = 'Copied ' + text;
          __mapContextMenuEl.appendChild(temp);
          setTimeout(() => { if (temp.parentNode) temp.parentNode.removeChild(temp); hideMapContextMenu(); }, 700);
        } catch (e) {
          console.error('Copy failed', e);
          hideMapContextMenu();
        }
      });

      // Add Build Path menu item without touching innerHTML to preserve other listeners
      const buildItem = document.createElement('div');
      buildItem.className = 'map-contextmenu-item';
      buildItem.id = 'map-build-path';
      buildItem.textContent = 'Build Path';
      __mapContextMenuEl.appendChild(buildItem);
      buildItem.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        hideMapContextMenu();
        try { if (window.buildPath && typeof window.buildPath.showPanel === 'function') window.buildPath.showPanel(); } catch (e) { console.error(e); }
      });

      // Hide menu when clicking elsewhere or pressing Escape
      document.addEventListener('click', (ev) => { if (__mapContextMenuEl && !__mapContextMenuEl.contains(ev.target)) hideMapContextMenu(); });
      document.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') hideMapContextMenu(); });
    }

    function showMapContextMenuAt(containerPoint, latlng) {
      if (!__mapContextMenuEl) createMapContextMenu();
      __lastContextLatLng = latlng;
      const rect = map.getContainer().getBoundingClientRect();
      __mapContextMenuEl.style.left = (rect.left + containerPoint.x) + 'px';
      __mapContextMenuEl.style.top = (rect.top + containerPoint.y) + 'px';
      __mapContextMenuEl.style.display = 'block';
      // show/hide Walk Here item depending on whether the location is walkable
      try {
        const walkItem = __mapContextMenuEl.querySelector('#map-walk-here');
        if (walkItem) {
          if (typeof __lastContextAllowed === 'boolean') {
            // permission was precomputed by the contextmenu handler
            walkItem.style.display = __lastContextAllowed ? 'block' : 'none';
            walkItem.title = __lastContextAllowed ? '' : 'Cannot walk to that region';
            __lastContextAllowed = null;
          } else {
            // fallback: hide while checking then async update
            walkItem.style.display = 'none';
            walkItem.title = 'Checking...';
            (async () => {
              try {
                const allowed = await isLatLngWalkAllowedAsync(latlng);
                if (allowed) {
                  walkItem.style.display = 'block';
                  walkItem.title = '';
                } else {
                  walkItem.style.display = 'none';
                  walkItem.title = 'Cannot walk to that region';
                }
              } catch (e) {
                walkItem.style.display = 'none';
                walkItem.title = 'Cannot walk to that region';
              }
            })();
          }
        }
      } catch (e) { /* ignore */ }
    }

    function hideMapContextMenu() {
      if (!__mapContextMenuEl) return;
      __mapContextMenuEl.style.display = 'none';
      __lastContextLatLng = null;
    }

    // Region permission helpers moved to public/regions.js

    async function performMoveAtLatLng(latlng) {
      const x = Math.round(latlng.lng);
      const y = Math.round(totalH - latlng.lat);

      if (x < 0 || x > 6144 || y < 0 || y > 6144) return;

      try {
        const formData = new URLSearchParams();
        formData.append('x', x);
        formData.append('y', y);

        await apiCall('/player/position', {
          method: 'POST',
          body: formData
        });

        gameState.position = { x, y };
        if (gameState.playerMarker) gameState.playerMarker.setLatLng([totalH - y, x]);
        updatePlayerCoords(x, y);
      } catch (error) {
        console.error('Failed to update position:', error);
      }
    }

    // Start walking toward a target; server will compute path and advance via cron.
    async function performWalkAtLatLng(latlng) {
      const x = Math.round(latlng.lng);
      const y = Math.round(totalH - latlng.lat);

      if (x < 0 || x > 6144 || y < 0 || y > 6144) return;

      try {
        console.log('performWalkAtLatLng: requested', {x,y});
        const formData = new URLSearchParams();
        formData.append('x', x);
        formData.append('y', y);
        // Prevent walking into non-walkable or foreign-owned regions
        try {
          const allowed = await isLatLngWalkAllowedAsync(latlng);
          if (!allowed) { alert('Cannot walk to that region.'); return; }
        } catch (e) { console.debug('region check before walk failed', e); alert('Cannot walk to that region.'); return; }

        const data = await apiCall('/player/move', {
          method: 'POST',
          body: formData
        });

        // show destination marker using server-provided destination (preferred)
        if (data.walker && data.walker.destination) {
          const dest = data.walker.destination;
          const dx = parseInt(dest[0], 10);
          const dy = parseInt(dest[1], 10);
          if (gameState.walkDestinationMarker) map.removeLayer(gameState.walkDestinationMarker);
          const goHereIcon = L.divIcon({
            className: 'custom-go-here-marker',
            html: `<div style="width:14px;height:14px;background:#ffd700;border:2px solid #fff;border-radius:50%;box-shadow:0 0 6px rgba(255,215,0,0.8);"></div>`,
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          });
          gameState.walkDestinationMarker = L.marker([totalH - dy, dx], { icon: goHereIcon, riseOnHover: true }).addTo(map);
          gameState.walkingTarget = { x: dx, y: dy };
        } else {
          // fallback: use clicked coord
          if (gameState.walkDestinationMarker) map.removeLayer(gameState.walkDestinationMarker);
          const goHereIcon = L.divIcon({
            className: 'custom-go-here-marker',
            html: `<div style="width:14px;height:14px;background:#ffd700;border:2px solid #fff;border-radius:50%;box-shadow:0 0 6px rgba(255,215,0,0.8);"></div>`,
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          });
          gameState.walkDestinationMarker = L.marker([totalH - y, x], { icon: goHereIcon, riseOnHover: true }).addTo(map);
          gameState.walkingTarget = { x, y };
        }

        console.debug('performWalkAtLatLng: started', data);
      } catch (error) {
        try {
          if (error && (error.status === 403 || String(error.message).toLowerCase().includes('cannot walk to'))) {
            window.addLogMessage(error.message || 'Cannot walk to that region.', 'error');
          } else if (error && error.message) {
            window.addLogMessage('Failed to start walking: ' + error.message, 'error');
          }
        } catch (e) { /* ignore logging failures */ }
        console.error('Failed to start walking:', error);
      }
    }

    // Load and render paths from API
    // Convert position objects/arrays (x,y) to Leaflet latlngs (global helper)
    function positionsToLatLngs(positions){
      return (positions||[]).map(p => {
        if (Array.isArray(p)) {
          return [totalH - p[1], p[0]];
        }
        return [totalH - (p.y ?? p[1] ?? 0), (p.x ?? p[0] ?? 0)];
      });
    }

    function drawWalkPath(positions) {
      // positions: array of [x,y] in raster coords
      const latlngs = positionsToLatLngs(positions || []);
      if (!latlngs || latlngs.length === 0) {
        if (gameState.walkPathPolyline) { try { map.removeLayer(gameState.walkPathPolyline); } catch (e) {} gameState.walkPathPolyline = null; }
        return;
      }
      if (gameState.walkPathPolyline) {
        try { gameState.walkPathPolyline.setLatLngs(latlngs); } catch (e) {}
      } else {
        gameState.walkPathPolyline = L.polyline(latlngs, { color: '#ffd700', weight: 3, opacity: 0.9, dashArray: '6,6' }).addTo(map);
        try { gameState.walkPathPolyline.bringToFront(); } catch (e) {}
      }
    }

    // loadAndRenderPaths moved into public/build-path.js

    function enableClickToMove() {
      // Use right-click (contextmenu) to open a small menu with actions
      map.on('contextmenu', async (e) => {
        // Prevent the browser default context menu
        if (e.originalEvent && typeof e.originalEvent.preventDefault === 'function') e.originalEvent.preventDefault();
        try {
          // Compute permission before showing menu to avoid race conditions
          __lastContextAllowed = await isLatLngWalkAllowedAsync(e.latlng);
        } catch (err) { __lastContextAllowed = false; }
        showMapContextMenuAt(e.containerPoint, e.latlng);
      });

      // Hide menu when map viewport changes
      map.on('movestart zoomstart', () => hideMapContextMenu());
      map.on('click', (e) => {
        if (gameState.buildPathMode && window.buildPath && typeof window.buildPath.onMapClick === 'function') {
          try { window.buildPath.onMapClick(e); } catch (err) { console.error(err); }
          return;
        }
        hideMapContextMenu();
      });
    }

    function startPlayerPolling() {
      // Poll every 1 second
      gameState.pollInterval = setInterval(async () => {
        try {
          // Fetch own player stats
          const posData = await apiCall('/player/position');
          gameState.health = posData.health;
          gameState.maxHealth = posData.maxHealth;
          gameState.mana = posData.mana;
          gameState.maxMana = posData.maxMana;
          gameState.damage = typeof posData.damage !== 'undefined' ? posData.damage : (gameState.damage || 0);
          gameState.armor = typeof posData.armor !== 'undefined' ? posData.armor : (gameState.armor || 0);
          // xp/level/stats
          gameState.xp = typeof posData.xp !== 'undefined' ? posData.xp : (gameState.xp || 0);
          gameState.level = typeof posData.level !== 'undefined' ? posData.level : (gameState.level || 1);
          gameState.xpToNext = typeof posData.xpToNext !== 'undefined' ? posData.xpToNext : (gameState.xpToNext || 0);
          gameState.stats = posData.stats || gameState.stats || { intelligence:20, dexterity:20, concentration:20, strength:20, constitution:20 };
          // update info panel values
          try { showPlayerInfo(); updateCharacterStats(); } catch (e) {}
          updatePlayerStats();

          // Update local player position and marker so UI reacts to server-driven walking
          if (posData.position) {
            const px = parseInt(posData.position.x, 10);
            const py = parseInt(posData.position.y, 10);
            gameState.position = { x: px, y: py };
            if (gameState.playerMarker) {
              try { gameState.playerMarker.setLatLng([totalH - py, px]); } catch (e) {}
            }

                // Build path rendering moved to public/build-path.js
            updatePlayerCoords(px, py);
            // Show or update server-provided destination marker
            if (posData.walker) {
              // show destination marker
              if (posData.walker.destination) {
                const dest = posData.walker.destination;
                const dx = parseInt(dest[0], 10);
                const dy = parseInt(dest[1], 10);
                if (!gameState.walkDestinationMarker) {
                  const goHereIcon = L.divIcon({
                    className: 'custom-go-here-marker',
                    html: `<div style="width:14px;height:14px;background:#ffd700;border:2px solid #fff;border-radius:50%;box-shadow:0 0 6px rgba(255,215,0,0.8);"></div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                  });
                  gameState.walkDestinationMarker = L.marker([totalH - dy, dx], { icon: goHereIcon, riseOnHover: true }).addTo(map).bindPopup('Walking to destination');
                } else {
                  try { gameState.walkDestinationMarker.setLatLng([totalH - dy, dx]); } catch (e) {}
                }
                gameState.walkingTarget = { x: dx, y: dy };
              }

              // draw path preview if provided
              if (posData.walker.positions) {
                try { drawWalkPath(posData.walker.positions); } catch (e) { console.debug('Failed to draw walk path', e); }
              } else {
                // no positions provided: clear polyline
                drawWalkPath(null);
              }
            } else {
              if (gameState.walkDestinationMarker) {
                try { map.removeLayer(gameState.walkDestinationMarker); } catch (e) {}
                gameState.walkDestinationMarker = null;
              }
              gameState.walkingTarget = null;
              drawWalkPath(null);
            }
          }

          // also redraw build path polyline if user is authoring
          try {
            if (gameState.buildPathPoints && gameState.buildPathPoints.length > 0) {
              try { if (window.buildPath && typeof window.buildPath.updateBuildPathPolyline === 'function') window.buildPath.updateBuildPathPolyline(); } catch(e){}
            }
          } catch (e) {}

          // Fetch other players
          const data = await apiCall('/players/online');
          updateOtherPlayers(data.players);
        } catch (error) {
          console.error('Failed to fetch online players:', error);
        }
      }, 3000);

      // Initial fetch
      apiCall('/players/online').then(data => {
        updateOtherPlayers(data.players);
      });
    }

    function updateOtherPlayers(players) {
      const realmColors = {
        syrtis: '#22c55e',
        alsius: '#3b82f6',
        ignis: '#ef4444'
      };

      // Ensure we don't have an "other player" marker for the current user
      try {
        for (const [uid, marker] of gameState.otherPlayers.entries()) {
          if (String(uid) === String(gameState.userId)) {
            map.removeLayer(marker);
            gameState.otherPlayers.delete(uid);
          }
        }
      } catch (e) {}

      const currentPlayerIds = new Set();

      players.forEach(player => {
        // Skip own player (coerce to string to avoid type-mismatch duplicates)
        if (String(player.userId) === String(gameState.userId)) return;

        currentPlayerIds.add(player.userId);

        const latLng = [totalH - player.y, player.x];
        const healthPercent = Math.max(0, Math.min(100, Math.round(((Number(player.health) || 0) / (Number(player.maxHealth) || 1)) * 100)));
        // Determine ally vs enemy (same realm = ally). Use case-insensitive compare and treat missing realm as enemy.
        const playerRealm = (player.realm || '').toString().toLowerCase();
        const myRealm = (gameState.realm || '').toString().toLowerCase();
        const isAlly = (playerRealm !== '' && myRealm !== '' && playerRealm === myRealm);
        const healthClass = isAlly ? 'health-ally' : 'health-enemy';

        if (gameState.otherPlayers.has(player.userId)) {
          // Update existing marker - remove and recreate with new health
          const oldMarker = gameState.otherPlayers.get(player.userId);
          map.removeLayer(oldMarker);
          
          const customIcon = L.divIcon({
            className: 'custom-player-marker',
            html: `
              <div style="text-align: center;">
                <div style="width: 12px; height: 12px; background: ${realmColors[playerRealm] || (isAlly ? '#22c55e' : '#ef4444')}; border: 2px solid #fff; border-radius: 50%; margin: 0 auto;"></div>
                <div class="territory-health-bar" style="margin-top: 2px;">
                  <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
                </div>
              </div>
            `,
            iconSize: [40, 20],
            iconAnchor: [20, 10]
          });
          
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(`<b>${player.username}</b><br>Realm: ${player.realm}<br>Health: ${player.health}/${player.maxHealth}`);
          gameState.otherPlayers.set(player.userId, marker);
        } else {
          // Create new marker with health bar
          const customIcon = L.divIcon({
            className: 'custom-player-marker',
            html: `
              <div style="text-align: center;">
                <div style="width: 12px; height: 12px; background: ${realmColors[playerRealm] || (isAlly ? '#22c55e' : '#ef4444')}; border: 2px solid #fff; border-radius: 50%; margin: 0 auto;"></div>
                <div class="territory-health-bar" style="margin-top: 2px;">
                  <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
                </div>
              </div>
            `,
            iconSize: [40, 20],
            iconAnchor: [20, 10]
          });

          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(`<b>${player.username}</b><br>Realm: ${player.realm}<br>Health: ${player.health}/${player.maxHealth}`);
          gameState.otherPlayers.set(player.userId, marker);
        }
      });

      // Remove markers for players no longer online
      for (const [userId, marker] of gameState.otherPlayers.entries()) {
        if (!currentPlayerIds.has(userId)) {
          map.removeLayer(marker);
          gameState.otherPlayers.delete(userId);
        }
      }
    }

    function startTerritoriesPolling() {
      // Poll every 5 seconds
      gameState.territoriesPollInterval = setInterval(async () => {
        try {
          const data = await apiCall('/territories');
          updateTerritories(data.territories);
        } catch (error) {
          console.error('Failed to fetch territories:', error);
        }
      }, 5000);

      // Initial fetch
      apiCall('/territories').then(data => {
        updateTerritories(data.territories);
      });
    }

    function updateTerritories(territories) {
      const currentTerritoryIds = new Set();

      territories.forEach(territory => {
        currentTerritoryIds.add(territory.territoryId);

        const latLng = [totalH - territory.y, territory.x];
        const isContested = territory.contested;
        
        // Determine icon key based on type, realm, and contested state
        let iconKey = '';
        if (territory.type === 'fort') {
          iconKey = `fort-${territory.ownerRealm}`;
          if (isContested) {
            iconKey += '-contested';
          }
        }
        // For castles, use fort icons
        else if (territory.type === 'castle') {
          iconKey = `fort-${territory.ownerRealm}`;
          if (isContested) {
            iconKey += '-contested';
          }
        }
        // For walls, use door icons
        else if (territory.type === 'wall') {
          iconKey = isContested ? 'door-vulnerable' : 'door-safe';
        }

        const iconData = territoryIcons[iconKey];

        if (iconData) {
          // Determine health bar color and calculate percentage
          const health = territory.health;
          const maxHealth = territory.maxHealth;
          
          const healthPercent = Math.max(0, Math.min(100, Math.round(((Number(health) || 0) / (Number(maxHealth) || 1)) * 100)));
          
          let healthClass = 'health-high';
          if (healthPercent < 30) {
            healthClass = 'health-low';
          } else if (healthPercent < 70) {
            healthClass = 'health-medium';
          }

          // Get icon URL from the icon object
          const iconUrl = iconData.options.iconUrl;

          // Create custom HTML marker with health bar
          const customIcon = L.divIcon({
            className: 'custom-territory-marker',
            html: `
              <div class="territory-marker">
                <div class="territory-icon" style="background-image: url('${iconUrl}');"></div>
                <div class="territory-health-bar">
                  <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
                </div>
              </div>
            `,
            iconSize: [40, 44],
            iconAnchor: [20, 38]
          });

          if (gameState.territories.has(territory.territoryId)) {
            // Update existing marker - remove and recreate
            const oldMarker = gameState.territories.get(territory.territoryId);
            map.removeLayer(oldMarker);
            
            const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
            const statusText = isContested ? '<div class="status-contested">âš”ï¸ Contested!</div>' : '';
            const ttHtml = `
              <div class="tooltip-title">${territory.name}</div>
              <div class="tooltip-row"><strong>Health:</strong> ${health.toLocaleString()}/${maxHealth.toLocaleString()}</div>
              ${statusText}
            `;
            marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: true, direction: 'top', offset: [0, -10] });
            gameState.territories.set(territory.territoryId, marker);
          } else {
            // Create new marker with custom icon
            const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
            const statusText = isContested ? '<div class="status-contested">âš”ï¸ Contested!</div>' : '';
            const ttHtml = `
              <div class="tooltip-title">${territory.name}</div>
              <div class="tooltip-row"><strong>Health:</strong> ${health.toLocaleString()}/${maxHealth.toLocaleString()}</div>
              ${statusText}
            `;
            marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: true, direction: 'top', offset: [0, -10] });
            gameState.territories.set(territory.territoryId, marker);
          }
        }
      });

      // Remove markers for territories no longer in response (shouldn't happen normally)
      for (const [territoryId, marker] of gameState.territories.entries()) {
        if (!currentTerritoryIds.has(territoryId)) {
          map.removeLayer(marker);
          gameState.territories.delete(territoryId);
        }
      }
    }

    function startSuperbossesPolling() {
      // Poll every 5 seconds
      gameState.superbossesPollInterval = setInterval(async () => {
        try {
          const data = await apiCall('/superbosses');
          updateSuperbosses(data.superbosses);
        } catch (error) {
          console.error('Failed to fetch superbosses:', error);
        }
      }, 5000);

      // Initial fetch
      apiCall('/superbosses').then(data => {
        updateSuperbosses(data.superbosses);
      });
    }

    function updateSuperbosses(bosses) {
      const currentBossIds = new Set();

      bosses.forEach(boss => {
        currentBossIds.add(boss.bossId);

        const latLng = [totalH - boss.y, boss.x];
        const healthPercent = Math.max(0, Math.min(100, Math.round(((Number(boss.health) || 0) / (Number(boss.maxHealth) || 1)) * 100)));
        
        let healthClass = 'health-high';
        if (healthPercent < 30) {
          healthClass = 'health-low';
        } else if (healthPercent < 70) {
          healthClass = 'health-medium';
        }

        // Determine icon based on boss name
        let iconUrl = 'assets/icons/boss-default.png';
        if (boss.name === 'Thorkul') {
          iconUrl = 'assets/icons/boss-thorkul.png';
        } else if (boss.name === 'Daen Rha') {
          iconUrl = 'assets/icons/boss-daen-rha.png';
        } else if (boss.name === 'Evendim') {
          iconUrl = 'assets/icons/boss-evendim.png';
        } else if (boss.name === 'Vesper') {
          iconUrl = 'assets/icons/boss-vesper.png';
        } else if (boss.name === 'Alasthor') {
          iconUrl = 'assets/icons/boss-alasthor.png';
        } else if (boss.name === 'Tenax') {
          iconUrl = 'assets/icons/boss-tenax.png';
        }

        // Create custom HTML marker with health bar
        const customIcon = L.divIcon({
          className: 'custom-territory-marker',
          html: `
            <div class="territory-marker">
              <div class="territory-icon" style="background-image: url('${iconUrl}');"></div>
              <div class="territory-health-bar">
                <div class="territory-health-fill" style="width: ${healthPercent}%; background-color: #ef4444; ${healthPercent > 0 ? 'min-width:2px;' : ''}"></div>
              </div>
            </div>
          `,
          iconSize: [40, 44],
          iconAnchor: [20, 38]
        });

        if (gameState.superbosses.has(boss.bossId)) {
          // Update existing marker
          const oldMarker = gameState.superbosses.get(boss.bossId);
          map.removeLayer(oldMarker);
          
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          const bossLevel = boss.level || boss.lvl || null;
          // Do not display raw coords in tooltip (clientside). Keep server coords for marker placement only.
          const respawnHtml = (typeof boss.respawnInSeconds === 'number') ? `<div class="tooltip-row"><strong>Respawn:</strong> ${formatDurationSeconds(boss.respawnInSeconds)}</div>` : '';
          const levelHtml = bossLevel ? `<div class="tooltip-row"><strong>Level:</strong> ${bossLevel}</div>` : '';
          const ttHtml = `
            <div class="tooltip-title">${boss.name}</div>
            <div class="tooltip-row"><strong>Health:</strong> ${boss.health.toLocaleString()}/${boss.maxHealth.toLocaleString()}</div>
            ${levelHtml}
            
            ${respawnHtml}
          `;
          marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: true, direction: 'top', offset: [0, -10] });
          gameState.superbosses.set(boss.bossId, marker);
        } else {
          // Create new marker
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          const bossLevel = boss.level || boss.lvl || null;
          const respawnHtml = (typeof boss.respawnInSeconds === 'number') ? `<div class="tooltip-row"><strong>Respawn:</strong> ${formatDurationSeconds(boss.respawnInSeconds)}</div>` : '';
          const levelHtml = bossLevel ? `<div class="tooltip-row"><strong>Level:</strong> ${bossLevel}</div>` : '';
          const ttHtml = `
            <div class="tooltip-title">${boss.name}</div>
            <div class="tooltip-row"><strong>Health:</strong> ${boss.health.toLocaleString()}/${boss.maxHealth.toLocaleString()}</div>
            ${levelHtml}
            ${respawnHtml}
          `;
          marker.bindTooltip(ttHtml, { className: 'info-tooltip', sticky: true, direction: 'top', offset: [0, -10] });
          gameState.superbosses.set(boss.bossId, marker);
        }
      });

      // Remove markers for bosses no longer alive
      for (const [bossId, marker] of gameState.superbosses.entries()) {
        if (!currentBossIds.has(bossId)) {
          map.removeLayer(marker);
          gameState.superbosses.delete(bossId);
        }
      }
    }

    // Auto-login if session token exists
    if (gameState.sessionToken) {
      initGame().catch(() => {
        // Session invalid, show login
        localStorage.removeItem('sessionToken');
        gameState.sessionToken = null;
      });
    }
  </script>
  <script src="build-path.js"></script>
  <style>
    .info-tooltip { background: rgba(20,20,24,0.95); color: #fff; border-radius:6px; padding:8px; font-size:13px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
    .info-tooltip .tooltip-title { font-weight:700; margin-bottom:6px; font-size:14px }
    .info-tooltip .tooltip-row { margin-bottom:4px }
    .info-tooltip .status-contested { color:#ffb4b4; font-weight:700 }
    /* UI image overlay (bottom-right) */
    #ui-image-overlay{
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 73px; /* scaled up ~30% */
      z-index: 20000;
      pointer-events: none;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
    }
    #ui-image-overlay .ui-bar-repeat{
      flex: 1 1 auto;
      height: 73px;
      background-image: url('assets/ui-v1/ui-bottom-bar-left.png');
      background-repeat: repeat-x;
      background-position: left top;
      background-size: auto 100%;
    }
    #ui-image-overlay .ui-bar-right{ flex: 0 0 auto; }
    #ui-image-overlay .ui-bar-right img{ height: 73px; display:block; pointer-events: none; }
    /* Top-right compass image */
    #ui-compass{ position: fixed; top: 0; right: 0; z-index: 20001; pointer-events: none; }
    #ui-compass img{ height: 166px; display:block; }

    /* Top-left character status (overlay) */
    #ui-character-status{ position: fixed; top: 0; left: 0; z-index: 20001; pointer-events: none; }
    #ui-character-status img{ height: 86px; width: auto; display:block; }
    #ui-character-status .ui-character-overlay{ position: absolute; top: 4px; left: 6px; right: 6px; bottom: 4px; display:flex; flex-direction:column; justify-content:flex-start; align-items:center; gap:4px; box-sizing:border-box; pointer-events: none; z-index:20002; transform: translate(-6px, -2px); }
    #ui-character-status .ui-character-overlay .status-top{ position:absolute; top:2px; left:4px; display:flex; align-items:center; gap:6px; z-index:20003; }
    #ui-character-status .ui-character-overlay .status-name{ margin-top:6px; padding-top:0; font-size:13px; color:#ffffff; font-weight:600; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; text-align:center; align-self:center; max-width:160px; text-shadow:0 1px 0 rgba(0,0,0,0.8); transform: translateX(-20px); }
    #ui-character-status .ui-character-overlay .status-bars{ display:flex; flex-direction:column; gap:1px; transform: translateX(-15px) translateY(7px); }
    /* Add padding to the level number so it sits away from top/left edges */
    #ui-character-status .ui-character-overlay .status-top #player-level{ padding-top:8px; padding-left:12px; }
    /* Username visibility */
    #ui-character-status .ui-character-overlay .status-top #player-username{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:inline-block; max-width:120px; font-weight:600; text-shadow:0 1px 0 rgba(0,0,0,0.8); color:#fff; }
    /* Use UI bar images for overlay health/mana fills and stretch them horizontally */
    #ui-character-status .ui-character-overlay .territory-health-bar{ background: transparent; border: none; }
    #ui-character-status .ui-character-overlay .territory-health-bar .territory-health-fill{ background-color: transparent; }
    /* Use border-image 9-slice style like window title/body so caps are preserved and center repeats */
    #ui-character-status .ui-character-overlay #player-health-fill{
      background-color: transparent;
      height:100%;
      border-width: 0 2px 0 2px;
      border-style: solid;
      border-image: url('assets/ui-v1/ui-bar-health.png') 0 2 0 2 fill / 0 2px 0 2px / 0 stretch;
      box-sizing: border-box;
    }
    #ui-character-status .ui-character-overlay #player-mana-fill{
      background-color: transparent;
      height:100%;
      border-width: 0 2px 0 2px;
      border-style: solid;
      border-image: url('assets/ui-v1/ui-bar-mana.png') 0 2 0 2 fill / 0 2px 0 2px / 0 stretch;
      box-sizing: border-box;
    }
    /* Nudge health/mana fills vertically: health down 1px, mana up 2px */
    #ui-character-status .ui-character-overlay #player-health-fill{ position: relative; top: -3px; }
    #ui-character-status .ui-character-overlay #player-mana-fill{ position: relative; top: -1px; }
    /* Overlay-specific bar sizing: less wide, taller */
    #ui-character-status .ui-character-overlay .overlay-bar{ flex: 0 0 auto; width: 218px; height: 15px; border-radius: 4px; overflow: hidden; }
    /* Center bar text on top of the bar */
    #ui-character-status .ui-character-overlay .overlay-bar{ position: relative; }
    #ui-character-status .ui-character-overlay .bar-text{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size:11px; color:#ffffff; text-shadow:0 1px 0 rgba(0,0,0,0.8); pointer-events: none; }
    /* hide small realm badge in the compact overlay (was showing as a green dot) */
    #ui-character-status .ui-character-overlay .status-top .realm-badge{ display:none; }

    /* Unified HUD button styles */
    .ui-hud-btn{
      position: absolute;
      bottom: 4px;
      width: 38px;
      height: 38px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center center;
      border: none;
      padding: 0;
      margin: 0;
      cursor: pointer;
      pointer-events: auto; /* allow clicks */
      z-index: 20002;
      background-color: transparent;
    }
    .ui-hud-btn[data-action="spellbook"]{ right: 303px; background-image: url('assets/ui-v1/ui-icon-spellbook-base.png'); }
    .ui-hud-btn[data-action="spellbook"]:hover{ background-image: url('assets/ui-v1/ui-icon-spellbook-hover.png'); }
    .ui-hud-btn[data-action="spellbook"]:active{ background-image: url('assets/ui-v1/ui-icon-spellbook-pressed.png'); }

    .ui-hud-btn[data-action="character"]{ right: 251px; background-image: url('assets/ui-v1/ui-icon-character-base.png'); }
    .ui-hud-btn[data-action="character"]:hover{ background-image: url('assets/ui-v1/ui-icon-character-hover.png'); }
    .ui-hud-btn[data-action="character"]:active{ background-image: url('assets/ui-v1/ui-icon-character-pressed.png'); }

    .ui-hud-btn[data-action="inventory"]{ right: 207px; background-image: url('assets/ui-v1/ui-icon-inventory-base.png'); }
    .ui-hud-btn[data-action="inventory"]:hover{ background-image: url('assets/ui-v1/ui-icon-inventory-hover.png'); }
    .ui-hud-btn[data-action="inventory"]:active{ background-image: url('assets/ui-v1/ui-icon-inventory-pressed.png'); }

    .ui-hud-btn[data-action="actions"]{ right: 164px; background-image: url('assets/ui-v1/ui-icon-actions-base.png'); }
    .ui-hud-btn[data-action="actions"]:hover{ background-image: url('assets/ui-v1/ui-icon-actions-hover.png'); }
    .ui-hud-btn[data-action="actions"]:active{ background-image: url('assets/ui-v1/ui-icon-actions-pressed.png'); }

    .ui-hud-btn[data-action="party"]{ right: 123px; background-image: url('assets/ui-v1/ui-icon-party-base.png'); }
    .ui-hud-btn[data-action="party"]:hover{ background-image: url('assets/ui-v1/ui-icon-party-hover.png'); }
    .ui-hud-btn[data-action="party"]:active{ background-image: url('assets/ui-v1/ui-icon-party-pressed.png'); }

    .ui-hud-btn[data-action="quests"]{ right: 78px; background-image: url('assets/ui-v1/ui-icon-quests-base.png'); }
    .ui-hud-btn[data-action="quests"]:hover{ background-image: url('assets/ui-v1/ui-icon-quests-hover.png'); }
    .ui-hud-btn[data-action="quests"]:active{ background-image: url('assets/ui-v1/ui-icon-quests-pressed.png'); }

    .ui-hud-btn[data-action="premium"]{ right: 34px; background-image: url('assets/ui-v1/ui-icon-premium-base.png'); }
    .ui-hud-btn[data-action="premium"]:hover{ background-image: url('assets/ui-v1/ui-icon-premium-hover.png'); }
    .ui-hud-btn[data-action="premium"]:active{ background-image: url('assets/ui-v1/ui-icon-premium-pressed.png'); }

    /* 9-slice window styling (title bar + body) */
    .ui-window{
      /* No backgrounds - pure image-based */
    }
    .ui-window-titlebar{
      height: 16px;
      padding: 0 4px;
      position: relative;
      z-index: 1;
      /* 9-slice: repeat center 10px strip horizontally (128px - 59px - 59px = 10px) */
      border-image: url('assets/ui-v1/ui-window-title-bar.png') 0 59 0 59 fill / 0 59px 0 59px / 0 repeat;
    }
    .ui-window-body{
      margin-top: -16px;
      padding-top: 16px;
      /* 9-slice: repeat center 10px horizontally and vertically (128px - 59px - 59px = 10px) */
      border-image: url('assets/ui-v1/ui-window-main.png') 59 59 59 59 fill / 59px 59px 59px 59px / 0 repeat repeat;
    }
    .ui-window-close-btn{
      width: 16px;
      height: 16px;
      padding: 0;
      border: none;
      cursor: pointer;
      background: url('assets/ui-v1/ui-window-close-base.png') center center no-repeat;
      background-size: 16px 16px;
      flex-shrink: 0;
    }
    .ui-window-close-btn:hover{
      background-image: url('assets/ui-v1/ui-window-close-hover.png');
    }
    .ui-window-close-btn:active{
      background-image: url('assets/ui-v1/ui-window-close-pressed.png');
    }
  </style>
  
  <!-- Shoutbox (Regnum window style) -->
  <div id="shoutbox-window" class="ui-window" style="position: absolute; left: 0px; bottom: 0px; width: 300px; z-index: 20005; display: flex; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
    <div id="shoutbox-header" class="ui-window-titlebar" style="display:flex; justify-content: space-between; align-items: center; user-select: none;">
      <h2 style="margin:0; flex:1; font-size:11px; font-weight:700; color:#ffffff; text-align: center;">Chat</h2>
      <button id="shoutbox-close-btn" class="ui-window-close-btn" title="Close"></button>
    </div>

    <div class="ui-window-body" style="padding:8px; display:flex; flex-direction:column; gap:4px;">
      <div id="sbMessages" style="height:140px; overflow-y:auto; overflow-x:hidden; padding:4px; background: transparent; color: #e6e6e6; font-size:13px; word-wrap: break-word; overflow-wrap: break-word;"></div>

      <div style="display:flex; gap:4px; align-items:center;">
        <input id="sbMessage" type="text" placeholder="Message" style="flex:1; background:#171717; border:1px solid #333; color:#e6e6e6; padding:4px; font-size:13px; border-radius:4px" />
        <button id="sbSend" class="btn" style="flex:0 0 auto; width:64px">Send</button>
      </div>
    </div>
  </div>

  <script>
    (async function(){
      const sbMessages = document.getElementById('sbMessages');
      const sbSend = document.getElementById('sbSend');
      const sbMessage = document.getElementById('sbMessage');
      const sbClose = document.getElementById('shoutbox-close-btn');
      const sbWin = document.getElementById('shoutbox-window');
      let currentUsername = null;
      let lastMessageId = 0;
      let lastMessageTime = 0;

      // Try server-provided username from /player/position (requires session). Fallback to stored username.
      try{
        const res = await fetch('/api/player/position', { method: 'GET', credentials: 'same-origin' });
        if (res.ok) {
          const pd = await res.json();
          if (pd && pd.success && pd.username) currentUsername = pd.username;
        }
      }catch(e){}

      try{ const u = localStorage.getItem('shoutbox.username'); if(!currentUsername && u) currentUsername = u; }catch(e){}

      sbClose.addEventListener('click', ()=>{ sbWin.style.display = 'none'; });

      function renderMessages(messages){
        sbMessages.innerHTML = '';
        messages.forEach(m=>{
          const el = document.createElement('div');
          el.style.marginBottom = '2px';
          el.style.wordWrap = 'break-word';
          el.style.overflowWrap = 'break-word';
          
          let timeStr = '';
          if(m.time) {
            try{ 
              const d = new Date(m.time * 1000);
              timeStr = d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit', hour12: false});
            }catch(e){}
          }
          
          const username = m.username || 'anon';
          let message = m.message || '';
          
          // Resize images to max 20x20 and ensure inline display
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = message;
          const imgs = tempDiv.querySelectorAll('img');
          imgs.forEach(img => {
            img.style.maxWidth = '16px';
            img.style.maxHeight = '16px';
            img.style.verticalAlign = 'middle';
            img.style.display = 'inline';
          });
          // Replace block elements with inline spans to keep everything on one line
          const blockEls = tempDiv.querySelectorAll('div, p, br');
          blockEls.forEach(b => {
            if(b.tagName === 'BR') b.replaceWith(' ');
            else { const span = document.createElement('span'); span.innerHTML = b.innerHTML; b.replaceWith(span); }
          });
          message = tempDiv.innerHTML;
          
          el.innerHTML = `<span style="opacity:0.7; font-size:11px;">[${timeStr}]</span> <span style="font-weight:700; color:#ffd27a;">${username}</span>: <span style="display:inline;">${message}</span>`;
          sbMessages.appendChild(el);
        });
        sbMessages.scrollTop = sbMessages.scrollHeight;
      }

      async function fetchMessages(){
        try{
          const headers = {};
          if (gameState && gameState.sessionToken) headers['X-Session-Token'] = gameState.sessionToken;
          const res = await fetch('/api/shoutbox', { method: 'GET', headers, credentials: 'same-origin' });
          const data = await res.json();
          if(!(data && data.success && Array.isArray(data.messages))) return;

          const msgs = data.messages;
          if(msgs.length === 0){
            // If we previously had messages, clear; otherwise nothing to do
            if(sbMessages.children.length > 0){
              renderMessages(msgs);
              lastMessageId = 0; lastMessageTime = 0;
            }
            return;
          }

          // Determine newest identifier (prefer numeric id, fallback to timestamp)
          const maxId = Math.max(...msgs.map(m => Number(m.id) || 0));
          const maxTime = Math.max(...msgs.map(m => Number(m.time) || 0));

          if(maxId > 0){
            if(maxId <= lastMessageId) return; // no new messages
            lastMessageId = maxId;
            lastMessageTime = Math.max(lastMessageTime, maxTime);
          }else{
            if(maxTime <= lastMessageTime) return; // no new messages
            lastMessageTime = maxTime;
          }

          renderMessages(msgs);
        }catch(e){ console.warn('shoutbox fetch failed', e); }
      }

      async function postMessage(){
        const message = (sbMessage.value || '').trim();
        const username = (currentUsername && currentUsername.trim()) ? currentUsername.trim() : 'anon';
        if(!message) return alert('Please enter a message');

        const form = new URLSearchParams(); form.append('message', message);
        try{
          sbSend.disabled = true;
          const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
          if(gameState.sessionToken){ headers['X-Session-Token'] = gameState.sessionToken; }
          const res = await fetch('/api/shoutbox', { method: 'POST', body: form, headers, credentials: 'same-origin' });
          const data = await res.json();
          if(data && data.success){ sbMessage.value = ''; fetchMessages(); }
          else alert(data.error || 'Failed to post');
        }catch(e){ alert('Failed to post message'); }
        finally{ sbSend.disabled = false; }
      }

      sbSend.addEventListener('click', postMessage);
      sbMessage.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); postMessage(); } });

      fetchMessages();
      const poll = setInterval(fetchMessages, 5000);
      window.addEventListener('beforeunload', ()=>clearInterval(poll));
    })();
  </script>

</body>
</html>

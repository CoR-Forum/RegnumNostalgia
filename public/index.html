<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Regnum Online Old World Map</title>

  <!-- Basic metadata -->
  <meta name="description" content="Interactive tiled map viewer for Regnum Online Old World. Pan and zoom the stitched map using Leaflet.">
  <meta name="keywords" content="Regnum Online, map, tiles, Leaflet, gaming, Old World, nostalgia">
  <meta name="author" content="Joshua Treudler">
  <meta name="robots" content="index,follow">
  <meta name="theme-color" content="#0d6efd">

  <!-- Social preview -->
  <meta property="og:title" content="Regnum Online Old World Map">
  <meta property="og:description" content="Interactive tiled map viewer for Regnum Online Old World.">
  <meta property="og:type" content="website">
  <meta property="og:image" content="assets/preview.png">
  <meta property="og:url" content="">
  <meta name="twitter:card" content="summary_large_image">

  <link rel="icon" href="assets/favicon.png" sizes="32x32">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    html,body,#map{height:100%;margin:0;padding:0}
    /* Background image shown behind tiles when panning outside bounds */
    #map{width:100vw;height:100vh; background: url('assets/background.jpg') center center / cover no-repeat}
      #coords {
        position: absolute;
        right: 12px;
        top: 12px;
        background: rgba(0,0,0,0.65);
        color: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        z-index: 1100;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        pointer-events: none;
        display: none;
      }

    /* Bottom-right author notice */
    #attribution{
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      line-height: 1;
    }
    #attribution a{ color: #fff; text-decoration: underline }
    /* Top-center logo */
    #logo{
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 8px;
      width: 200px;
      height: auto;
      z-index: 1000;
      pointer-events: none;
    }

    /* Login/Realm Modal Styles */
    #modal-overlay{
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    #modal-overlay.hidden{ display: none; }

    .modal-content{
      background: #1a1a1a;
      border: none;
      padding: 0;
      max-width: 420px;
      width: 90%;
      box-shadow: 0 4px 16px rgba(0,0,0,0.8);
      border: 1px solid #333;
      position: relative;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }
    .modal-content::before{
      display: none;
    }

    .modal-step{ display: none; }
    .modal-step.active{ display: block; }

    .modal-title{
      font-size: 11px;
      font-weight: 700;
      color: #00d9ff;
      margin: 0;
      text-align: left;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      text-shadow: none;
      text-transform: none;
      letter-spacing: 0;
      border: none;
      padding: 3px 4px;
      background: linear-gradient(180deg, #000080 0%, #1084d0 100%);
    }

    .modal-body{
      padding: 16px;
      background: #1a1a1a;
    }

    .form-group{
      margin-bottom: 14px;
    }

    .form-label{
      display: block;
      color: #e0e0e0;
      font-size: 11px;
      margin-bottom: 4px;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }

    .form-input{
      width: 100%;
      padding: 3px 4px;
      border: 1px solid #444;
      background: #2a2a2a;
      color: #e0e0e0;
      font-size: 11px;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      box-sizing: border-box;
      transition: none;
    }
    .form-input:focus{
      outline: 1px solid #0d6efd;
      outline-offset: 0;
      border-color: #0d6efd;
    }

    .btn{
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #444;
      font-size: 11px;
      font-weight: 400;
      cursor: pointer;
      transition: background 0.2s;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .btn-primary{
      background: #0d6efd;
      color: #ffffff;
      border-color: #0d6efd;
    }
    .btn-primary:hover{ background: #0a58ca; }
    .btn-primary:active{
      background: #084298;
    }
    .btn-primary:disabled{
      background: #2a2a2a;
      color: #666;
      cursor: not-allowed;
      border-color: #333;
    }

    .realm-cards{
      display: flex;
      flex-direction: row;
      gap: 8px;
      margin-top: 12px;
    }

    .realm-card{
      padding: 8px;
      border: 1px solid #444;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      background: #2a2a2a;
      color: #e0e0e0;
      flex: 1;
      text-align: center;
    }
    .realm-card:hover{
      background: #333;
      border-color: #555;
    }
    .realm-card:active{
      background: #1a1a1a;
    }

    .realm-card.syrtis{
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .realm-card.alsius{
      background: #2a2a2a;
      color: #e0e0e0;
    }
    .realm-card.ignis{
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .realm-icon{
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
    }
    .realm-icon img{
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .realm-info h3{
      margin: 0 0 2px 0;
      font-size: 11px;
      font-weight: 700;
    }
    .realm-info p{
      margin: 0;
      font-size: 11px;
      opacity: 1;
    }

    .error-message{
      background: #3a1a1a;
      color: #ff6b6b;
      padding: 8px;
      margin-bottom: 12px;
      font-size: 11px;
      border: 1px solid #661a1a;
    }
    .error-message.hidden{ display: none; }

    .loading-spinner{
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin{
      to{ transform: rotate(360deg); }
    }

    /* Player Info Panel */
    #player-info{
      position: absolute;
      left: 12px;
      top: 80px;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 0;
      font-size: 11px;
      z-index: 1000;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      min-width: 220px;
      display: none;
      box-shadow: 0 4px 16px rgba(0,0,0,0.8);
      border: 1px solid #333;
    }
    #player-info.visible{ display: block; }

    .player-name{
      font-size: 11px;
      font-weight: 700;
      margin: 0;
      padding: 3px 4px;
      display: flex;
      align-items: center;
      gap: 4px;
      background: linear-gradient(180deg, #000080 0%, #1084d0 100%);
      color: #ffffff;
    }

    .realm-badge{
      display: inline-block;
      width: 10px;
      height: 10px;
    }
    .realm-badge.syrtis{ background: #008000; }
    .realm-badge.alsius{ background: #0000ff; }
    .realm-badge.ignis{ background: #ff0000; }

    .player-info-body{
      padding: 8px;
      background: #1a1a1a;
    }

    .player-coords{
      font-size: 11px;
      color: #e0e0e0;
      margin-bottom: 8px;
    }

    .btn-logout{
      padding: 4px 8px;
      background: #2a2a2a;
      color: #e0e0e0;
      border: 1px solid #444;
      cursor: pointer;
      font-size: 11px;
      width: 100%;
      font-family: 'MS Sans Serif', Arial, sans-serif;
      transition: background 0.2s;
      text-shadow: none;
      box-shadow: none;
      margin-bottom: 4px;
    }
    .btn-logout:hover{ 
      background: #333;
    }
    .btn-logout:active{
      background: #1a1a1a;
    }

    /* Territory Health Bar Styles */
    .territory-marker{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .territory-icon{
      width: 32px;
      height: 32px;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    .territory-health-bar{
      width: 40px;
      height: 4px;
      background: rgba(0,0,0,0.5);
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .territory-health-fill{
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    .health-high{ background: #22c55e; }
    .health-medium{ background: #eab308; }
    .health-low{ background: #ef4444; }

    /* Inventory Grid Styles */
    .inventory-grid{
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border: 2px solid #1a2538;
      border-radius: 3px;
    }

    .inventory-slot{
      aspect-ratio: 1;
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
      border: 2px solid #2a3f5f;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.15s;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    }
    .inventory-slot:hover{
      border-color: #4a6f9f;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(74,111,159,0.4);
    }
    .inventory-slot.empty{
      opacity: 0.5;
    }

    .slot-icon{
      font-size: 32px;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.7));
    }

    .slot-quantity{
      position: absolute;
      bottom: 2px;
      right: 4px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      padding: 1px 4px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.2);
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .slot-rarity-border{
      position: absolute;
      inset: -2px;
      border-radius: 3px;
      pointer-events: none;
    }
    .slot-rarity-border.common{ border: 2px solid #6b7280; }
    .slot-rarity-border.uncommon{ border: 2px solid #22c55e; box-shadow: 0 0 6px rgba(34,197,94,0.3); }
    .slot-rarity-border.rare{ border: 2px solid #3b82f6; box-shadow: 0 0 6px rgba(59,130,246,0.3); }
    .slot-rarity-border.epic{ border: 2px solid #a855f7; box-shadow: 0 0 6px rgba(168,85,247,0.3); }

    .item-tooltip{
      position: fixed;
      background: #ffffe1;
      border: 1px solid #000000;
      padding: 4px 6px;
      color: #000000;
      font-size: 11px;
      z-index: 10001;
      pointer-events: none;
      box-shadow: 1px 1px 0 rgba(0,0,0,0.5);
      max-width: 200px;
      line-height: 1.3;
      font-family: 'MS Sans Serif', Arial, sans-serif;
    }
    .item-tooltip .tooltip-name{
      font-weight: 700;
      font-size: 11px;
      margin-bottom: 2px;
      color: #000000;
    }
    .item-tooltip .tooltip-type{
      font-size: 9px;
      color: #000000;
      margin-bottom: 3px;
      text-transform: capitalize;
    }
    .item-tooltip .tooltip-description{
      color: #000000;
      font-size: 9px;
      margin-bottom: 3px;
      font-style: normal;
    }
    .item-tooltip .tooltip-stats{
      font-size: 9px;
      color: #000000;
      border-top: 1px solid #808080;
      padding-top: 3px;
      margin-top: 3px;
    }
    .item-tooltip .tooltip-rarity{
      font-size: 9px;
      text-transform: uppercase;
      font-weight: 400;
      margin-top: 2px;
      color: #000000;
    }
    .item-tooltip .tooltip-rarity.common,
    .item-tooltip .tooltip-rarity.uncommon,
    .item-tooltip .tooltip-rarity.rare,
    .item-tooltip .tooltip-rarity.epic{ color: #000000; }

    /* Inventory Item Styles */
    .inventory-item{
      background: #2a2a2a;
      border: 1px solid #444;
      padding: 4px 6px;
      margin-bottom: 2px;
      display: flex;
      gap: 6px;
      align-items: center;
      transition: background 0.2s;
    }
    .inventory-item:hover{
      background: #0d6efd;
      color: #ffffff;
    }
    .inventory-item:hover .item-name,
    .inventory-item:hover .item-type,
    .inventory-item:hover .item-description,
    .inventory-item:hover .item-stats{
      color: #ffffff;
    }

    .item-icon{
      width: 24px;
      height: 24px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .item-details{
      flex: 1;
      min-width: 0;
    }

    .item-header{
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .item-name{
      font-weight: 400;
      font-size: 11px;
      color: #e0e0e0;
      margin: 0;
    }

    .item-rarity{
      font-size: 9px;
      padding: 1px 3px;
      text-transform: uppercase;
      font-weight: 400;
      letter-spacing: 0;
      background: #1a1a1a;
      color: #e0e0e0;
      border: 1px solid #444;
    }

    .item-type{
      font-size: 9px;
      color: #aaa;
      text-transform: capitalize;
    }

    .item-description{
      font-size: 9px;
      color: #bbb;
      margin: 2px 0 0 0;
      line-height: 1.3;
    }

    .item-stats{
      font-size: 9px;
      color: #22c55e;
      margin-top: 2px;
    }

    .item-quantity{
      font-size: 11px;
      color: #e0e0e0;
      font-weight: 400;
      background: #1a1a1a;
      padding: 2px 4px;
      border: 1px solid #444;
      align-self: center;
    }
  </style>
</head>
<body>
  <!-- Login/Realm Selection Modal -->
  <div id="modal-overlay">
    <div class="modal-content">
      <!-- Step 1: Login -->
      <div id="step-login" class="modal-step active">
        <h2 class="modal-title">Regnum Online - Login</h2>
        <div class="modal-body">
          <div id="login-error" class="error-message hidden"></div>
          <form id="login-form">
            <div class="form-group">
              <label class="form-label" for="username">Username</label>
              <input type="text" id="username" class="form-input" placeholder="Enter your username" required>
            </div>
            <div class="form-group">
              <label class="form-label" for="password">Password</label>
              <input type="password" id="password" class="form-input" placeholder="Enter your password" required>
            </div>
            <button type="submit" id="login-btn" class="btn btn-primary">
              <span id="login-text">Login</span>
              <span id="login-spinner" class="loading-spinner" style="display:none;"></span>
            </button>
          </form>
        </div>
      </div>

      <!-- Step 2: Realm Selection -->
      <div id="step-realm" class="modal-step">
        <h2 class="modal-title">Regnum Online - Select Realm</h2>
        <div class="modal-body">
          <p style="color:#e0e0e0;text-align:center;margin-bottom:8px;font-size:11px;">You may change your realm later</p>
          <div id="realm-error" class="error-message hidden"></div>
          <div class="realm-cards">
            <div class="realm-card syrtis" data-realm="syrtis">
              <div class="realm-icon"><img src="assets/logo-syrtis.webp" alt="Syrtis"></div>
              <div class="realm-info">
                <h3>Syrtis</h3>
                <p>The Elven Kingdom</p>
              </div>
            </div>
            <div class="realm-card alsius" data-realm="alsius">
              <div class="realm-icon"><img src="assets/logo-alsius.webp" alt="Alsius"></div>
              <div class="realm-info">
                <h3>Alsius</h3>
                <p>The Dwarven Realm</p>
              </div>
            </div>
            <div class="realm-card ignis" data-realm="ignis">
              <div class="realm-icon"><img src="assets/logo-ignis.webp" alt="Ignis"></div>
              <div class="realm-info">
                <h3>Ignis</h3>
                <p>The Human Empire</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Inventory Window -->
  <div id="inventory-window" style="position: absolute; left: 250px; top: 80px; width: 304px; max-height: 765px; background: #1a1a1a; border: 1px solid #333; box-shadow: 0 4px 16px rgba(0,0,0,0.8); z-index: 1000; display: none; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
    <div id="inventory-header" style="padding: 3px 4px; background: linear-gradient(180deg, #000080 0%, #1084d0 100%); cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none;">
      <h2 style="margin: 0; flex: 1; font-size: 11px; font-weight: 700; color: #ffffff; font-family: 'MS Sans Serif', Arial, sans-serif;">Inventory</h2>
      <button id="inventory-close-btn" style="background: #2a2a2a; border: 1px solid #444; color: #e0e0e0; font-size: 11px; cursor: pointer; padding: 0; width: 16px; height: 14px; line-height: 1; font-family: 'MS Sans Serif', Arial, sans-serif; font-weight: 700;">X</button>
    </div>
    <div id="inventory-list" style="overflow-y: auto; max-height: 695px; padding: 8px; background: #1a1a1a;">
      <div id="inventory-loading" style="text-align: center; color: #e0e0e0; padding: 40px;">
        <div class="loading-spinner" style="margin: 0 auto 12px;"></div>
        <div style="font-size: 11px;">Loading inventory...</div>
      </div>
      <div id="inventory-items" style="display: none;"></div>
      <div id="inventory-empty" style="text-align: center; color: #e0e0e0; padding: 40px; display: none; font-size: 11px;">
        Your inventory is empty
      </div>
    </div>
    <div id="inventory-footer" style="padding: 4px 8px; background: #1a1a1a; border-top: 1px solid #333; display: none;">
      <div style="display: flex; align-items: center; gap: 4px; color: #e0e0e0; font-size: 11px;">
        <span style="font-size: 14px;">üí∞</span>
        <span id="inventory-gold" style="font-weight: 400;">0 Gold</span>
      </div>
    </div>
  </div>

  <!-- Player Info Panel -->
  <div id="player-info">
    <div class="player-name">
      <span class="realm-badge"></span>
      <span id="player-username"></span>
    </div>
    <div class="player-info-body">
      <div style="margin: 6px 0;">
        <div style="display: flex; align-items: center; margin-bottom: 4px;">
          <span style="width: 45px; font-size: 11px; color: #e0e0e0;">Health:</span>
          <div class="territory-health-bar" style="flex: 1; width: auto; margin-right: 4px;">
            <div id="player-health-fill" class="territory-health-fill health-high" style="width: 100%;"></div>
          </div>
          <span id="player-health-text" style="font-size: 11px; color: #e0e0e0;">1000/1000</span>
        </div>
        <div style="display: flex; align-items: center;">
          <span style="width: 45px; font-size: 11px; color: #e0e0e0;">Mana:</span>
          <div class="territory-health-bar" style="flex: 1; width: auto; margin-right: 4px; background: rgba(59, 130, 246, 0.3); border-color: rgba(59, 130, 246, 0.5);">
            <div id="player-mana-fill" class="territory-health-fill" style="width: 100%; background: #3b82f6;"></div>
          </div>
          <span id="player-mana-text" style="font-size: 11px; color: #e0e0e0;">500/500</span>
        </div>
      </div>
      <div class="player-coords" id="player-coords">Position: 0, 0</div>
      <button class="btn-logout" id="inventory-btn" style="margin-bottom: 4px;">Inventory</button>
      <button class="btn-logout" id="logout-btn">Logout</button>
    </div>
  </div>

  <div id="map"></div>
  <div id="coords" aria-hidden="true"></div>
  <img id="logo" src="assets/regnum-logo.png" alt="Regnum logo">
  <div id="attribution" aria-label="Map author and source">
    <a href="https://github.com/CoR-Forum/RegnumMap-Nostalgia" target="_blank" rel="noopener noreferrer">GitHub</a>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Configuration: 3 rows, 3 columns, tiles named `tiles/{row}-{col}.png`
    const rows = 3, cols = 3;
    const tileUrl = (r, c) => `assets/tiles/${r}-${c}.png`;

    // Load first tile to determine tile pixel size at runtime
    const probe = new Image();
    probe.src = tileUrl(1,1);
    probe.onload = () => {
      const tileW = probe.width;
      const tileH = probe.height;

      // Original stitched image pixel size (e.g. 3 * 1024 = 3072)
      const origTotalW = cols * tileW;
      const origTotalH = rows * tileH;

      // Desired raster coordinates size. The world should behave as 6144x6144
      // while the actual stitched image is 3072x3072. scale = 6144/3072 = 2
      const scale = 2;

      // Scaled world size used by Leaflet (map coordinate units)
      totalW = origTotalW * scale;
      totalH = origTotalH * scale;

      // Use CRS.Simple so coordinates map directly to pixels
      // Disable the default zoomControl (placed top-left) so we can
      // re-add it on the right side.
      map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -3,
        maxZoom: 0,
        maxBoundsViscosity: 0.5,
        zoomControl: false
      });

      const fullBounds = [[0,0],[totalH,totalW]]; // [[y1,x1],[y2,x2]]
      map.fitBounds(fullBounds);

      // Snap back to bounds, but allow a padding buffer so users can pan slightly
      // outside before the map bounces back. Adjust `pad` (pixels) and
      // `maxBoundsViscosity` above to tune feel.
      const pad = 200 * scale; // pixels of padding outside the image (scaled)
      const paddedBounds = [[-pad, -pad], [totalH + pad, totalW + pad]];
      map.setMaxBounds(paddedBounds);

      // Helper: add markers using raster coordinates (6144x6144 space)
      // Example: addRasterMarker(x, y) where x/y are in the 6144x6144 space.
      // Y-axis: user coords have origin at top-left, Leaflet has origin at bottom-left
      function addRasterMarker(x, y, opts){
        // Leaflet expects [lat, lng] -> [y, x], and invert Y
        return L.marker([totalH - y, x], opts).addTo(map);
      }

      // Add each tile as an ImageOverlay positioned by scaled pixel bounds
      // Note: flip vertical ordering so rows 1 and 3 are swapped
      for(let r=1; r<=rows; r++){
        for(let c=1; c<=cols; c++){
          const rowPos = rows - r; // invert row index
          const y1 = rowPos * tileH * scale;
          const x1 = (c-1) * tileW * scale;
          const y2 = (rowPos + 1) * tileH * scale;
          const x2 = c * tileW * scale;
          L.imageOverlay(tileUrl(r,c), [[y1,x1],[y2,x2]]).addTo(map);
        }
      }

      L.control.scale({metric: false, imperial: false}).addTo(map);
      // Add zoom control on the right side
      L.control.zoom({ position: 'topright' }).addTo(map);

      // Load markers/shapes/icons from JSON and render them
      fetch('assets/markers.json').then(r => r.json()).then(data => {
        const icons = {};
        // Create Leaflet icons (scale sizes by `scale` so they fit raster coords)
        for(const [key, def] of Object.entries(data.icons||{})){
          const size = def.size || [24,24];
          const anchor = def.anchor || [Math.floor(size[0]/2), size[1]];
          icons[key] = L.icon({
            iconUrl: def.url,
            iconSize: [size[0], size[1]],
            iconAnchor: [anchor[0], anchor[1]]
          });
        }
        // Store icons globally for territory markers
        territoryIcons = icons;

        const layerIndex = {};
        const overlays = {};

        function toLatLng(p){ return [totalH - p[1], p[0]]; }

        for(const f of (data.features||[])){
          let layer = null;
          if(f.type === 'marker'){
            const icon = f.icon && icons[f.icon] ? icons[f.icon] : undefined;
            layer = addRasterMarker(f.x, f.y, icon ? {icon} : undefined);
          } else if(f.type === 'circle'){
            const c = toLatLng(f.center);
            layer = L.circle(c, { radius: (f.radius||50), color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polygon'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polygon(pts, { color: f.color, fillColor: f.fillColor, fillOpacity: f.fillOpacity || 0.2 }).addTo(map);
          } else if(f.type === 'polyline'){
            const pts = (f.points||[]).map(toLatLng);
            layer = L.polyline(pts, { color: f.color || '#3388ff', weight: f.weight || 3 }).addTo(map);
          } else if(f.type === 'group'){
            const members = (f.members||[]).map(id => layerIndex[id]).filter(Boolean);
            layer = L.layerGroup(members).addTo(map);
            // register group as an overlay so it can be toggled in the layer control
            overlays[f.name || f.id || ('group-' + Object.keys(overlays).length)] = layer;
          }

          if(layer){
            if(f.popup) layer.bindPopup(f.popup);
            if(f.id) layerIndex[f.id] = layer;
          }
        }
          // If any overlays (groups) were registered, add a layer control
          if(Object.keys(overlays).length > 0){
            L.control.layers(null, overlays, { collapsed: false, position: 'bottomleft' }).addTo(map);
          }
        // Coordinate readout: show raster coords (original pixel space) while hovering
        const coordsEl = document.getElementById('coords');
        if(coordsEl){
          map.on('mousemove', (e) => {
            const mapX = e.latlng.lng; // scaled x in 0..totalW
            const mapY = e.latlng.lat; // scaled y in 0..totalH (origin at bottom)
            // X: 1-based left-to-right using scaled coords
            const displayX = Math.max(1, Math.min(totalW, Math.floor(mapX) + 1));
            // Y: invert because mapY origin is bottom; top should be 1
            const displayY = Math.max(1, Math.min(totalH, Math.floor(totalH - mapY) + 1));
            coordsEl.style.display = 'block';
            coordsEl.textContent = `${displayX}x${displayY}`;
          });
          map.on('mouseout', () => { coordsEl.style.display = 'none'; });
        }
      }).catch(err => console.error('Failed to load markers.json', err));
    };

    probe.onerror = () => {
      console.error('Failed to load probe tile:', probe.src);
      document.getElementById('map').innerText = 'Failed to load tiles. Check tiles/ filenames.';
    };

    // ============================================================
    // GAME CLIENT CODE
    // ============================================================

    const API_BASE = '/api';
    
    // Global map variables (set by probe.onload)
    let map = null;
    let totalH = 0;
    let totalW = 0;
    let territoryIcons = {};
    
    let gameState = {
      sessionToken: localStorage.getItem('sessionToken'),
      userId: null,
      username: null,
      realm: null,
      position: { x: 0, y: 0 },
      health: 1000,
      maxHealth: 1000,
      mana: 500,
      maxMana: 500,
      playerMarker: null,
      otherPlayers: new Map(),
      territories: new Map(),
      superbosses: new Map(),
      pollInterval: null,
      territoriesPollInterval: null,
      superbossesPollInterval: null
    };

    // API Helper functions
    async function apiCall(endpoint, options = {}) {
      const headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...options.headers
      };

      if (gameState.sessionToken && !options.skipAuth) {
        headers['X-Session-Token'] = gameState.sessionToken;
      }

      const response = await fetch(API_BASE + endpoint, {
        ...options,
        headers
      });

      const data = await response.json();
      if (!data.success) {
        throw new Error(data.error || 'API call failed');
      }
      return data;
    }

    // Login handler
    document.getElementById('login-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      const loginBtn = document.getElementById('login-btn');
      const loginText = document.getElementById('login-text');
      const loginSpinner = document.getElementById('login-spinner');
      const errorEl = document.getElementById('login-error');

      loginBtn.disabled = true;
      loginText.style.display = 'none';
      loginSpinner.style.display = 'inline-block';
      errorEl.classList.add('hidden');

      try {
        const formData = new URLSearchParams();
        formData.append('username', username);
        formData.append('password', password);

        const data = await apiCall('/login', {
          method: 'POST',
          body: formData,
          skipAuth: true
        });

        gameState.sessionToken = data.sessionToken;
        gameState.userId = data.userId;
        gameState.username = data.username;
        gameState.realm = data.realm;

        localStorage.setItem('sessionToken', data.sessionToken);

        if (data.needsRealmSelection) {
          showRealmSelection();
        } else {
          await initGame();
        }
      } catch (error) {
        errorEl.textContent = error.message;
        errorEl.classList.remove('hidden');
        loginBtn.disabled = false;
        loginText.style.display = 'inline';
        loginSpinner.style.display = 'none';
      }
    });

    // Realm selection handler
    document.querySelectorAll('.realm-card').forEach(card => {
      card.addEventListener('click', async () => {
        const realm = card.dataset.realm;
        const errorEl = document.getElementById('realm-error');
        errorEl.classList.add('hidden');

        try {
          const formData = new URLSearchParams();
          formData.append('realm', realm);

          const data = await apiCall('/realm/select', {
            method: 'POST',
            body: formData
          });

          gameState.realm = data.realm;
          gameState.position = data.position;

          await initGame();
        } catch (error) {
          errorEl.textContent = error.message;
          errorEl.classList.remove('hidden');
        }
      });
    });

    // Inventory button handler
    document.getElementById('inventory-btn').addEventListener('click', () => {
      openInventory();
    });

    // Close inventory handler
    document.getElementById('inventory-close-btn').addEventListener('click', () => {
      closeInventory();
    });

    // Make inventory window draggable
    (function() {
      const inventoryWindow = document.getElementById('inventory-window');
      const header = document.getElementById('inventory-header');
      let isDragging = false;
      let currentX;
      let currentY;
      let initialX;
      let initialY;
      let xOffset = 0;
      let yOffset = 0;

      header.addEventListener('mousedown', dragStart);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', dragEnd);

      function dragStart(e) {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        isDragging = true;
      }

      function drag(e) {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          xOffset = currentX;
          yOffset = currentY;
          setTranslate(currentX, currentY, inventoryWindow);
        }
      }

      function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
      }

      function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
      }
    })();

    // Logout handler
    document.getElementById('logout-btn').addEventListener('click', () => {
      localStorage.removeItem('sessionToken');
      gameState.sessionToken = null;
      if (gameState.pollInterval) {
        clearInterval(gameState.pollInterval);
      }
      if (gameState.territoriesPollInterval) {
        clearInterval(gameState.territoriesPollInterval);
      }
      if (gameState.superbossesPollInterval) {
        clearInterval(gameState.superbossesPollInterval);
      }
      location.reload();
    });

    function showRealmSelection() {
      document.getElementById('step-login').classList.remove('active');
      document.getElementById('step-realm').classList.add('active');
    }

    async function openInventory() {
      const window = document.getElementById('inventory-window');
      window.style.display = 'flex';
      document.getElementById('inventory-loading').style.display = 'block';
      document.getElementById('inventory-items').style.display = 'none';
      document.getElementById('inventory-empty').style.display = 'none';

      try {
        const data = await apiCall('/inventory');
        displayInventory(data.items);
      } catch (error) {
        console.error('Failed to fetch inventory:', error);
        alert('Failed to load inventory: ' + error.message);
        closeInventory();
      }
    }

    function closeInventory() {
      document.getElementById('inventory-window').style.display = 'none';
    }

    function displayInventory(items) {
      document.getElementById('inventory-loading').style.display = 'none';

      const container = document.getElementById('inventory-items');
      const footer = document.getElementById('inventory-footer');
      container.innerHTML = '';

      if (items.length === 0) {
        document.getElementById('inventory-empty').style.display = 'block';
        footer.style.display = 'none';
        return;
      }

      document.getElementById('inventory-items').style.display = 'block';
      footer.style.display = 'flex';

      // Icon mapping
      const iconMap = {
        weapon: '‚öîÔ∏è',
        armor: 'üõ°Ô∏è',
        consumable: 'üß™',
        currency: 'üí∞',
        misc: 'üì¶'
      };

      // Calculate total gold
      let totalGold = 0;

      // Render items as list
      items.forEach(item => {
        // Track gold
        if (item.itemName === 'Gold Coin') {
          totalGold += item.quantity;
        }

        const itemDiv = document.createElement('div');
        itemDiv.className = 'inventory-item';

        const icon = iconMap[item.itemType] || 'üì¶';

        itemDiv.innerHTML = `
          <div class="item-icon">${icon}</div>
          <div class="item-details">
            <div class="item-header">
              <h4 class="item-name">${item.itemName}</h4>
              <span class="item-rarity ${item.rarity}">${item.rarity}</span>
            </div>
            <div class="item-type">${item.itemType}</div>
            ${item.description ? `<div class="item-description">${item.description}</div>` : ''}
            ${item.stats && Object.keys(item.stats).length > 0 ? `<div class="item-stats">Stats: ${Object.entries(item.stats).map(([k, v]) => `+${v} ${k.replace('_', ' ')}`).join(', ')}</div>` : ''}
          </div>
          ${item.quantity > 1 ? `<div class="item-quantity">√ó${item.quantity}</div>` : ''}
        `;

        // Tooltip on hover
        itemDiv.addEventListener('mouseenter', (e) => showTooltip(e, item));
        itemDiv.addEventListener('mouseleave', hideTooltip);
        itemDiv.addEventListener('mousemove', (e) => moveTooltip(e));

        container.appendChild(itemDiv);
      });
      
      // Update gold display
      document.getElementById('inventory-gold').textContent = `${totalGold.toLocaleString()} Gold`;
    }

    let currentTooltip = null;

    function showTooltip(event, item) {
      hideTooltip();
      
      const tooltip = document.createElement('div');
      tooltip.className = 'item-tooltip';
      
      // Format stats
      let statsHtml = '';
      if (item.stats && Object.keys(item.stats).length > 0) {
        const statsParts = Object.entries(item.stats).map(([key, value]) => {
          return `+${value} ${key.replace('_', ' ')}`;
        });
        statsHtml = `<div class="tooltip-stats">${statsParts.join('<br>')}</div>`;
      }
      
      tooltip.innerHTML = `
        <div class="tooltip-name">${item.itemName}</div>
        <div class="tooltip-type">${item.itemType}</div>
        ${item.description ? `<div class="tooltip-description">"${item.description}"</div>` : ''}
        ${statsHtml}
        <div class="tooltip-rarity ${item.rarity}">${item.rarity}</div>
      `;
      
      document.body.appendChild(tooltip);
      currentTooltip = tooltip;
      moveTooltip(event);
    }

    function moveTooltip(event) {
      if (!currentTooltip) return;
      const offsetX = 15;
      const offsetY = 15;
      currentTooltip.style.left = (event.clientX + offsetX) + 'px';
      currentTooltip.style.top = (event.clientY + offsetY) + 'px';
    }

    function hideTooltip() {
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
      }
    }

    function hideModal() {
      document.getElementById('modal-overlay').classList.add('hidden');
    }

    function showPlayerInfo() {
      const panel = document.getElementById('player-info');
      const usernameEl = document.getElementById('player-username');
      const realmBadge = panel.querySelector('.realm-badge');

      usernameEl.textContent = gameState.username;
      realmBadge.className = `realm-badge ${gameState.realm}`;
      panel.classList.add('visible');
    }

    function updatePlayerStats() {
      // Update health bar
      const healthPercent = (gameState.health / gameState.maxHealth) * 100;
      const healthFill = document.getElementById('player-health-fill');
      const healthText = document.getElementById('player-health-text');
      
      healthFill.style.width = `${healthPercent}%`;
      healthText.textContent = `${gameState.health}/${gameState.maxHealth}`;
      
      // Update health color
      healthFill.className = 'territory-health-fill';
      if (healthPercent < 30) {
        healthFill.classList.add('health-low');
      } else if (healthPercent < 70) {
        healthFill.classList.add('health-medium');
      } else {
        healthFill.classList.add('health-high');
      }

      // Update mana bar
      const manaPercent = (gameState.mana / gameState.maxMana) * 100;
      const manaFill = document.getElementById('player-mana-fill');
      const manaText = document.getElementById('player-mana-text');
      
      manaFill.style.width = `${manaPercent}%`;
      manaText.textContent = `${gameState.mana}/${gameState.maxMana}`;
    }

    function updatePlayerCoords(x, y) {
      document.getElementById('player-coords').textContent = `Position: ${x}, ${y}`;
    }

    // Initialize game after login/realm selection
    async function initGame() {
      try {
        // Get current position
        const data = await apiCall('/player/position');
        gameState.position = data.position;
        gameState.realm = data.realm;
        gameState.health = data.health;
        gameState.maxHealth = data.maxHealth;
        gameState.mana = data.mana;
        gameState.maxMana = data.maxMana;

        hideModal();
        showPlayerInfo();
        updatePlayerStats();

        // Create player marker
        createPlayerMarker(gameState.position.x, gameState.position.y);

        // Enable click-to-move
        enableClickToMove();

        // Start polling for other players
        startPlayerPolling();

        // Start polling for territories
        startTerritoriesPolling();

        // Start polling for superbosses
        startSuperbossesPolling();

        updatePlayerCoords(gameState.position.x, gameState.position.y);
      } catch (error) {
        console.error('Failed to initialize game:', error);
        alert('Failed to initialize game: ' + error.message);
        localStorage.removeItem('sessionToken');
        location.reload();
      }
    }

    function createPlayerMarker(x, y) {
      if (gameState.playerMarker) {
        map.removeLayer(gameState.playerMarker);
      }

      const realmColors = {
        syrtis: '#22c55e',
        alsius: '#3b82f6',
        ignis: '#ef4444'
      };

      const latLng = [totalH - y, x];
      gameState.playerMarker = L.circleMarker(latLng, {
        radius: 8,
        fillColor: realmColors[gameState.realm],
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
      }).addTo(map);

      gameState.playerMarker.bindPopup(`<b>${gameState.username}</b><br>Realm: ${gameState.realm}`);
      map.setView(latLng, map.getZoom());
    }

    function enableClickToMove() {
      map.on('click', async (e) => {
        const x = Math.round(e.latlng.lng);
        const y = Math.round(totalH - e.latlng.lat);

        // Validate bounds
        if (x < 0 || x > 6144 || y < 0 || y > 6144) return;

        try {
          const formData = new URLSearchParams();
          formData.append('x', x);
          formData.append('y', y);

          await apiCall('/player/position', {
            method: 'POST',
            body: formData
          });

          gameState.position = { x, y };
          gameState.playerMarker.setLatLng([totalH - y, x]);
          updatePlayerCoords(x, y);
        } catch (error) {
          console.error('Failed to update position:', error);
        }
      });
    }

    function startPlayerPolling() {
      // Poll every 1 second
      gameState.pollInterval = setInterval(async () => {
        try {
          // Fetch own player stats
          const posData = await apiCall('/player/position');
          gameState.health = posData.health;
          gameState.maxHealth = posData.maxHealth;
          gameState.mana = posData.mana;
          gameState.maxMana = posData.maxMana;
          updatePlayerStats();

          // Fetch other players
          const data = await apiCall('/players/online');
          updateOtherPlayers(data.players);
        } catch (error) {
          console.error('Failed to fetch online players:', error);
        }
      }, 3000);

      // Initial fetch
      apiCall('/players/online').then(data => {
        updateOtherPlayers(data.players);
      });
    }

    function updateOtherPlayers(players) {
      const realmColors = {
        syrtis: '#22c55e',
        alsius: '#3b82f6',
        ignis: '#ef4444'
      };

      const currentPlayerIds = new Set();

      players.forEach(player => {
        // Skip own player
        if (player.userId === gameState.userId) return;

        currentPlayerIds.add(player.userId);

        const latLng = [totalH - player.y, player.x];
        const healthPercent = (player.health / player.maxHealth) * 100;
        let healthClass = 'health-high';
        if (healthPercent < 30) {
          healthClass = 'health-low';
        } else if (healthPercent < 70) {
          healthClass = 'health-medium';
        }

        if (gameState.otherPlayers.has(player.userId)) {
          // Update existing marker - remove and recreate with new health
          const oldMarker = gameState.otherPlayers.get(player.userId);
          map.removeLayer(oldMarker);
          
          const customIcon = L.divIcon({
            className: 'custom-player-marker',
            html: `
              <div style="text-align: center;">
                <div style="width: 12px; height: 12px; background: ${realmColors[player.realm]}; border: 2px solid #fff; border-radius: 50%; margin: 0 auto;"></div>
                <div class="territory-health-bar" style="margin-top: 2px;">
                  <div class="territory-health-fill ${healthClass}" style="width: ${healthPercent}%;"></div>
                </div>
              </div>
            `,
            iconSize: [40, 20],
            iconAnchor: [20, 10]
          });
          
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(`<b>${player.username}</b><br>Realm: ${player.realm}<br>Health: ${player.health}/${player.maxHealth}`);
          gameState.otherPlayers.set(player.userId, marker);
        } else {
          // Create new marker with health bar
          const customIcon = L.divIcon({
            className: 'custom-player-marker',
            html: `
              <div style="text-align: center;">
                <div style="width: 12px; height: 12px; background: ${realmColors[player.realm]}; border: 2px solid #fff; border-radius: 50%; margin: 0 auto;"></div>
                <div class="territory-health-bar" style="margin-top: 2px;">
                  <div class="territory-health-fill ${healthClass}" style="width: ${healthPercent}%;"></div>
                </div>
              </div>
            `,
            iconSize: [40, 20],
            iconAnchor: [20, 10]
          });

          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(`<b>${player.username}</b><br>Realm: ${player.realm}<br>Health: ${player.health}/${player.maxHealth}`);
          gameState.otherPlayers.set(player.userId, marker);
        }
      });

      // Remove markers for players no longer online
      for (const [userId, marker] of gameState.otherPlayers.entries()) {
        if (!currentPlayerIds.has(userId)) {
          map.removeLayer(marker);
          gameState.otherPlayers.delete(userId);
        }
      }
    }

    function startTerritoriesPolling() {
      // Poll every 5 seconds
      gameState.territoriesPollInterval = setInterval(async () => {
        try {
          const data = await apiCall('/territories');
          updateTerritories(data.territories);
        } catch (error) {
          console.error('Failed to fetch territories:', error);
        }
      }, 5000);

      // Initial fetch
      apiCall('/territories').then(data => {
        updateTerritories(data.territories);
      });
    }

    function updateTerritories(territories) {
      const currentTerritoryIds = new Set();

      territories.forEach(territory => {
        currentTerritoryIds.add(territory.territoryId);

        const latLng = [totalH - territory.y, territory.x];
        const isContested = territory.contested;
        
        // Determine icon key based on type, realm, and contested state
        let iconKey = '';
        if (territory.type === 'fort') {
          iconKey = `fort-${territory.ownerRealm}`;
          if (isContested) {
            iconKey += '-contested';
          }
        }
        // For castles, use fort icons
        else if (territory.type === 'castle') {
          iconKey = `fort-${territory.ownerRealm}`;
          if (isContested) {
            iconKey += '-contested';
          }
        }
        // For walls, use door icons
        else if (territory.type === 'wall') {
          iconKey = isContested ? 'door-vulnerable' : 'door-safe';
        }

        const iconData = territoryIcons[iconKey];

        if (iconData) {
          // Determine health bar color and calculate percentage
          const health = territory.health;
          const maxHealth = territory.maxHealth;
          
          const healthPercent = Math.round((health / maxHealth) * 100);
          
          let healthClass = 'health-high';
          if (healthPercent < 30) {
            healthClass = 'health-low';
          } else if (healthPercent < 70) {
            healthClass = 'health-medium';
          }

          // Get icon URL from the icon object
          const iconUrl = iconData.options.iconUrl;

          // Create custom HTML marker with health bar
          const customIcon = L.divIcon({
            className: 'custom-territory-marker',
            html: `
              <div class="territory-marker">
                <div class="territory-icon" style="background-image: url('${iconUrl}');"></div>
                <div class="territory-health-bar">
                  <div class="territory-health-fill ${healthClass}" style="width: ${healthPercent}%;"></div>
                </div>
              </div>
            `,
            iconSize: [40, 44],
            iconAnchor: [20, 38]
          });

          if (gameState.territories.has(territory.territoryId)) {
            // Update existing marker - remove and recreate
            const oldMarker = gameState.territories.get(territory.territoryId);
            map.removeLayer(oldMarker);
            
            const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
            const statusText = isContested ? '<br><span style="color:#ef4444">‚öîÔ∏è Contested!</span>' : '';
            marker.bindTooltip(`<b>${territory.name}</b><br>Health: ${health.toLocaleString()}/${maxHealth.toLocaleString()}${statusText}`, {
              permanent: false,
              direction: 'top'
            });
            gameState.territories.set(territory.territoryId, marker);
          } else {
            // Create new marker with custom icon
            const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
            const statusText = isContested ? '<br><span style="color:#ef4444">‚öîÔ∏è Contested!</span>' : '';
            marker.bindTooltip(`<b>${territory.name}</b><br>Health: ${health.toLocaleString()}/${maxHealth.toLocaleString()}${statusText}`, {
              permanent: false,
              direction: 'top'
            });
            gameState.territories.set(territory.territoryId, marker);
          }
        }
      });

      // Remove markers for territories no longer in response (shouldn't happen normally)
      for (const [territoryId, marker] of gameState.territories.entries()) {
        if (!currentTerritoryIds.has(territoryId)) {
          map.removeLayer(marker);
          gameState.territories.delete(territoryId);
        }
      }
    }

    function startSuperbossesPolling() {
      // Poll every 5 seconds
      gameState.superbossesPollInterval = setInterval(async () => {
        try {
          const data = await apiCall('/superbosses');
          updateSuperbosses(data.superbosses);
        } catch (error) {
          console.error('Failed to fetch superbosses:', error);
        }
      }, 5000);

      // Initial fetch
      apiCall('/superbosses').then(data => {
        updateSuperbosses(data.superbosses);
      });
    }

    function updateSuperbosses(bosses) {
      const currentBossIds = new Set();

      bosses.forEach(boss => {
        currentBossIds.add(boss.bossId);

        const latLng = [totalH - boss.y, boss.x];
        const healthPercent = Math.round((boss.health / boss.maxHealth) * 100);
        
        let healthClass = 'health-high';
        if (healthPercent < 30) {
          healthClass = 'health-low';
        } else if (healthPercent < 70) {
          healthClass = 'health-medium';
        }

        // Determine icon based on boss name
        let iconUrl = 'assets/icons/boss-default.png';
        if (boss.name === 'Thorkul') {
          iconUrl = 'assets/icons/boss-thorkul.png';
        } else if (boss.name === 'Daen Rha') {
          iconUrl = 'assets/icons/boss-daen-rha.png';
        } else if (boss.name === 'Evendim') {
          iconUrl = 'assets/icons/boss-evendim.png';
        } else if (boss.name === 'Vesper') {
          iconUrl = 'assets/icons/boss-vesper.png';
        } else if (boss.name === 'Alasthor') {
          iconUrl = 'assets/icons/boss-alasthor.png';
        } else if (boss.name === 'Tenax') {
          iconUrl = 'assets/icons/boss-tenax.png';
        }

        // Create custom HTML marker with health bar
        const customIcon = L.divIcon({
          className: 'custom-territory-marker',
          html: `
            <div class="territory-marker">
              <div class="territory-icon" style="background-image: url('${iconUrl}');"></div>
              <div class="territory-health-bar">
                <div class="territory-health-fill ${healthClass}" style="width: ${healthPercent}%;"></div>
              </div>
            </div>
          `,
          iconSize: [40, 44],
          iconAnchor: [20, 38]
        });

        if (gameState.superbosses.has(boss.bossId)) {
          // Update existing marker
          const oldMarker = gameState.superbosses.get(boss.bossId);
          map.removeLayer(oldMarker);
          
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindTooltip(`<b>${boss.name}</b><br>Health: ${boss.health.toLocaleString()}/${boss.maxHealth.toLocaleString()}`, {
            permanent: false,
            direction: 'top'
          });
          gameState.superbosses.set(boss.bossId, marker);
        } else {
          // Create new marker
          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindTooltip(`<b>${boss.name}</b><br>Health: ${boss.health.toLocaleString()}/${boss.maxHealth.toLocaleString()}`, {
            permanent: false,
            direction: 'top'
          });
          gameState.superbosses.set(boss.bossId, marker);
        }
      });

      // Remove markers for bosses no longer alive
      for (const [bossId, marker] of gameState.superbosses.entries()) {
        if (!currentBossIds.has(bossId)) {
          map.removeLayer(marker);
          gameState.superbosses.delete(bossId);
        }
      }
    }

    // Auto-login if session token exists
    if (gameState.sessionToken) {
      initGame().catch(() => {
        // Session invalid, show login
        localStorage.removeItem('sessionToken');
        gameState.sessionToken = null;
      });
    }
  </script>
  
</body>
</html>

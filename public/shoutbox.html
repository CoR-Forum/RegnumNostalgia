<style>
/* Dark scrollbar class is defined in index.html */
</style>

<div id="shoutbox-window" class="ui-window" style="position: absolute; left: 0px; bottom: 52px; width: 240px; z-index: 20005; display: flex; flex-direction: column; font-family: 'MS Sans Serif', Arial, sans-serif;">
  <div id="shoutbox-header" class="ui-window-titlebar" style="display:flex; justify-content: space-between; align-items: center; user-select: none;">
    <h2 style="margin:0; flex:1; font-size:11px; font-weight:700; color:#ffffff; text-align: center;">Chat</h2>
    <button id="shoutbox-close-btn" class="ui-window-close-btn" title="Close"></button>
  </div>

  <div class="ui-window-body" style="padding:8px; display:flex; flex-direction:column; gap:4px;">
    <!-- Log section (30%) -->
    <div style="display:flex; flex-direction:column; gap:4px;">
      <div style="font-size:11px; font-weight:700; color:#ffd27a; opacity:0.9; padding-top:8px;">Log</div>
      <div id="logMessages" class="dark-scrollbar" style="height:60px; overflow-y:auto; overflow-x:hidden; padding:4px; background: rgba(0,0,0,0.2); color: #e6e6e6; font-size:12px; word-wrap: break-word; overflow-wrap: break-word; border: 1px solid rgba(255,255,255,0.1); border-radius:4px;"></div>
    </div>

    <!-- Chat section (70%) -->
    <div style="display:flex; flex-direction:column; gap:4px;">
      <div style="font-size:11px; font-weight:700; color:#ffd27a; opacity:0.9;">Chat</div>
      <div id="sbMessages" class="dark-scrollbar" style="height:120px; overflow-y:auto; overflow-x:hidden; padding:4px; background: transparent; color: #e6e6e6; font-size:13px; word-wrap: break-word; overflow-wrap: break-word;"></div>
    </div>

    <div style="display:flex; gap:4px; align-items:center;">
      <input id="sbMessage" type="text" placeholder="Message" style="flex:1; background: rgba(255,255,255,0.18); border: 1px solid rgba(255,255,255,0.22); color:#e6e6e6; padding:6px; font-size:13px; border-radius:4px" />
      <button id="sbSend" class="btn" style="flex:0 0 auto; width:64px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.16); color:#e6e6e6; padding:6px 8px; border-radius:4px">Send</button>
    </div>
  </div>
</div>

<script>
  (async function(){
    const sbMessages = document.getElementById('sbMessages');
    const logMessages = document.getElementById('logMessages');
    const sbSend = document.getElementById('sbSend');
    const sbMessage = document.getElementById('sbMessage');
    const sbWin = document.getElementById('shoutbox-window');
    let currentUsername = null;
    let lastMessageId = 0;
    let lastMessageTime = 0;

    // UI windows persistence helpers (store visibility in localStorage.uiWindows)
    function loadUIWindows(){
      try{ return JSON.parse(localStorage.getItem('uiWindows') || '{}'); }catch(e){ return {}; }
    }
    function saveUIWindows(obj){
      try{ localStorage.setItem('uiWindows', JSON.stringify(obj)); }catch(e){}
    }
    function setUIWindowVisible(id, visible){
      const u = loadUIWindows();
      const cur = u[id];
      // If an object shape is already stored, preserve other fields and update open/display
      if (cur && typeof cur === 'object') {
        cur.open = !!visible;
        cur.display = !!visible ? 'flex' : 'none';
        u[id] = cur;
      } else {
        u[id] = !!visible;
      }
      saveUIWindows(u);
    }

    try{
      const socket = window.getSocket && window.getSocket();
      if (socket && socket.connected) {
        socket.emit('player:stats:get', (resp) => {
          if (resp && resp.success && resp.state && resp.state.username) currentUsername = resp.state.username;
        });
      } else {
        // Do not call REST; wait for WebSocket connection if needed
        window.addEventListener('websocket:connected', function onConn() {
          window.removeEventListener('websocket:connected', onConn);
          const s = window.getSocket && window.getSocket();
          if (s && s.connected) {
            s.emit('player:stats:get', (resp) => {
              if (resp && resp.success && resp.state && resp.state.username) currentUsername = resp.state.username;
            });
          }
        });
      }
    }catch(e){}

    try{ const u = localStorage.getItem('shoutbox.username'); if(!currentUsername && u) currentUsername = u; }catch(e){}

    // ==================== LOG MESSAGES ====================
    
    function renderLogMessages(logs){
      logMessages.innerHTML = '';
      const toShow = (logs || []).slice(-50);
      toShow.forEach(log => {
        const el = document.createElement('div');
        el.style.marginBottom = '2px';
        el.style.wordWrap = 'break-word';
        el.style.overflowWrap = 'break-word';
        
        let timeStr = '';
        if(log.createdAt) {
          try{ 
            const d = new Date(log.createdAt * 1000);
            timeStr = d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit', hour12: false});
          }catch(e){}
        }
        
        let typeColor = '#9ecbff';
        if (log.logType === 'success') typeColor = '#7ed321';
        else if (log.logType === 'error') typeColor = '#ff4757';
        else if (log.logType === 'warning') typeColor = '#ffa502';
        else if (log.logType === 'combat') typeColor = '#ff6348';
        
        el.innerHTML = `<span style="opacity:0.7; font-size:10px;">[${timeStr}]</span> <span style="color:${typeColor};">${log.message}</span>`;
        logMessages.appendChild(el);
      });
      logMessages.scrollTop = logMessages.scrollHeight;
    }

    function fetchLogMessages(){
      const socket = window.getSocket && window.getSocket();
      if (!socket || !socket.connected) {
        console.warn('WebSocket not connected for log fetch');
        return;
      }

      socket.emit('log:get', {}, (response) => {
        if (response && response.success && Array.isArray(response.logs)) {
          renderLogMessages(response.logs);
        } else {
          console.warn('Failed to fetch log messages:', response?.error);
        }
      });
    }

    // Listen for incoming log messages
    window.onLogMessage = function(data) {
      if (data && data.message) {
        const log = {
          logId: data.logId || 0,
          createdAt: data.createdAt || Math.floor(Date.now() / 1000),
          message: data.message,
          logType: data.logType || 'info'
        };
        
        // Append new log message
        const el = document.createElement('div');
        el.style.marginBottom = '2px';
        el.style.wordWrap = 'break-word';
        el.style.overflowWrap = 'break-word';
        
        let timeStr = '';
        if(log.createdAt) {
          try{ 
            const d = new Date(log.createdAt * 1000);
            timeStr = d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit', hour12: false});
          }catch(e){}
        }
        
        let typeColor = '#9ecbff';
        if (log.logType === 'success') typeColor = '#7ed321';
        else if (log.logType === 'error') typeColor = '#ff4757';
        else if (log.logType === 'warning') typeColor = '#ffa502';
        else if (log.logType === 'combat') typeColor = '#ff6348';
        
        el.innerHTML = `<span style="opacity:0.7; font-size:10px;">[${timeStr}]</span> <span style="color:${typeColor};">${log.message}</span>`;
        logMessages.appendChild(el);
        
        // Keep max 50 log entries
        while (logMessages.children.length > 50) logMessages.removeChild(logMessages.firstChild);
        logMessages.scrollTop = logMessages.scrollHeight;
      }
    };

    // ==================== CHAT MESSAGES ====================
    
    function scrollToBottom() {
      sbMessages.scrollTop = sbMessages.scrollHeight;
    }

    // Aggressively ensure scroll stays at bottom for 2 seconds
    // This handles layout shifts from external CSS assets, border-images, etc.
    let _scrollInterval = null;
    function ensureScrolledToBottom() {
      scrollToBottom();
      if (_scrollInterval) clearInterval(_scrollInterval);
      let attempts = 0;
      _scrollInterval = setInterval(() => {
        scrollToBottom();
        if (++attempts >= 20) { clearInterval(_scrollInterval); _scrollInterval = null; }
      }, 100);
    }

    function renderMessages(messages){
      sbMessages.innerHTML = '';
      // Ensure we never render more than 50 messages
      const toShow = (messages || []).slice(-50);
      toShow.forEach(m=>{
        const el = document.createElement('div');
        el.style.marginBottom = '2px';
        el.style.wordWrap = 'break-word';
        el.style.overflowWrap = 'break-word';
        
        let timeStr = '';
        if(m.time) {
          try{ 
            const d = new Date(m.time * 1000);
            timeStr = d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit', hour12: false});
          }catch(e){}
        }
        
        const username = m.username || 'anon';
        let message = m.message || '';
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = message;
        const imgs = tempDiv.querySelectorAll('img');
        imgs.forEach(img => {
          img.style.maxWidth = '16px';
          img.style.maxHeight = '16px';
          img.style.verticalAlign = 'middle';
          img.style.display = 'inline';
        });
        const blockEls = tempDiv.querySelectorAll('div, p, br');
        blockEls.forEach(b => {
          if(b.tagName === 'BR') b.replaceWith(' ');
          else { const span = document.createElement('span'); span.innerHTML = b.innerHTML; b.replaceWith(span); }
        });
        message = tempDiv.innerHTML;
        
        el.innerHTML = `<span style="opacity:0.7; font-size:11px;">[${timeStr}]</span> <span style="font-weight:700; color:#ffd27a;">${username}</span>: <span style="display:inline;">${message}</span>`;
        sbMessages.appendChild(el);
      });
      ensureScrolledToBottom();
    }

    function fetchMessages(){
      const socket = window.getSocket && window.getSocket();
      if (!socket || !socket.connected) {
        console.warn('WebSocket not connected, will retry when connected');
        return;
      }

      socket.emit('shoutbox:get', {}, (response) => {
        if (response && response.success && Array.isArray(response.messages)) {
          const msgs = response.messages;
          
          if(msgs.length === 0){
            if(sbMessages.children.length > 0){
              renderMessages(msgs);
              lastMessageId = 0; 
              lastMessageTime = 0;
            }
            return;
          }

          const maxId = Math.max(...msgs.map(m => Number(m.entryId) || 0));
          const maxTime = Math.max(...msgs.map(m => Number(m.time) || 0));

          if(maxId > 0){
            if(maxId <= lastMessageId) return;
            lastMessageId = maxId;
            lastMessageTime = Math.max(lastMessageTime, maxTime);
          }else{
            if(maxTime <= lastMessageTime) return;
            lastMessageTime = maxTime;
          }

          renderMessages(msgs);
        } else {
          console.warn('Failed to fetch messages:', response?.error);
        }
      });
    }

    async function postMessage(){
      const message = (sbMessage.value || '').trim();
      const username = (currentUsername && currentUsername.trim()) ? currentUsername.trim() : 'anon';
      if(!message) return;

      const socket = window.getSocket && window.getSocket();
      if (!socket || !socket.connected) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      try {
        sbSend.disabled = true;
        socket.emit('shoutbox:send', { message }, (response) => {
          if (response && response.success) {
            sbMessage.value = '';
            // Display the sent message immediately
            if (response.message && window.onShoutboxMessage) {
              window.onShoutboxMessage(response.message);
            }
          } else {
            alert(response?.error || 'Failed to post message');
          }
          sbSend.disabled = false;
        });
      } catch (e) {
        console.error('Failed to send message:', e);
        alert('Failed to send message');
        sbSend.disabled = false;
      }
    }

    sbSend.addEventListener('click', postMessage);
    sbMessage.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); postMessage(); } });

    // WebSocket event handler for incoming shoutbox messages
    window.onShoutboxMessage = function(data) {
      if (data && data.message) {
        const msg = {
          entryID: data.entryID || 0,
          time: data.time || Math.floor(Date.now() / 1000),
          username: data.username || 'anon',
          message: data.message
        };
        
        // Update last message tracking
        if (msg.entryID > lastMessageId) lastMessageId = msg.entryID;
        if (msg.time > lastMessageTime) lastMessageTime = msg.time;
        
        // Append new message (keep at most 50 messages visible)
        const el = document.createElement('div');
        el.style.marginBottom = '2px';
        el.style.wordWrap = 'break-word';
        el.style.overflowWrap = 'break-word';
        
        let timeStr = '';
        if(msg.time) {
          try{ 
            const d = new Date(msg.time * 1000);
            timeStr = d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit', hour12: false});
          }catch(e){}
        }
        
        let message = msg.message || '';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = message;
        const imgs = tempDiv.querySelectorAll('img');
        imgs.forEach(img => {
          img.style.maxWidth = '16px';
          img.style.maxHeight = '16px';
          img.style.verticalAlign = 'middle';
          img.style.display = 'inline';
        });
        const blockEls = tempDiv.querySelectorAll('div, p, br');
        blockEls.forEach(b => {
          if(b.tagName === 'BR') b.replaceWith(' ');
          else { const span = document.createElement('span'); span.innerHTML = b.innerHTML; b.replaceWith(span); }
        });
        message = tempDiv.innerHTML;
        
        el.innerHTML = `<span style="opacity:0.7; font-size:11px;">[${timeStr}]</span> <span style="font-weight:700; color:#ffd27a;">${msg.username}</span>: <span style="display:inline;">${message}</span>`;
        sbMessages.appendChild(el);
        // If there are more than 50 children, remove the oldest at top
        while (sbMessages.children.length > 50) sbMessages.removeChild(sbMessages.firstChild);
        sbMessages.scrollTop = sbMessages.scrollHeight;
      }
    };

    // If user scrolls to the very top, show an external link to view all messages
    const viewAllId = 'shoutbox-view-all-link';
    function ensureViewAllLink(visible){
      let existing = document.getElementById(viewAllId);
      if (visible) {
        if (!existing) {
          const linkEl = document.createElement('div');
          linkEl.id = viewAllId;
          linkEl.style.padding = '6px';
          linkEl.style.textAlign = 'center';
          linkEl.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))';
          linkEl.style.cursor = 'pointer';
          linkEl.style.fontSize = '12px';
          linkEl.style.color = '#9ecbff';
          linkEl.textContent = 'See all messages on cor-forum.de';
          linkEl.addEventListener('click', () => { window.open('https://cor-forum.de', '_blank', 'noopener'); });
          sbMessages.insertBefore(linkEl, sbMessages.firstChild);
        }
      } else {
        if (existing) existing.remove();
      }
    }

    sbMessages.addEventListener('scroll', () => {
      // When scrolled to the very top, show the external link
      const atTop = sbMessages.scrollTop === 0;
      ensureViewAllLink(atTop);
    });

    function startShoutboxPolling(){
      const socket = window.getSocket && window.getSocket();
      if (socket && socket.connected) {
        fetchMessages();
        fetchLogMessages(); // Fetch log messages on start
      } else {
        console.warn('WebSocket not available for shoutbox, will wait for connection');
        // Retry after a short delay
        setTimeout(() => {
          const retrySocket = window.getSocket && window.getSocket();
            if (retrySocket && retrySocket.connected) {
              fetchMessages();
              fetchLogMessages(); // Fetch log messages on retry
            }
        }, 1000);
      }
    }

    // Listen for WebSocket connection if initializeWebSocket exposes an event
    if (window.addEventListener) {
      window.addEventListener('websocket:connected', () => {
        fetchMessages();
        fetchLogMessages();
      });
    }

    if(document.body.classList && document.body.classList.contains('authenticated')){
      startShoutboxPolling();
    } else {
      const ob = new MutationObserver((records)=>{
        if(document.body.classList && document.body.classList.contains('authenticated')){
          ob.disconnect(); startShoutboxPolling();
        }
      });
      try{ ob.observe(document.body, { attributes: true, attributeFilter: ['class'] }); }catch(e){}
    }

    // Ensure close button creates a small open button so users can reopen the shoutbox
    try {
      const shoutboxCloseBtn = document.getElementById('shoutbox-close-btn');
      function createOpenButton() {
        if (document.getElementById('shoutbox-open-btn')) return;
        const openBtn = document.createElement('button');
        openBtn.id = 'shoutbox-open-btn';
        openBtn.title = 'Open Chat';
        openBtn.textContent = 'Chat';
        openBtn.style.position = 'absolute';
        openBtn.style.left = '0px';
        openBtn.style.bottom = '52px';
        openBtn.style.width = '64px';
        openBtn.style.zIndex = '20005';
        openBtn.style.cursor = 'pointer';
        openBtn.style.padding = '6px';
        openBtn.style.background = 'linear-gradient(180deg, #1b2b44, #11202f)';
        openBtn.style.color = '#e6e6e6';
        openBtn.style.border = '1px solid #25446a';
        openBtn.style.borderRadius = '4px';
        openBtn.addEventListener('click', () => {
          try { sbWin.style.display = 'flex'; } catch (e) {}
          try { fetchMessages(); } catch (e) {}
          openBtn.remove();
          try { setUIWindowVisible('shoutbox-window', true); } catch (err) {}
        });
        (document.body || document.documentElement).appendChild(openBtn);
      }

      if (shoutboxCloseBtn) {
        shoutboxCloseBtn.addEventListener('click', (e) => {
          try { sbWin.style.display = 'none'; } catch (err) {}
          try { createOpenButton(); } catch (err) {}
          try { setUIWindowVisible('shoutbox-window', false); } catch (err) {}
        });
      }

      // Expose a global helper so other parts of the app can reopen the shoutbox
      window.openShoutbox = function() {
        try { sbWin.style.display = 'flex'; } catch (e) {}
        try { fetchMessages(); } catch (e) {}
        try { fetchLogMessages(); } catch (e) {}
        const b = document.getElementById('shoutbox-open-btn'); if (b) b.remove();
        try { setUIWindowVisible('shoutbox-window', true); } catch (err) {}
      };

      // Restore shoutbox visibility from stored uiWindows
      try {
        const ui = loadUIWindows();
        const val = ui && ui['shoutbox-window'];
        const isClosed = (val === false) || (val && typeof val === 'object' && (val.open === false || val.display === 'none'));
        if (isClosed) {
          try { sbWin.style.display = 'none'; } catch (e) {}
          try { createOpenButton(); } catch (e) {}
        } else {
          try { sbWin.style.display = 'flex'; } catch (e) {}
          const b = document.getElementById('shoutbox-open-btn'); if (b) b.remove();
        }
      } catch (e) {}
    } catch (e) {}
  })();
</script>
